'From Pharo4.0 of 18 March 2013 [Latest update: #40607] on 14 April 2015 at 9:52:49.547808 am'!----STARTUP----2015-04-14T09:52:16.024237+02:00 as /Users/denker/Desktop/40607/Pharo-40607.image!----QUIT----2015-04-14T09:52:53.433201+02:00 Pharo-40607.image priorSource: 0!----STARTUP----2015-04-14T09:53:10.503839+02:00 as /Users/denker/Desktop/40607/Pharo-40607.image!----QUIT----2015-04-14T09:53:23.786467+02:00 Pharo-40607.image priorSource: 196!----STARTUP----2015-04-14T12:27:52.175891+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 4/14/2015 12:25' prior: 55184883!commentForCurrentUpdate ^ 'new .sources'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 4/14/2015 12:25'!script608	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.189.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.683.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.171.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.88.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.120.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2011.mczKernelTests-TheIntegrator.767.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1009.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.341.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.166.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.641.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.55.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.110.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-StephaneDucasse.35.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.236.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.8.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-StephaneDucasse.1091.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.66.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 4/14/2015 12:25'!update40608	"self new update40608"	self withUpdateLog: 'new .sources'.	self loadTogether: self script608 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update40607!ScriptLoader removeSelector: #script607!"ScriptLoader40"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.786.mcz') load.ScriptLoader new update40608.!----End fileIn----!----QUIT----2015-04-14T12:27:53.326572+02:00 Pharo.image priorSource: 376!----STARTUP----2015-04-14T12:27:53.4798+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-04-14T12:27:57.217802+02:00 Pharo.image priorSource: 15532!----STARTUP----2015-04-14T12:42:49.686617+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-04-14T12:42:49.754863+02:00 Pharo-40608.image priorSource: 15722!----STARTUP----2015-04-15T17:06:01.522135+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'EstebanLorenzano 4/15/2015 17:02' prior: 33555098!commentForCurrentUpdate ^ '15341 remove download sources setting	https://pharo.fogbugz.com/f/cases/1534115342 Metaclasses should not have a source pointer	https://pharo.fogbugz.com/f/cases/15342'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'EstebanLorenzano 4/15/2015 17:02'!script609	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.189.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.683.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.171.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.88.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.120.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2011.mczKernelTests-TheIntegrator.767.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1009.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.341.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.166.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.641.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.55.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.110.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.236.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.8.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.66.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'EstebanLorenzano 4/15/2015 17:02'!update40609	"self new update40609"	Smalltalk allClasses do: [ :each | each class organization comment: nil; commentStamp: nil ].	self withUpdateLog: '15341 remove download sources setting	https://pharo.fogbugz.com/f/cases/1534115342 Metaclasses should not have a source pointer	https://pharo.fogbugz.com/f/cases/15342'.	self loadTogether: self script609 merge: false.	[ | workspace window |		workspace := Workspace openContents: '"Pharo 4.0=========Welcome to Pharo, an immersive live programming environment.You can learn pharo by highlighting the next line and selecting [Do it] from the context menu:"PharoTutorial go."Pharo 4.0 already comes pre-loaded with a rich set of packages that you can use to explore the system and develop your own applications. However there is also a huge library of user contributed projects that you can also load using the ''Configurations Browser'' by executing:"MetacelloConfigurationBrowser open."This browser is also accessible from the World | Tools menu (just click the desktop, select Tools, and then Configuration Browser).You can find information about Pharo on http://www.pharo.org. Some useful starting points are:- Joining us and getting help http://www.pharo.org/get-help- Getting the Pharo By Example book (available as a free PDF): http://www.pharobyexample.org- Browser the documentation http://www.pharo.org/documentation- Reporting problems http://www.pharo.org/get-involvedAbout this release---------------------------There are more than 1600 issues treated in this release. Sumarized issues for 4.0:=========================New stuff---------- GTools (Playground, Inspector, Spotter)- Slots model instance variables as first class enities and enable meta-programming on this level.- ShoreLine reporter: submit information automatically when errors happen- TxModel, a modern text model who works with Athens (Preview)- OSWindow, a new way to handle windows and input events (Preview)- Glamour, a mature declarative browser builder- Dark themeUpdated stuff-------------- Zinc/Zodiac- Fuel- VersionnerAnd a lot more!!You can check a more detailed explanation here: https://github.com/pharo-project/pharo-changelogs/blob/master/Pharo40ChangeLogs.md"'	label: 'Welcome to Pharo 4.0!!'.	window := workspace dependents detect: [ :each | 		(each isKindOf: SystemWindow) and: [ each label = 'Welcome to Pharo 4.0!!' ] ].	window extent: 700@400.window center: Display extent / 2  ] value.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update40608!ScriptLoader removeSelector: #script608!"ScriptLoader40"!!SmalltalkImage commentStamp: 'StephaneDucasse 6/7/2011 15:48' prior: 55982943!My singleton is a central entry point to the system.It has many roles and responsibilities (to be documented)	- startup/shutdown image	- source management	- namespace access	- tool access	- platform access	- VM information and parameters		Startup-----------At startup and shutdown the image execute the methods startUp: and shutdown: of registered classes (registered using addToStartUpList:, addToShutDownList:, ... methods and friends).	Startup phasesDuring the first stage of start up the UI manager, the default uimanager is switched to a specific non interactive ui manager (StartupUIManager). Note that this specific non interactive UIManager kills the system on any attempt to open windows and interaction. So be warned, don't use interaction in the first phase. Then all registered classes execute their start up procedures (which should not imply interactive behavior). After startup list is finished, any deferred startup actions are executed, which you can add using the methodaddDeferredStartupAction: method.  !!SystemSystemSettings class methodsFor: 'settings' stamp: 'EstebanLorenzano 4/15/2015 15:03' prior: 58207175!systemSettingOn: aBuilder	<systemsettings>	(aBuilder group: #pharoSystem) 		label: 'System';		description: 'General system settings' ;		with: [			(aBuilder setting: #serverMode)				label: 'Server mode';				target: WorldState;				description: 'If enabled, then each main rendering loop will always wait a complete delay of 50ms' .			(aBuilder setting: #useLocale)				label: 'Use locale';				target: Locale;				selector: #activated;				description: 'Use the system locale to set the system language at startup.']! !!SmalltalkImage commentStamp: 'StephaneDucasse 6/7/2011 15:48' prior: 33587555!My singleton is a central entry point to the system.It has many roles and responsibilities (to be documented)	- startup/shutdown image	- source management	- namespace access	- tool access	- platform access	- VM information and parameters		Startup-----------At startup and shutdown the image execute the methods startUp: and shutdown: of registered classes (registered using addToStartUpList:, addToShutDownList:, ... methods and friends).	Startup phasesDuring the first stage of start up the UI manager, the default uimanager is switched to a specific non interactive ui manager (StartupUIManager). Note that this specific non interactive UIManager kills the system on any attempt to open windows and interaction. So be warned, don't use interaction in the first phase. Then all registered classes execute their start up procedures (which should not imply interactive behavior). After startup list is finished, any deferred startup actions are executed, which you can add using the methodaddDeferredStartupAction: method.  !SmalltalkImage removeSelector: #shouldDownloadSourcesFile!SmalltalkImage class removeSelector: #shouldDownloadSourcesFile:!SmalltalkImage class removeSelector: #shouldDownloadSourcesFile!"Settings-System"!"System-Support"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-EstebanLorenzano.789.mcz') load.ScriptLoader new update40609.!----End fileIn----!----QUIT----2015-04-15T17:06:04.321261+02:00 Pharo.image priorSource: 15916!----STARTUP----2015-04-15T17:06:04.475077+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-04-15T17:06:08.61668+02:00 Pharo.image priorSource: 36763!----STARTUP----2015-04-15T17:17:40.057035+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-04-15T17:17:40.126384+02:00 Pharo-40609.image priorSource: 36957!----STARTUP----2015-04-23T13:55:03.41202+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 4/23/2015 13:52' prior: 33570647!commentForCurrentUpdate ^ '15349 The menu in the PharoTutorial has an erroneous label	https://pharo.fogbugz.com/f/cases/1534915375 backport pharo4: 15332 [Spec Help] protocol and protocol-events dont exist anymore	https://pharo.fogbugz.com/f/cases/15375'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 4/23/2015 13:52'!script610	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.189.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.683.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.171.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.88.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2011.mczKernelTests-TheIntegrator.767.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1009.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.341.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.166.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.641.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.110.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.236.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.66.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 4/23/2015 13:52'!update40610	"self new update40610"	self withUpdateLog: '15349 The menu in the PharoTutorial has an erroneous label	https://pharo.fogbugz.com/f/cases/1534915375 backport pharo4: 15332 [Spec Help] protocol and protocol-events dont exist anymore	https://pharo.fogbugz.com/f/cases/15375'.	self loadTogether: self script610 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40609!ScriptLoader removeSelector: #script609!"ScriptLoader40"!!HelpBrowser methodsFor: 'ui' stamp: 'SvenVanCaekenberghe 4/16/2015 21:29' prior: 26430124!menu	^ MenuMorph new		add: 'do it (d)' selector: #doIt;		add: 'print it (p)' selector: #printIt;		add: 'inspect it (i)' selector: #inspectIt;		yourself! !!SpecExamples class methodsFor: 'pages' stamp: 'BernardoContreras 4/17/2015 15:20' prior: 57222476!firstExample	^HelpTopic 		title: 'A first example: ModelList'		contents: 'Creating a specific UI always starts with the subclassing of Composable-Model. Each sub widget is stored into an instance variable of the newly created class. All the code presented here is already in the image so you can simply do: 			ModelList browseAnd follow the tutorial while browsing the code. So let''s subclass ComposableModel.	ComposableModel subclass: #ModelList	instanceVariableNames: ''list''	classVariableNames: ''	category: ''Spec-Examples''				The first required step then is to instantiate and define the sub widgets. This step is done in the method initializeWidgets. It creates the list and populates it with the required classes, in alphabetical order.	ModelList>>initializeWidgets	list := self newList.	list items: (AbstractWidgetModel allSubclasses	sorted: [:a :b | a name < b name ]).	self focusOrder add: list	The second required step is to define a layout, which is done on the class side. Since there is here only one sub widget, the layout is quite simple. It simply returns a layout that contains only the list:	ModelList class>>#defaultSpec	<spec: #default>	^ SpecLayout composed	add: #list;	yourself	The three last methods to define on ModelList are a getter, a method to display the UI title and a method to register to list selection changes.	"accessing"	ModelList>>list		^ list	"api"	ModelList>>title		^ ''Widgets''	"api-events"	ModelList>>whenSelectedItemChanged: aBlock		list whenSelectedItemChanged: aBlockThe first UI is now done. The result can be seen by executing the following snippet of code: 	ModelList new openWithSpec.'! !!SpecExamples class methodsFor: 'pages' stamp: 'BernardoContreras 4/17/2015 15:25' prior: 57224262!secondExample	^HelpTopic 		title: 'A second example: Protocol List'		contents: 'The next user interface is the protocol list. This UI combines two sub widgets: 		a list		a label.So again, we start by subclassing ComposableModel:	ComposableModel subclass: #ProtocolList	instanceVariableNames: ''label protocols''	classVariableNames: ''	category: ''Spec-Examples''	The initializeWidgets method for this UI is quite similar to the method in ModelList:	ProtocolList>>initializeWidgets		protocols := self newList.		label := self newLabel.		label text: ''Protocol''.		protocols displayBlock: [ :m | m selector ].		self focusOrder add: protocols	The layout method is quite different though. Now the sub widgets need to be placed more specifically than in the previous example, we have to build a layout that has a column with the label on top and the list taking all the space that is left.	ProtocolList class>>defaultSpec		<spec: #default>		^ SpecLayout composed		newColumn: [ :column |			column				add: #label					height: self toolbarHeight;					add: #protocols ];		yourself			The remaining methods are getters, sub widget delegation methods, a method to display the title, and a method to register to list selection changes: 	"accessing"	ProtocolList>>label		^ label	"accessing"	ProtocolList>>protocols		^ protocols	"api"	ProtocolList>>items: aCollection		protocols items: aCollection	"api"	ProtocolList>>label: aText		label label: aText	"api"	ProtocolList>>resetSelection		protocols resetSelection	"api"	ProtocolList>>title		^ ''Protocol widget''	"api-events"	ProtocolList>>whenSelectedItemChanged: aBlock		protocols whenSelectedItemChanged: aBlockThe ProtocolList UI can be seen by evaluating: ProtocolList new openWithSpec.'! !!LessonView methodsFor: 'gui' stamp: 'SvenVanCaekenberghe 4/16/2015 21:29' prior: 27700877!menu	^ MenuMorph new		add: 'do it (d)' selector: #doIt;		add: 'print it (p)' selector: #printIt;		add: 'inspect it (i)' selector: #inspectIt;		yourself! !!SpecHelpTopics class methodsFor: 'pages' stamp: 'BernardoContreras 4/17/2015 15:19' prior: 57227371!introduction	^HelpTopic 			title: 'About Spec'		contents: 'Spec has been originally developed by B. Van Ryseghem based on an idea of S. Ducasse. It is now maintained by the community and the pharo core team.. Spec is an attempt to support UI logic reuse. Spec is influenced by VisualWorks and Dolphin MVP in the sense that it recognizes the need for a Presenter or Application-Model class, in Spec called ComposableModel that manages the logic and the link between widgets and domain objects. Spec, following the tradition, uses value holders, simple object raising announcements when their values, often domain objects, change.'! !"HelpSystem-Core"!"ProfStef-Core"!"Spec-Help"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.790.mcz') load.ScriptLoader new update40610.!----End fileIn----!----QUIT----2015-04-23T13:55:05.772768+02:00 Pharo.image priorSource: 37150!----STARTUP----2015-04-23T13:55:05.929678+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-04-23T13:55:09.820052+02:00 Pharo.image priorSource: 57709!----STARTUP----2015-04-23T14:06:29.625404+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-04-23T14:06:29.693694+02:00 Pharo-40610.image priorSource: 57903!----STARTUP----2015-04-24T11:30:58.269253+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 4/24/2015 11:28' prior: 33591877!commentForCurrentUpdate ^ '15338 OrderedDictionary changes to merge	https://pharo.fogbugz.com/f/cases/1533815339 Monticello with spotter extension methods throws MNU errors when browsing packages in repos that dont contain every package	https://pharo.fogbugz.com/f/cases/15339'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 4/24/2015 11:28'!script611	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.171.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.88.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2011.mczKernelTests-TheIntegrator.767.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.166.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.641.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.110.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.236.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.66.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 4/24/2015 11:28'!update40611	"self new update40611"	self withUpdateLog: '15338 OrderedDictionary changes to merge	https://pharo.fogbugz.com/f/cases/1533815339 Monticello with spotter extension methods throws MNU errors when browsing packages in repos that dont contain every package	https://pharo.fogbugz.com/f/cases/15339'.	self loadTogether: self script611 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40610!ScriptLoader removeSelector: #script610!"ScriptLoader40"!!MCFileRepositoryInspector methodsFor: 'accessing' stamp: 'ThierryGoubier 4/15/2015 11:22' prior: 28331243!selectedPackageAncestors	selectedPackageAncestors		ifNil: [ 			selectedPackage				ifNotNil: [ 					(MCWorkingCopy registry at: (MCPackage named: selectedPackage) ifAbsent: [  ])						ifNotNil: [ :aWorkingCopy | selectedPackageAncestors := aWorkingCopy ancestry breadthFirstAncestors collect: #name ] ] ].	^ selectedPackageAncestors! !!OrderedIdentityDictionaryTest methodsFor: 'testing' stamp: 'monty 12/15/2014 16:44'!isTestingIdentityDictionary	^ true! !!MCVersionInfo methodsFor: 'initialization' stamp: 'ThierryGoubier 4/15/2015 09:41' prior: 28762933!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName.	id := aUUID.	message := aString.	date := aDate ifNil: [ Date today ].	time := aTime.	author := initials.	ancestors := aCollection.	stepChildren := stepCollection! !!OrderedDictionary methodsFor: 'adding' stamp: 'monty 4/14/2015 03:37' prior: 50556679!add: anAssociation	| oldSize |	oldSize := dictionary size.	dictionary add: anAssociation.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: anAssociation key].	^ anAssociation.! !!OrderedDictionary methodsFor: 'accessing' stamp: 'monty 4/14/2015 03:13' prior: 50552150!associationAt: aKey ifPresent: aBlock	^ dictionary associationAt: aKey ifPresent: aBlock! !!OrderedDictionary methodsFor: 'accessing' stamp: 'monty 4/14/2015 03:38' prior: 50552686!at: aKey put: aValue	| oldSize |	oldSize := dictionary size.	dictionary at: aKey put: aValue.	dictionary size > oldSize		ifTrue: [			orderedKeys size > oldSize				ifFalse: [self growOrderedKeys].			orderedKeys at: oldSize + 1 put: aKey].	^ aValue.! !!OrderedDictionary methodsFor: 'private' stamp: 'monty 4/14/2015 03:12' prior: 50557786!errorInvalidIndex: anIndex	SubscriptOutOfBounds signalFor: anIndex! !!OrderedDictionary methodsFor: 'accessing' stamp: 'monty 4/14/2015 02:20'!identityIndexOfKey: aKey	^ self identityIndexOfKey: aKey ifAbsent: [0]! !!OrderedDictionary methodsFor: 'private' stamp: 'monty 4/14/2015 02:19'!orderedKeysIndexOf: aKey	^ orderedKeys indexOf: aKey! !!OrderedDictionary methodsFor: 'private' stamp: 'monty 4/14/2015 03:36'!orderedKeysRemove: aRemovedKey	| index |	index := self orderedKeysIndexOf: aRemovedKey.	"shift every remaining key after to the left by one"	orderedKeys		replaceFrom: index		to: self size		with: orderedKeys		startingAt: index + 1.	"one key was removed and the rest shifted, so nil what was the last	key slot before removing and shifting"	orderedKeys		at: self size + 1		put: nil.! !!OrderedDictionary methodsFor: 'removing' stamp: 'monty 4/14/2015 01:26' prior: 50552529!removeKey: aKey	| value |	value := dictionary removeKey: aKey.	self orderedKeysRemove: aKey.	^ value.! !!OrderedDictionary methodsFor: 'removing' stamp: 'monty 4/14/2015 01:26' prior: 50549581!removeKey: aKey ifAbsent: aBlock	| oldSize value |	oldSize := dictionary size.	value := dictionary removeKey: aKey ifAbsent: aBlock.	dictionary size < oldSize		ifTrue: [self orderedKeysRemove: aKey].	^ value.! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:44' prior: 50576809!absentKey	self isTestingIdentityDictionary		ifTrue: [^ self identityAbsentKey]		ifFalse: [^ self nonIdentityAbsentKey]! !!OrderedDictionaryTest methodsFor: 'assertions' stamp: 'monty 12/15/2014 16:50'!assertRemovedKey: aKey from: aDictionary	self deny: (aDictionary includesKey: aKey).	aDictionary keys asArray, aDictionary orderedKeys asArray do: [:each |		self deny:			(self isTestingIdentityDictionary				ifTrue: [each == aKey]				ifFalse: [each = aKey])].! !!OrderedDictionaryTest methodsFor: 'assertions' stamp: 'monty 12/14/2014 16:35' prior: 50579258!assertSelector: aSelector collects: aCollection from: aDictionary	self		assert: (self emptyDictionary perform: aSelector) asArray = #();		assert: (aDictionary perform: aSelector) asArray = aCollection asArray! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:36' prior: 50586042!defaultCapacity	^ self emptyInternalDictionary capacity! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:44' prior: 50584960!dictionaryAssociations	self isTestingIdentityDictionary		ifTrue: [^ self identityDictionaryAssociations]		ifFalse: [^ self nonIdentityDictionaryAssociations]! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:34'!emptyInternalDictionary	^ self internalDictionaryClass new! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:44' prior: 50579135!internalDictionaryClass	self isTestingIdentityDictionary		ifTrue: [^ IdentityDictionary]		ifFalse: [^ Dictionary]! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:37'!internalDictionaryWithSingleAssociation	^ self internalDictionaryClass with: self singleAssociation! !!OrderedDictionaryTest methodsFor: 'testing' stamp: 'monty 12/15/2014 16:44'!isTestingIdentityDictionary	^ false! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:08'!nonIdentityAbsentKey	^ 'absentKey'! !!OrderedDictionaryTest methodsFor: 'accessing' stamp: 'monty 12/15/2014 16:08'!nonIdentityDictionaryAssociations	"Associations are grouped out of their natural sort order and	are copied so can be modified in one test without affecting others,	but the keys and values are identical each time for identity tests."	dictionaryAssociations ifNil: [		dictionaryAssociations :=		Array			with: 'testKey'->'testValue'			with: 'testKey3'->'testValue3'			with: 'testKey2'->'testValue2'			with: 'testKey4'->'testValue4'].	^ dictionaryAssociations collect: [:each | each copy].! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 12/15/2014 16:43'!testDictionary	| dictionary |	dictionary := self emptyDictionary.	self		assert: dictionary dictionary class == self internalDictionaryClass;		assert: dictionary dictionary = self emptyInternalDictionary.	dictionary := self dictionaryWithSingleAssociation.	self		assert: dictionary dictionary class == self internalDictionaryClass;		assert: dictionary dictionary = self internalDictionaryWithSingleAssociation.	dictionary := self dictionaryWithAssociations.	self		assert: dictionary dictionary class == self internalDictionaryClass;		assert: dictionary dictionary = self internalDictionaryWithAssociations.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 12/15/2014 16:36' prior: 50574882!testEqualsDictionary	| orderedDictionary unorderedDictionary |	"only works on Pharo"	orderedDictionary := self emptyDictionary.	unorderedDictionary := self emptyInternalDictionary.	unorderedDictionary = orderedDictionary		ifFalse: [^ self].	self assertDictionary: orderedDictionary equals: unorderedDictionary.	orderedDictionary addAll: self dictionaryAssociations.	self assertDictionary: orderedDictionary doesNotEqual: unorderedDictionary.		"Dictionary>>addAll: can only accept keyed collections as an argument, so newFrom: is	used instead."	unorderedDictionary := self internalDictionaryWithAssociations.	self assertDictionary: orderedDictionary equals: unorderedDictionary.	unorderedDictionary := self internalDictionaryClass newFrom: self dictionaryAssociations reversed.	self assertDictionary: orderedDictionary equals: unorderedDictionary.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 12/15/2014 16:41' prior: 50564184!testHash	| dictionary |	dictionary := self emptyDictionary.	self assert: dictionary hash = self emptyDictionary hash.	self emptyInternalDictionary hash =		self internalDictionaryWithSingleAssociation hash		ifFalse: [			self deny:				dictionary hash = self dictionaryWithSingleAssociation hash].	self emptyInternalDictionary hash = self internalDictionaryWithAssociations hash		ifFalse: [self deny: dictionary hash = self dictionaryWithAssociations hash].	dictionary := self dictionaryWithSingleAssociation.	self assert: dictionary hash = self dictionaryWithSingleAssociation hash.	(self internalDictionaryWithSingleAssociation hash =		self internalDictionaryWithAssociations hash)		ifFalse: [self deny: dictionary hash = self dictionaryWithAssociations hash].	dictionary := self dictionaryWithAssociations.	self assert: dictionary hash = self dictionaryWithAssociations hash.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 4/14/2015 02:30'!testIdentityIndexOfKey	| dictionary |	dictionary := self dictionaryWithAssociations.	dictionary keys withIndexDo: [:each :i |		self			assert: (dictionary identityIndexOfKey: each) = i;			assert: (dictionary identityIndexOfKey: each copy) isZero].	self assert: (dictionary identityIndexOfKey: self absentKey) isZero.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 4/14/2015 02:29'!testIdentityIndexOfKeyIfAbsent	| dictionary |	dictionary := self dictionaryWithAssociations.	dictionary keys withIndexDo: [:each :i |		self			assert: (dictionary identityIndexOfKey: each ifAbsent: [self absentValue]) = i;			assert:				(dictionary					identityIndexOfKey: each copy					ifAbsent: [self absentValue]) = self absentValue].	self assert:		(dictionary			identityIndexOfKey: self absentKey			ifAbsent: [self absentValue]) = self absentValue.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 4/14/2015 02:27' prior: 50589911!testIndexOfKeyIfAbsent	| dictionary |	dictionary := self dictionaryWithAssociations.	dictionary keys withIndexDo: [:each :i |		self assert: (dictionary indexOfKey: each ifAbsent: [self absentValue]) = i].	self assert:		(dictionary			indexOfKey: self absentKey			ifAbsent: [self absentValue]) = self absentValue.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 4/14/2015 03:21' prior: 50591000!testKeyAtIdentityValue	| dictionary singleValue |	dictionary := self dictionaryWithSingleAssociation.	singleValue := dictionary at: self singleKey.	self		should: [dictionary keyAtIdentityValue: self absentValue] raise: Error;		should: [dictionary keyAtIdentityValue: singleValue copy] raise: Error;		assert: (dictionary keyAtIdentityValue: singleValue) = self singleKey.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 4/14/2015 03:20' prior: 50586183!testKeyAtIdentityValueIfAbsent	| dictionary singleValue |	dictionary := self dictionaryWithSingleAssociation.	singleValue := dictionary at: self singleKey.	self assert:		(dictionary			keyAtIdentityValue: self absentValue			ifAbsent: [self absentKey]) = self absentKey.	self assert:		(dictionary			keyAtIdentityValue: singleValue copy			ifAbsent: [self absentKey]) = self absentKey.	self assert:		(dictionary			keyAtValue: singleValue			ifAbsent: [self absentKey]) = self singleKey.! !!OrderedDictionaryTest methodsFor: 'tests' stamp: 'monty 12/15/2014 15:58' prior: 50569249!testRemoveKey	| dictionary associationsToRemove |	dictionary := self dictionaryWithAssociations.	self should: [dictionary removeKey: self absentKey] raise: Error.	associationsToRemove := self dictionaryAssociations asOrderedCollection.	[associationsToRemove notEmpty]		whileTrue: [ | removed |			removed := associationsToRemove removeFirst.			self				assert: (dictionary removeKey: removed key) = removed value;				should: [dictionary removeKey: removed key] raise: Error;				assertRemovedKey: removed key from: dictionary;				assert: dictionary keys = (associationsToRemove collect: [:each | each key]) asArray].! !!OrderedIdentityDictionary methodsFor: 'private' stamp: 'monty 4/14/2015 02:20'!orderedKeysIndexOf: aKey	^ orderedKeys identityIndexOf: aKey! !!MCLazyVersionInfo methodsFor: 'initialization' stamp: 'ThierryGoubier 4/15/2015 09:41' prior: 28471913!initializeWithName: vName id: aUUID message: aString date: aDate time: aTime author: initials ancestors: aCollection stepChildren: stepCollection	name := vName.	id := aUUID.	message := aString.	date := aDate ifNil: [ Date today ].	time := aTime.	author := initials.	ancestors := WeakArray withAll: aCollection.	stepChildren := WeakArray withAll: stepCollection! !OrderedDictionary removeSelector: #deleteOrderedKey:!OrderedIdentityDictionaryTest removeSelector: #internalDictionaryClass!OrderedIdentityDictionaryTest removeSelector: #dictionaryAssociations!OrderedIdentityDictionaryTest removeSelector: #absentKey!"Collections-Sequenceable"!"CollectionsTests"!"Monticello"!"MonticelloGUI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.791.mcz') load.ScriptLoader new update40611.!----End fileIn----!----QUIT----2015-04-24T11:31:04.158257+02:00 Pharo.image priorSource: 58097!----STARTUP----2015-04-24T11:31:04.314727+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-04-24T11:31:08.184451+02:00 Pharo.image priorSource: 86474!----STARTUP----2015-04-24T11:41:04.485005+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-04-24T11:41:04.561394+02:00 Pharo-40611.image priorSource: 86668!----STARTUP----2015-05-04T10:36:15.561429+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/4/2015 10:33' prior: 33612825!commentForCurrentUpdate ^ '15417 TestRunner does not offer the RunCoverage functionality 	https://pharo.fogbugz.com/f/cases/1541715322 "Save As" does not properly save filenames with dots in them	https://pharo.fogbugz.com/f/cases/15322'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/4/2015 10:33'!script612	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2011.mczKernelTests-TheIntegrator.767.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.641.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.236.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.66.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/4/2015 10:33'!update40612	"self new update40612"	self withUpdateLog: '15417 TestRunner does not offer the RunCoverage functionality 	https://pharo.fogbugz.com/f/cases/1541715322 "Save As" does not properly save filenames with dots in them	https://pharo.fogbugz.com/f/cases/15322'.	self loadTogether: self script612 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40611!ScriptLoader removeSelector: #script611!"ScriptLoader40"!!FileReferenceTest methodsFor: 'tests' stamp: 'monty 4/9/2015 23:34' prior: 23421577!testBasenameWithoutExtension	"self debug: #testBasenameWithoutExtension"		| ref |		ref := filesystem root.	self assert: ref basename equals: '/'.		ref := filesystem * 'plonk' / 'griffle'.	self assert: ref basenameWithoutExtension equals: 'griffle'.	self assert: (ref basenameWithoutExtension: 'griffle') equals: 'griffle'.	self assert: (ref basenameWithoutExtension: 'taz') equals: 'griffle'.		ref := filesystem * 'plonk' / 'griffle.taz'.	self assert: ref basenameWithoutExtension equals: 'griffle'.	self assert: (ref basenameWithoutExtension: 'taz') equals: 'griffle'.	self assert: (ref basenameWithoutExtension: 'griffle.taz') equals: 'griffle.taz'.	self assert: (ref basenameWithoutExtension: 'zork') equals: 'griffle.taz'.		ref := filesystem * 'plonk' / 'griffle.taz.zork'.	self assert: ref basenameWithoutExtension equals: 'griffle.taz'.	self assert: (ref basenameWithoutExtension: 'zork') equals: 'griffle.taz'.	self assert: (ref basenameWithoutExtension: 'taz.zork') equals: 'griffle'.	self assert: (ref basenameWithoutExtension: 'griffle.taz.zork') equals: 'griffle.taz.zork'.	self assert: (ref basenameWithoutExtension: 'taz') equals: 'griffle.taz.zork'.! !!AbstractFileReference methodsFor: 'accessing' stamp: 'monty 4/9/2015 23:28'!basenameWithoutExtension: anExtension	"Returns the basename without specified extension (if any)	('/foo/gloops.taz' asFileReference basenameWithoutExtension: 'taz') = 'gloops'	"	^ self fullPath basenameWithoutExtension: anExtension! !!PathTest methodsFor: 'tests' stamp: 'monty 4/9/2015 23:33' prior: 50992571!testBasenameWithoutExtension	"self debug: #testBasenameWithoutExtension"	| path |	path := Path * 'plonk' / 'griffle'.	self assert: path basenameWithoutExtension equals: 'griffle'.	self assert: (path basenameWithoutExtension: 'griffle') equals: 'griffle'.	self assert: (path basenameWithoutExtension: 'taz') equals: 'griffle'.		path := Path * 'plonk' / 'griffle.taz'.	self assert: path basenameWithoutExtension equals: 'griffle'.	self assert: (path basenameWithoutExtension: 'taz') equals: 'griffle'.	self assert: (path basenameWithoutExtension: 'griffle.taz') equals: 'griffle.taz'.	self assert: (path basenameWithoutExtension: 'zork') equals: 'griffle.taz'.		path := Path * 'plonk' / 'griffle.taz.zork'.	self assert: path basenameWithoutExtension equals: 'griffle.taz'.	self assert: (path basenameWithoutExtension: 'zork') equals: 'griffle.taz'.	self assert: (path basenameWithoutExtension: 'taz.zork') equals: 'griffle'.	self assert: (path basenameWithoutExtension: 'girffle.taz.zork') equals: 'griffle.taz.zork'.	self assert: (path basenameWithoutExtension: 'taz') equals: 'griffle.taz.zork'.! !!TestRunner methodsFor: 'accessing-ui' stamp: 'SergioFedi 4/27/2015 21:47' prior: 58630987!buttons	^ #(( 'Run Selected' #runAll 'Run all selected tests' #hasRunnable )		( 'Run Profiled' #runProfiled 'Run tests and profile' #hasRunnable )		( 'Run Coverage' #runCoverage 'Run test and check code coverage' #hasRunnable )		( 'Run Failures' #runFailures 'Run all failures' #hasFailures )		( 'Run Errors' #runErrors 'Run all errors' #hasErrors )		( 'File out results' #fileOutResults 'File out test results' #hasFailuresOrErrors))! !!TestRunner methodsFor: 'actions' stamp: 'SergioFedi 4/27/2015 21:48' prior: 58614643!collectCoverageFor: methods	| wrappers suite |	wrappers := methods collect: [ :each | TestCoverage on: each ].	suite := self		resetResult;		suiteForAllSelected.		[ wrappers do: [ :each | each install ].	[ self runSuite: suite ] ensure: [ wrappers do: [ :each | each uninstall ] ] ] valueUnpreemptively.	wrappers := wrappers reject: [:each | each hasRun].	wrappers := wrappers collect: [:each | each reference].	wrappers isEmpty 		ifTrue:  [ UIManager default inform: 'Congratulations. Your tests cover all code under analysis.' ]		ifFalse: [ 			Smalltalk tools messageList 				browse: wrappers				title: 'Not Covered Code (' , (100 - (100 * wrappers size // methods size)) printString , '% Code Coverage)'].	self saveResultInHistory! !!Path methodsFor: 'accessing' stamp: 'monty 4/9/2015 23:28'!basenameWithoutExtension: anExtension	"Returns the basename without specified extension (if any)	('/foo/gloops.taz' asPath basenameWithoutExtension: 'taz') = 'gloops'	"	| extensionWihtDelimiter |	extensionWihtDelimiter := anExtension copyWithFirst: self extensionDelimiter.	(self basename endsWith: extensionWihtDelimiter)		ifTrue: [^ self basename allButLast: extensionWihtDelimiter size]		ifFalse: [ ^ self basename ]! !!WorldState class methodsFor: 'world menu items' stamp: 'monty 4/9/2015 23:29' prior: 61812197!saveAs	| reference |	reference := UIManager default fileSave: 'New File Name?' extensions: #('image') path: Smalltalk imageDirectory.	reference ifNotNil: [ Smalltalk saveAs: reference parent / (reference basenameWithoutExtension: 'image') ]! !"FileSystem-Core"!"FileSystem-Tests-Core"!"Morphic-Core"!"SUnit-UI"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.792.mcz') load.ScriptLoader new update40612.!----End fileIn----!----QUIT----2015-05-04T10:36:19.183664+02:00 Pharo.image priorSource: 86862!----STARTUP----2015-05-04T10:36:19.338418+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-05-04T10:36:23.139051+02:00 Pharo.image priorSource: 107478!----STARTUP----2015-05-04T10:45:08.078705+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-05-04T10:45:08.150291+02:00 Pharo-40612.image priorSource: 107672!----STARTUP----2015-05-05T15:47:04.643301+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/5/2015 15:45' prior: 33641589!commentForCurrentUpdate ^ '15423 Backport Pharo4: 15422 SHTextStyler>>#styleInBackgroundProcess: should not set the text if styling process was terminated	https://pharo.fogbugz.com/f/cases/1542315492 Backport Nautilus MergeGroups + sourceNodeForPC should use #methodNode	https://pharo.fogbugz.com/f/cases/15492'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/5/2015 15:45'!script613	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2013.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.115.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.238.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/5/2015 15:45'!update40613	"self new update40613"	self withUpdateLog: '15423 Backport Pharo4: 15422 SHTextStyler>>#styleInBackgroundProcess: should not set the text if styling process was terminated	https://pharo.fogbugz.com/f/cases/1542315492 Backport Nautilus MergeGroups + sourceNodeForPC should use #methodNode	https://pharo.fogbugz.com/f/cases/15492'.	self loadTogether: self script613 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40612!ScriptLoader removeSelector: #script612!"ScriptLoader40"!!SHTextStyler methodsFor: 'styling' stamp: 'AndreiChis 5/4/2015 13:31' prior: 54999964!styleInBackgroundProcess: aText	self terminateBackgroundStylingProcess.	stylingEnabled		ifFalse: [ ^ self ].	text := aText copy.	self monitor		critical: [ 			sem := Semaphore new.			[ 				sem notNil					ifTrue: [ 						sem 							waitTimeoutSeconds: 5							onCompletion: [ view ifNotNil: [ view stylerStyledInBackground: text ] ]							onTimeout: [ "do nothing if the styling has not finished or the process turned into a zombie." ] ] 			] forkAt: Processor activePriority.			backgroundProcess := [ 			self privateStyle: text.			sem signal ] forkAt: Processor userBackgroundPriority ]! !!DelayWaitTimeout methodsFor: 'waiting' stamp: 'AndreiChis 5/4/2015 13:30'!waitOnCompletion: completionBlock onTimeout: timeoutBlock	"Wait until either the semaphore is signaled or the delay times out.	If the delay times out execute timeoutBlock, otherwise if the semaphore is signaled execute completionBlock.	Return the value returned by the executed block."	^ self wait		ifTrue: [ timeoutBlock value ]		ifFalse: [ completionBlock value]! !!SemaphoreTest methodsFor: 'tests' stamp: 'AndreiChis 5/4/2015 13:31'!testWaitTimeoutSecondsOnCompletionOnTimeout	"Ensure that waitTimeoutSeconds:onCompletion:onTimeout: behaves properly"	"Ensure that a timed out waitTimeoutSeconds:onCompletion:onTimeout: returns the value of the timeout block"	self assert: (Semaphore new 		waitTimeoutSeconds: 0.05		onCompletion: [ #completed ]		onTimeout: [ #timeout ] ) == #timeout.	"Ensure that a signaled waitTimeoutSeconds:onCompletion:onTimeout: returns the value of the completed block"	self assert: (Semaphore new signal		waitTimeoutSeconds: 0.05		onCompletion: [ #completed ]		onTimeout: [ #timeout ]) == #completed.! !!AbstractTool methodsFor: 'group' stamp: 'MarcusDenker 5/5/2015 15:10' prior: 17544396!mergeGroups: aCollection	aCollection		ifNotEmpty: [:groups || group |			group := groups reduce: [:a :b | a or: b].			groups do: [:gp | 				gp removable					ifTrue: [self groupsManager removeAGroupSilently: gp]].				^ group].	^ nil! !!RBBlockNode methodsFor: '*OpalCompiler-Core' stamp: 'MarcusDenker 5/5/2015 15:10' prior: 52182722!sourceNodeForPC: anInteger 	^ self methodNode sourceNodeForPC: anInteger! !!Semaphore methodsFor: 'communication' stamp: 'AndreiChis 5/4/2015 13:31'!waitTimeoutSeconds: anInteger onCompletion: completionBlock onTimeout: timeoutBlock	"Wait on this semaphore for up to the given number of seconds, then timeout.	If the deadline expired execute timeoutBlock, otherwise execute completionBlock.	Return the value returned by the executed block."	| d |	d := DelayWaitTimeout new setDelay: (anInteger * 1000 max: 0) forSemaphore: self.	^d waitOnCompletion: completionBlock onTimeout: timeoutBlock! !"Kernel"!"KernelTests"!"OpalCompiler-Core"!"Shout"!"Tool-Base"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.793.mcz') load.ScriptLoader new update40613.!----End fileIn----!----QUIT----2015-05-05T15:47:10.552244+02:00 Pharo.image priorSource: 107867!----STARTUP----2015-05-05T15:47:10.712169+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-05-05T15:47:14.435205+02:00 Pharo.image priorSource: 126487!----STARTUP----2015-05-05T15:56:45.728351+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-05-05T15:56:45.798918+02:00 Pharo-40613.image priorSource: 126682!----STARTUP----2015-05-26T16:27:18.934807+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 5/26/2015 16:25' prior: 33662595!commentForCurrentUpdate ^ '15284 [Backport 4.0]: 15384 kommiter throws DNU when browsing remotes	https://pharo.fogbugz.com/f/cases/15284'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 5/26/2015 16:25'!script614	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2013.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.215.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.12.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.238.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 5/26/2015 16:25'!update40614	"self new update40614"	self withUpdateLog: '15284 [Backport 4.0]: 15384 kommiter throws DNU when browsing remotes	https://pharo.fogbugz.com/f/cases/15284'.	self loadTogether: self script614 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40613!ScriptLoader removeSelector: #script613!"ScriptLoader40"!!RemotesManager methodsFor: 'private' stamp: 'SeanDeNigris 4/4/2015 09:32' prior: 54039491!buildRoots	^ MCRepositoryGroup default repositories		select: [ :each | each isCache not ]		thenCollect: [ :each || remote  |						remote := each koRemote.			TreeNodeModel new				content: remote;				hasContentToShow: true;				selected: ( self selectedRemotes includes: each );				whenSelectedChanged: [ :bool | self selected: each changed: bool ] ;				yourself ]! !!RemotesManager methodsFor: 'private' stamp: 'SeanDeNigris 4/4/2015 09:32' prior: 54039163!selected: aRepository changed: selected	selected		ifTrue: [ self selectedRemotes add: aRepository ]		ifFalse: [ self selectedRemotes remove: aRepository ].	selectedChangedBlock ifNotNil: 		[ selectedChangedBlock cull: aRepository cull: selected ] ! !!RemotesManager methodsFor: 'api' stamp: 'SeanDeNigris 4/4/2015 09:34' prior: 54040083!selectedRemotes: aRemoteList	selectedRemotes := aRemoteList asSet! !"Komitter"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.794.mcz') load.ScriptLoader new update40614.!----End fileIn----!----QUIT----2015-05-26T16:27:20.757246+02:00 Pharo.image priorSource: 126877!----STARTUP----2015-05-26T16:27:20.912563+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-05-26T16:27:24.898441+02:00 Pharo.image priorSource: 143201!----STARTUP----2015-05-26T16:36:46.010192+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-05-26T16:36:46.084005+02:00 Pharo-40614.image priorSource: 143396!----STARTUP----2015-06-23T10:43:18.96833+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/23/2015 10:41' prior: 33681606!commentForCurrentUpdate ^ '15797 Backport 4.0: New PackageManifests should be classes, not instances	https://pharo.fogbugz.com/f/cases/15797'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/23/2015 10:41'!script615	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.270.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.238.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/23/2015 10:41'!update40615	"self new update40615"	self withUpdateLog: '15797 Backport 4.0: New PackageManifests should be classes, not instances	https://pharo.fogbugz.com/f/cases/15797'.	self loadTogether: self script615 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40614!ScriptLoader removeSelector: #script614!"ScriptLoader40"!!TheManifestBuilder commentStamp: 'StephaneDucasse 1/6/2014 20:52' prior: 59049974!I'm a tool to build manifest that handles small lint false positive and other information.My name is strange but this is to avoid to match with a Manifest class which is recognized because it starts with Manifest*.!!PackageTreeNautilusTest methodsFor: 'tests' stamp: 'ChristopheDemarey 6/18/2015 15:08' prior: 50747168!testPackagePatternStringRootPackageTag	lastValue := SharedPackageFilterPatternsHolder instance lastValue.	SharedPackageFilterPatternsHolder instance lastValue: ''.	self compiledMethod: (Object>>#=).	nautilus := PackageTreeNautilus openOnMethod: compiledMethod.	self assertSelectedCompiledMethod.	nautilus packagePatternString: 'H'.	self assertSelectedCompiledMethod.	nautilus packagePatternString: 'anything long'.	self assertSelectedCompiledMethod.	nautilus packagePatternString: ''.	self assertSelectedCompiledMethod.! !!PackageManifest class methodsFor: 'code-critics' stamp: 'ChristopheDemarey 6/18/2015 13:46'!rejectClasses	^ #()! !!PackageManifest class methodsFor: 'code-critics' stamp: 'ChristopheDemarey 6/18/2015 13:46'!rejectRules	^ #()! !!RPackage methodsFor: '*Manifest-Core' stamp: 'ChristopheDemarey 6/18/2015 13:48' prior: 53582145!packageManifest	^ self classes		detect: [ :each | each isManifest ]		ifNone: [ TheManifestBuilder new createManifestNamed: name]! !!TheManifestBuilder commentStamp: 'StephaneDucasse 1/6/2014 20:52' prior: 33712864!I'm a tool to build manifest that handles small lint false positive and other information.My name is strange but this is to avoid to match with a Manifest class which is recognized because it starts with Manifest*.!!TheManifestBuilder methodsFor: 'private' stamp: 'ChristopheDemarey 6/18/2015 13:54' prior: 59064401!compileSelector: selector returnValue: arrayString	manifestClass class		compile: selector asString , Character cr asString , '^ ' , arrayString 		classified: 'code-critics'! !!TheManifestBuilder methodsFor: 'accessing' stamp: 'ChristopheDemarey 6/18/2015 13:53' prior: 59064957!manifest	^ manifestClass! !PackageManifest removeSelector: #rejectRules!PackageManifest removeSelector: #rejectClasses!PackageManifest removeSelector: #hash!PackageManifest removeSelector: #=!"Kernel"!"Manifest-Core"!"Nautilus-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.795.mcz') load.ScriptLoader new update40615.!----End fileIn----!----QUIT----2015-06-23T10:43:23.558445+02:00 Pharo.image priorSource: 143591!----STARTUP----2015-06-23T10:43:23.717223+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-06-23T10:43:27.497364+02:00 Pharo.image priorSource: 161284!----STARTUP----2015-06-23T10:52:11.21743+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-06-23T10:52:11.293573+02:00 Pharo-40615.image priorSource: 161479!----STARTUP----2015-06-29T10:38:16.525934+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/29/2015 10:36' prior: 33698319!commentForCurrentUpdate ^ '15680 Backport 4.0: Class rename does not update references in class-side methods	https://pharo.fogbugz.com/f/cases/15680'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/29/2015 10:36'!script616	^ 'AST-Core-TheIntegrator.283.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.909.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-AndreiChis.187.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.238.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/29/2015 10:36'!update40616	"self new update40616"	self withUpdateLog: '15680 Backport 4.0: Class rename does not update references in class-side methods	https://pharo.fogbugz.com/f/cases/15680'.	self loadTogether: self script616 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40615!ScriptLoader removeSelector: #script615!"ScriptLoader40"!!RBNamespace methodsFor: 'accessing' stamp: 'ThomasHeniart 6/12/2015 10:08' prior: 52664882!allReferencesToClass: aRBClass do: aBlock	self		allClassesDo: [ :each | 			(each whichSelectorsReferToClass: aRBClass) do: [ :sel | aBlock value: (each methodFor: sel) ].			(each theMetaClass whichSelectorsReferToClass: aRBClass)				do: [ :sel | aBlock value: (each theMetaClass methodFor: sel) ] ]! !!RBRenameClassRefactoring methodsFor: 'initialize-release' stamp: 'ThomasHeniart 6/12/2015 10:09' prior: 53058623!className: aName newName: aNewName	className := aName asSymbol.	class := self model classNamed: className.	newName := aNewName asSymbol! !"Refactoring-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.796.mcz') load.ScriptLoader new update40616.!----End fileIn----!----QUIT----2015-06-29T10:38:18.397657+02:00 Pharo.image priorSource: 161673!----STARTUP----2015-06-29T10:38:18.576311+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-06-29T10:38:22.689866+02:00 Pharo.image priorSource: 177713!----STARTUP----2015-06-29T10:51:13.319291+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-06-29T10:51:13.402172+02:00 Pharo-40616.image priorSource: 177908!----STARTUP----2015-06-30T16:02:18.919025+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 6/30/2015 16:00' prior: 33716402!commentForCurrentUpdate ^ '14387 ressurrect format on accept and format on display	https://pharo.fogbugz.com/f/cases/14387'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 6/30/2015 16:00'!script617	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.160.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 6/30/2015 16:00'!update40617	"self new update40617"	self withUpdateLog: '14387 ressurrect format on accept and format on display	https://pharo.fogbugz.com/f/cases/14387'.	self loadTogether: self script617 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40616!ScriptLoader removeSelector: #script616!"ScriptLoader40"!!RBConfigurableFormatter commentStamp: '<historical>' prior: 52318551!RBConfigurableFormatter formats the Refactoring Browser's parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.Instance Variables:	codeStream	<PositionableStream>	the stream we are writing our output to	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.!!MethodDefinitionAcceptor methodsFor: 'protocol' stamp: 'PaulDeBruicker 6/10/2015 13:47' prior: 30708185!accept: source notifying: aController	| protocol method |	RBConfigurableFormatter formatOnAccept		ifTrue: [ self model sourceTextArea formatSourceCode ].	protocol := self model selectedCategory.	method := self model selectedMethod.	protocol ifNil: [ protocol := method ifNil: [ Protocol unclassified ] ifNotNil: [ method protocol ] ].	self model compileAMethodFromCategory: protocol withSource: source notifying: aController! !!SHTextStyler methodsFor: 'formatting' stamp: 'PaulDeBruicker 6/10/2015 13:47' prior: 54998777!format: aText 	| tree |	self terminateBackgroundStylingProcess.	RBConfigurableFormatter formatOnDisplay		ifTrue: [ 			tree := RBParser parseMethod: aText onError: [ :msg :pos | ^ aText ].			^ tree formattedCode ]		ifFalse: [ ^ aText ]! !!RubSHTextStylerST80 methodsFor: 'private' stamp: 'PaulDeBruicker 6/11/2015 17:14'!format: aText	self terminateBackgroundStylingProcess.	^ aText! !!RBConfigurableFormatter commentStamp: '<historical>' prior: 33747331!RBConfigurableFormatter formats the Refactoring Browser's parse trees. It has many more formatting options than the default formatter used by the RB. To change the RB to use this formatter, execute "RBProgramNode formatterClass: RBConfigurableFormatter". For some refactorings the RB must reformat the code after the change, so it is good to have a formatter configured to your tastes.Instance Variables:	codeStream	<PositionableStream>	the stream we are writing our output to	indent	<Integer>	how many times are we indenting a new line -- indents are normally tabs but could be any whitespace string	lineStart	<Integer>	the position of the character that started the current line. This is used for calculating the line length.	lookaheadCode	<Dictionary key: RBProgramNode value: String>	sometimes we need to lookahead while formatting, this dictionary contains the nodes that have already been formatted by lookahead	originalSource	<String>	the original source before we started formatting. This is used to extract the comments from the original source.!!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnAccept	^FormatOnAccept ifNil:[false]! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:45'!formatOnAccept:aBoolean	FormatOnAccept :=aBoolean! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnDisplay	^FormatOnDisplay ifNil:[false]! !!RBConfigurableFormatter class methodsFor: 'accessing' stamp: 'PaulDeBruicker 6/10/2015 13:44'!formatOnDisplay:aBoolean	FormatOnDisplay :=aBoolean! !!RBConfigurableFormatter class methodsFor: 'initialization' stamp: 'PaulDeBruicker 6/10/2015 13:45' prior: 52338947!initialize	CascadedMessageInsideParentheses := false.	FormatCommentWithStatements := true.	IndentString := String with: Character tab.	IndentsForKeywords := 1.	KeepBlockInMessage := true.	LineUpBlockBrackets := false.	MaxLineLength := 120.	MethodSignatureOnMultipleLines := false.	MinimumNewLinesBetweenStatements := 1.	MultiLineMessages := #(#ifTrue:ifFalse: #ifFalse:ifTrue: #ifTrue: #ifFalse: #on:do: #ensure: #ifCurtailed:).	NewLineAfterCascade := true.	NewLineBeforeFirstCascade := true.	NewLineBeforeFirstKeyword := false.	NewLinesAfterMethodComment := 2.	NewLinesAfterMethodPattern := 1.	NewLinesAfterTemporaries := 1.	NumberOfArgumentsForMultiLine := 4.	OneLineMessages := #(#to: #to:do: #to:by: #to:by:do:).	PeriodsAtEndOfBlock := false.	PeriodsAtEndOfMethod := false.	RetainBlankLinesBetweenStatements := false.	RetainBlankLinesBeforeComments := false.	StringFollowingReturn := ' '.	StringInsideBlocks := ' '.	StringInsideParentheses := ''.	TraditionalBinaryPrecedence := #(#($| $& $?) #($= $~ $< $>) #($- $+) #($* $/ $% $\) #($@)).	UseTraditionalBinaryPrecedenceForParentheses := true.	FormatOnAccept := false.	FormatOnDisplay := false! !!RBConfigurableFormatter class methodsFor: 'settings' stamp: 'PaulDeBruicker 6/10/2015 13:46' prior: 52344181!settingsOn: aBuilder	<systemsettings>	(aBuilder group: #configurableFormatter)		target: self;		parent: #codeBrowsing;		label: 'Pretty Printing';		description: 'Settings related to the formatter';		with: [ 					(aBuilder setting: #cascadedMessageInsideParentheses) label: 'Cascaded message inside parentheses'.					(aBuilder setting: #formatCommentWithStatements) label: 'Format comment with statements'.					(aBuilder setting: #indentString) label: 'Indent string'.					(aBuilder setting: #indentsForKeywords) label: 'Indents for keywords'.					(aBuilder setting: #keepBlockInMessage) label: 'Keep block in message'.					(aBuilder setting: #lineUpBlockBrackets) label: 'Line up block brackets'.					(aBuilder setting: #methodSignatureOnMultipleLines) label: 'Method signature on multiple lines'.					(aBuilder setting: #maxLineLength) label: 'Max line length'.					(aBuilder setting: #oneLineMessages) label: 'One line messages'.					(aBuilder setting: #multiLineMessages) label: 'Multi line messages'.					(aBuilder setting: #minimumNewLinesBetweenStatements) label: 'Minimum new lines between statements'.					(aBuilder setting: #newLineAfterCascade) label: 'New line after cascade'.					(aBuilder setting: #newLineBeforeFirstCascade) label: 'New line before first cascade'.					(aBuilder setting: #newLineBeforeFirstKeyword) label: 'New line before first keyword'.					(aBuilder setting: #newLinesAfterMethodComment) label: 'New lines after method comment'.					(aBuilder setting: #newLinesAfterMethodPattern) label: 'New lines after method pattern'.					(aBuilder setting: #newLinesAfterTemporaries) label: 'New lines after temporaries'.					(aBuilder setting: #numberOfArgumentsForMultiLine) label: 'Number of arguments for multi line'.					(aBuilder setting: #periodsAsTerminators) label: 'Periods as terminators'.					(aBuilder setting: #periodsAtEndOfBlock) label: 'Periods at end of block'.					(aBuilder setting: #periodsAtEndOfMethod) label: 'Periods at end of method'.					(aBuilder setting: #retainBlankLinesBetweenStatements) label: 'Retain blank lines between statements'.					(aBuilder setting: #retainBlankLinesBeforeComments) label: 'Retain blank lines before comments'.					(aBuilder setting: #stringFollowingReturn) label: 'String following return'.					(aBuilder setting: #stringInsideBlocks) label: 'String inside blocks'.					(aBuilder setting: #stringInsideParentheses) label: 'String inside parentheses'.					(aBuilder setting: #traditionalBinaryPrecedence) label: 'Traditional binary precedence'.					(aBuilder setting: #useTraditionalBinaryPrecedenceForParentheses)						label: 'Use traditional binary precedence for parentheses'.					(aBuilder setting: #formatOnDisplay) label: 'Format methods on display'.					(aBuilder setting: #formatOnAccept) label: 'Format methods on accept' ]! !"AST-Core"!"Nautilus"!"Rubric"!"Shout"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.797.mcz') load.ScriptLoader new update40617.!----End fileIn----!----QUIT----2015-06-30T16:02:24.097036+02:00 Pharo.image priorSource: 178103!----STARTUP----2015-06-30T16:02:24.277047+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-06-30T16:02:28.318556+02:00 Pharo.image priorSource: 201621!----STARTUP----2015-06-30T16:12:15.384368+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-06-30T16:12:15.466014+02:00 Pharo-40617.image priorSource: 201816!----STARTUP----2015-07-06T10:10:06.66953+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-07-06T10:10:06.762223+02:00 Pharo.image priorSource: 202011!----STARTUP----2015-07-06T10:10:06.947275+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-07-06T10:10:11.173128+02:00 Pharo.image priorSource: 202215!----STARTUP----2015-07-06T10:55:35.529342+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-07-06T10:55:35.68924+02:00 Pharo-40617.image priorSource: 202410!----STARTUP----2015-07-10T14:54:33.894643+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 7/10/2015 14:51' prior: 33732832!commentForCurrentUpdate ^ '15929 backport Pharo4: Revisiting RBUnpackagedCodeRule	https://pharo.fogbugz.com/f/cases/15929'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 7/10/2015 14:52'!script618	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.57.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.162.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 7/10/2015 14:52'!update40618	"self new update40618"	self withUpdateLog: '15929 backport Pharo4: Revisiting RBUnpackagedCodeRule	https://pharo.fogbugz.com/f/cases/15929'.	self loadTogether: self script618 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40617!ScriptLoader removeSelector: #script617!"ScriptLoader40"!!RBUnpackagedCodeRule methodsFor: 'running' stamp: 'YuriyTymchuk 7/8/2015 23:21' prior: 53274944!checkClass: aClass 	(self isUnpackaged: aClass) ifTrue: [		self result addClass: aClass ]! !!RBUnpackagedCodeRule methodsFor: 'running' stamp: 'YuriyTymchuk 7/8/2015 23:22' prior: 53274679!checkMethod: aMethod	(self isUnpackaged: aMethod) ifTrue: [		self result addMethod: aMethod ]! !!RBUnpackagedCodeRule methodsFor: 'running' stamp: 'YuriyTymchuk 7/8/2015 22:20'!isUnpackaged: anEntity	^ anEntity package isDefault! !"Refactoring-Critics"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.798.mcz') load.ScriptLoader new update40618.!----End fileIn----!----QUIT----2015-07-10T14:54:36.260693+02:00 Pharo.image priorSource: 202605!----STARTUP----2015-07-10T14:54:36.60957+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-07-10T14:54:40.758699+02:00 Pharo.image priorSource: 218468!----STARTUP----2015-07-10T15:04:42.067356+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-07-10T15:04:42.144693+02:00 Pharo-40618.image priorSource: 218662!----STARTUP----2015-07-31T10:06:18.832287+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-07-31T10:06:18.906559+02:00 Pharo.image priorSource: 218857!----STARTUP----2015-07-31T10:06:19.075251+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-07-31T10:06:22.858108+02:00 Pharo.image priorSource: 219062!----STARTUP----2015-07-31T10:26:48.632214+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-07-31T10:26:48.709608+02:00 Pharo-40618.image priorSource: 219257!----STARTUP----2015-08-26T17:19:17.276651+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 8/26/2015 17:16' prior: 33757333!commentForCurrentUpdate ^ '16362 Backport Pharo4: 16131 RBModifiesCollectionRule breaks methods AST when checking	https://pharo.fogbugz.com/f/cases/1636216069 backport Pharo4: 16067 remove #prepareDebuggerExample	https://pharo.fogbugz.com/f/cases/1606916081 Backport Pharo: 16080 RBImplementedButNotSent always true	https://pharo.fogbugz.com/f/cases/16081'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 8/26/2015 17:16'!script619	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.58.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 8/26/2015 17:16'!update40619	"self new update40619"	self withUpdateLog: '16362 Backport Pharo4: 16131 RBModifiesCollectionRule breaks methods AST when checking	https://pharo.fogbugz.com/f/cases/1636216069 backport Pharo4: 16067 remove #prepareDebuggerExample	https://pharo.fogbugz.com/f/cases/1606916081 Backport Pharo: 16080 RBImplementedButNotSent always true	https://pharo.fogbugz.com/f/cases/16081'.	self loadTogether: self script619 merge: false.	self flushCaches.self cleanRepositories.! !ScriptLoader removeSelector: #update40618!ScriptLoader removeSelector: #script618!"ScriptLoader40"!!RBImplementedNotSentRule methodsFor: 'cache' stamp: 'MarcusDenker 8/25/2015 08:16' prior: 52474310!literals    "return all 'message sends' in the systed and cache them"    literals ifNil: [        literals := IdentitySet new.        Smalltalk specialSelectors do: [:sel |            sel isSymbol ifTrue: [ literals add: sel ] ].        result rootEnvironment methodsDo: [ :meth |            meth literals do: [ :lit | (meth hasLiteral: lit) ifTrue: [self addLiteral: lit]]]].            "here we do a second check as #literals returns all literals even the one storing             method name"    ^ literals! !!RBModifiesCollectionRule methodsFor: 'private' stamp: 'MarcusDenker 8/25/2015 08:29' prior: 52627713!modifiesTree: aCollectionTree in: aParseTree 	| notifier args |	notifier := RBParseTreeSearcher new.	args := Array with: (RBPatternVariableNode named: '`@object').	notifier 		matchesAnyTreeOf: (#(add: addAll: remove: removeAll:) collect: 					[:each | 					RBMessageNode 						receiver: aCollectionTree copy						selector: each						arguments: args])		do: [:aNode :answer | true].	^notifier executeTree: aParseTree initialAnswer: false! !PharoSyntaxTutorial removeSelector: #prepareDebuggerExample!PharoSyntaxTutorial removeSelector: #initialize!"ProfStef-Core"!"Refactoring-Critics"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.802.mcz') load.ScriptLoader new update40619.!----End fileIn----!----QUIT----2015-08-26T17:19:20.432137+02:00 Pharo.image priorSource: 219452!----STARTUP----2015-08-26T17:19:20.598586+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-08-26T17:19:24.761874+02:00 Pharo.image priorSource: 236604!----STARTUP----2015-08-26T17:59:14.8342+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-08-26T17:59:15.018924+02:00 Pharo-40619.image priorSource: 236799!----STARTUP----2015-08-28T15:17:16.060902+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 8/28/2015 15:15' prior: 33774181!commentForCurrentUpdate ^ '16388 Backport Pharo4: 16387 remove Cursor read showWhile: from ImageReadWriter>>#formFromStream:	https://pharo.fogbugz.com/f/cases/16388'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 8/28/2015 15:15'!script620	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.383.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 8/28/2015 15:15'!update40620	"self new update40620"	self withUpdateLog: '16388 Backport Pharo4: 16387 remove Cursor read showWhile: from ImageReadWriter>>#formFromStream:	https://pharo.fogbugz.com/f/cases/16388'.	self loadTogether: self script620 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40619!ScriptLoader removeSelector: #script619!"ScriptLoader40"!!ImageReadWriter class methodsFor: 'image reading/writing' stamp: 'MarcusDenker 8/28/2015 09:43' prior: 26775261!formFromStream: aBinaryStream 	"Answer a ColorForm stored on the given stream.  closes the stream"	| reader readerClass form |	readerClass := self withAllSubclasses 		detect: [ :subclass | subclass understandsImageFormat: aBinaryStream ]		ifNone: 			[ aBinaryStream close.			^ self error: 'image format not recognized' ].	reader := readerClass new on: aBinaryStream reset.	form := reader nextImage.	reader close.	^ form! !"Graphics-Files"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.803.mcz') load.ScriptLoader new update40620.!----End fileIn----!----QUIT----2015-08-28T15:17:17.767005+02:00 Pharo.image priorSource: 236992!----STARTUP----2015-08-28T15:17:17.93146+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-08-28T15:17:21.845199+02:00 Pharo.image priorSource: 252956!----STARTUP----2015-08-28T15:30:44.029635+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-08-28T15:30:44.119378+02:00 Pharo-40620.image priorSource: 253150!----STARTUP----2015-09-01T15:36:15.989708+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 9/1/2015 15:33' prior: 33791721!commentForCurrentUpdate ^ '15935 Backport 4.0: Renaming a package just by changing upper/lowercase removes the package	https://pharo.fogbugz.com/f/cases/15935'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 9/1/2015 15:33'!script621	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.149.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 9/1/2015 15:33'!update40621	"self new update40621"	self withUpdateLog: '15935 Backport 4.0: Renaming a package just by changing upper/lowercase removes the package	https://pharo.fogbugz.com/f/cases/15935'.	self loadTogether: self script621 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40620!ScriptLoader removeSelector: #script620!"ScriptLoader40"!!RPackageOrganizer methodsFor: 'accessing' stamp: 'NicolaiHess 7/8/2015 22:53' prior: 53738151!packageNamed: aSymbol  ifAbsent: errorBlock	^ packages 		at: aSymbol asSymbol 		ifAbsent: errorBlock		! !"RPackage-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.804.mcz') load.ScriptLoader new update40621.!----End fileIn----!----QUIT----2015-09-01T15:36:17.836289+02:00 Pharo.image priorSource: 253345!----STARTUP----2015-09-01T15:36:18.050775+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-09-01T15:36:22.50955+02:00 Pharo.image priorSource: 268952!----STARTUP----2015-09-01T15:46:55.85832+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-09-01T15:46:55.944457+02:00 Pharo-40621.image priorSource: 269147!----STARTUP----2015-09-21T13:48:16.999597+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 9/21/2015 13:46' prior: 33808073!commentForCurrentUpdate ^ '10235 StandardFileStream>>compressFile cant create new compressed file	https://pharo.fogbugz.com/f/cases/10235'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 9/21/2015 13:46'!script622	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.151.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.912.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.643.mczOpalCompiler-Tests-TheIntegrator.282.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 9/21/2015 13:46'!update40622	"self new update40622"	self withUpdateLog: '10235 StandardFileStream>>compressFile cant create new compressed file	https://pharo.fogbugz.com/f/cases/10235'.	self loadTogether: self script622 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40621!ScriptLoader removeSelector: #script621!"ScriptLoader40"!!StandardFileStream methodsFor: '*compression' stamp: 'CarloTeixeira 9/12/2015 23:47' prior: 57331934!compressFile	"Write a new file that has the data in me compressed in GZip format."	| zipStream rawWriteStream |	self		readOnly;		binary.	rawWriteStream := (self name asFileReference, 'gz') writeStream		binary;		setFileTypeToObject.	zipStream := GZipWriteStream on: rawWriteStream.	[ 	| buffer |	buffer := ByteArray new: 50000.	[ self atEnd ] whileFalse: [ zipStream nextPutAll: (self nextInto: buffer) ] ]		ensure: [ 			zipStream close.			self close ].	^ zipStream! !"Compression"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.805.mcz') load.ScriptLoader new update40622.!----End fileIn----!----QUIT----2015-09-21T13:48:19.000693+02:00 Pharo.image priorSource: 269340!----STARTUP----2015-09-21T13:48:19.175441+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-09-21T13:48:23.252075+02:00 Pharo.image priorSource: 285288!----STARTUP----2015-09-21T14:00:30.612233+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-09-21T14:00:30.694533+02:00 Pharo-40622.image priorSource: 285483!----STARTUP----2015-10-18T00:20:52.37862+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 10/18/2015 00:17' prior: 33824069!commentForCurrentUpdate ^ '16736 Fix Nautilus #openOnClass: for Pharo4	https://pharo.fogbugz.com/f/cases/1673616777 Querying block with many temps fails	https://pharo.fogbugz.com/f/cases/16777'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 10/18/2015 00:17'!script623	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.151.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.914.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.645.mczOpalCompiler-Tests-TheIntegrator.285.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-MarcusDenker.29.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 10/18/2015 00:17'!update40623	"self new update40623"	self withUpdateLog: '16736 Fix Nautilus #openOnClass: for Pharo4	https://pharo.fogbugz.com/f/cases/1673616777 Querying block with many temps fails	https://pharo.fogbugz.com/f/cases/16777'.	self loadTogether: self script623 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40622!ScriptLoader removeSelector: #script622!"ScriptLoader40"!!OCClosureTests methodsFor: 'testing' stamp: 'HenrikSperreJohansen 10/13/2015 11:27'!testBlockTemps		| block block1 block2 |	"Regression test: Bytecode offset of IR was to last byte of IR node, which for blocks include temp initialization bytes. This caused scan for block creation bytecode to fail when there were many block temps, and no source node to be found."	block := [ :arg | | a b c d e f g | a:=b:=c:=d:=e:=f:=g := arg. [ a ] ].	self assert: block sourceNode isBlock.	self assert: block argumentNames equals: (OrderedCollection with:#arg).	block1 := block value: 1.	block2 := block value: 2.	self assert: block1 value = 1.	self assert: block2 value = 2! !!IRPushClosureCopy methodsFor: 'testing' stamp: 'HenrikSperreJohansen 10/13/2015 15:11'!isGoto	^ 	false! !!IRPushClosureCopy methodsFor: 'testing' stamp: 'HenrikSperreJohansen 10/13/2015 15:11'!isJump	^ 	false! !!IRBuilder methodsFor: 'private' stamp: 'HenrikSperreJohansen 10/13/2015 15:09' prior: 26498935!startNewSequence	"End current instruction sequence and start a new sequence to add instructions to.  If ending block just falls through to new block then add an explicit jump to it so they stay linked"	| newSequence | 	currentSequence ifEmpty: [^ self].	"block is still empty, continue using it"	newSequence := IRSequence orderNumber: currentSequence orderNumber + 1.	newSequence method: ir.	currentSequence last transitionsToNextSequence		ifFalse: [ self add: (IRJump new destination: newSequence)].	self currentScope isPushClosureCopy ifTrue: [self currentScope lastBlockSequence: currentSequence].	currentSequence := newSequence.! !!IRInstruction methodsFor: 'testing' stamp: 'HenrikSperreJohansen 10/13/2015 15:08'!transitionsToNextSequence	"Does the current instruction intrinsically know how to transition to the next sequence?"	^ self isJump or: [self isReturn or: [self isPushClosureCopy ]]! !!IRMethod methodsFor: 'debugging' stamp: 'HenrikSperreJohansen 10/12/2015 16:33' prior: 26591128!instructionForPC: aPC"generates the compiledMethod and optimize the ir. 	Removes the side-effect of optimizing the IR while looking for instruction, 	which results in incorrect found instruction"	self compiledMethod.	"For a given PC, the actual instruction may start N bytes ahead, specifically startPC of blocks is *after* the bytecode that creates the block. N = 3 must be revisited when bytecode sets are extended"	0 to: 3 do: [ :off |		(self firstInstructionMatching: [:ir | ir bytecodeOffset = (aPC - off) ]) ifNotNil: [:it |^it]]	! !!MustBeBooleanTests methodsFor: 'tests' stamp: 'HenrikSperreJohansen 10/13/2015 15:40'!testIfTrueWithClosureAfterJump	"A closure is a multibyte instruction, that should not be	1) confused for an ending jump in ifTrue/ifFalse structure	2) set as jumptarget, or have PC manually set to, none but its first byte."	| myBooleanObject |	myBooleanObject := MyBooleanObject new.	myBooleanObject		ifTrue: [ 4 + 3 ].	[ :string | 	self assert: 'a ' , string equals: 'a 5' ] value: '5'! !!IRBytecodeGenerator methodsFor: 'mapping' stamp: 'HenrikSperreJohansen 10/12/2015 16:33' prior: 26557903!mapBytesTo: instr	"Record the current byte offset in instruction sequence as start of instr. 	This is later used to calculate the total byte offset of instruction in generated code,	see #bytecodes"	instrMap add: instr -> (bytes size + 1)! !!NautilusUI methodsFor: 'package filter' stamp: 'MarcusDeneker 10/18/2015 00:10'!useLastPackagePatternStringForClass: aClass    ^ self ! !!IRJumpIf methodsFor: 'acessing' stamp: 'HenrikSperreJohansen 10/13/2015 15:37' prior: 26583734!nextBytecodeOffsetAfterJump	"check if we are in ifTrue:ifFalse: / ifFalse:ifTrue: or in ifTrue: / ifFalse: and answers the next byte code offset"	^destination last isJump 		ifTrue: [ destination last destination first bytecodeOffset ]		ifFalse: [ 			(destination sequence at: ((destination size - 1) max: 1)) bytecodeOffset ]! !!IRTranslatorV2 methodsFor: 'visiting' stamp: 'HenrikSperreJohansen 10/12/2015 16:33' prior: 26658704!visitInstruction: instr	gen mapBytesTo: instr.	self visitNode: instr.! !!IRTranslatorV2 methodsFor: 'visiting' stamp: 'HenrikSperreJohansen 10/12/2015 16:33' prior: 26655377!visitPushClosureCopy: closure	closure copiedValues do: [:name | 			gen pushTemp: (self currentScope indexForVarNamed: name).	].	gen mapBytesTo: closure.	gen pushClosureCopyNumCopiedValues: closure copiedValues size 			numArgs: closure arguments size 			to: closure destination orderNumber.	self pushScope: closure.	gen pushNClosureTemps: closure definedTemps size! !IRInstruction removeSelector: #isJumpOrReturn!"Nautilus"!"OpalCompiler-Core"!"OpalCompiler-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.806.mcz') load.ScriptLoader new update40623.!----End fileIn----!----QUIT----2015-10-18T00:20:57.091294+02:00 Pharo.image priorSource: 285678!----STARTUP----2015-10-18T00:20:57.287183+02:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-10-18T00:21:02.531129+02:00 Pharo.image priorSource: 305874!----STARTUP----2015-10-18T00:31:30.417885+02:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-10-18T00:31:30.58539+02:00 Pharo-40623.image priorSource: 306069!----STARTUP----2015-10-26T12:45:27.296246+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 10/26/2015 12:43' prior: 33840407!commentForCurrentUpdate ^ '16813 Unclosed file streams	https://pharo.fogbugz.com/f/cases/16813'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 10/26/2015 12:43'!script624	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.151.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.914.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.645.mczOpalCompiler-Tests-TheIntegrator.285.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-TheIntegrator.31.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 10/26/2015 12:43'!update40624	"self new update40624"	self withUpdateLog: '16813 Unclosed file streams	https://pharo.fogbugz.com/f/cases/16813'.	self loadTogether: self script624 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40623!ScriptLoader removeSelector: #script623!"ScriptLoader40"!!RGMethodDefinition methodsFor: '*Ring-Monticello' stamp: 'HenrikSperreJohansen 10/19/2015 14:26' prior: 53462522!basicAsMCMethodDefinition   "Creates a MCMethodDefinition from the receiver"   self isActive ifTrue: [ 		self compiledMethod sourceFileStream ifNotNil: [ :file|			[^ self asMCMethodDefinitionFromFile: file] ensure: [file close]]].	   ^ MCMethodDefinition		className: self theNonMetaParentName 	   	classIsMeta: self isMetaSide		selector: self selector		category: self protocol		timeStamp: self stamp		source: self sourceCode ! !"Ring-Monticello"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.807.mcz') load.ScriptLoader new update40624.!----End fileIn----!----QUIT----2015-10-26T12:45:29.012453+01:00 Pharo.image priorSource: 306264!----STARTUP----2015-10-26T12:45:29.208516+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-10-26T12:45:33.670786+01:00 Pharo.image priorSource: 322100!----STARTUP----2015-10-26T12:59:16.201816+01:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-10-26T12:59:16.283083+01:00 Pharo-40624.image priorSource: 322295!----STARTUP----2015-11-11T20:43:20.423212+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 11/11/2015 16:39' prior: 33860993!commentForCurrentUpdate ^ '16908 wrong source node for pc in mustBeBooleanInMagic	https://pharo.fogbugz.com/f/cases/16908'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 11/11/2015 16:40'!script625	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.151.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.441.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.99.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.914.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.647.mczOpalCompiler-Tests-TheIntegrator.287.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-TheIntegrator.31.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 11/11/2015 16:40'!update40625	"self new update40625"	self withUpdateLog: '16908 wrong source node for pc in mustBeBooleanInMagic	https://pharo.fogbugz.com/f/cases/16908'.	self loadTogether: self script625 merge: false.	self flushCaches.! !ScriptLoader removeSelector: #update40624!ScriptLoader removeSelector: #script624!"ScriptLoader40"!!MustBeBooleanTests methodsFor: 'tests' stamp: 'HenrikSperreJohansen 11/6/2015 11:10'!testDNU	| code |	code := [ (true ifFalse:[]) ifTrue:[] ].	self should: code raise: MessageNotUnderstood .	code on: MessageNotUnderstood do: [ :error | self assert: error receiver isNil. 			self assert: error message selector equals: #ifTrue:]! !!IRBytecodeGenerator methodsFor: 'results' stamp: 'HenrikSperreJohansen 11/6/2015 10:56' prior: 26546286!bytecodes	| stream |	self updateJumpOffsets.	stream := (ByteArray new: 100) writeStream.  	orderSeq do: [ :seqId | |lastInstr|			"If the instruction will emit bytes, record the first byte emitted as the instructions bytecode index"			lastInstr := IRInstruction new -> 1.			(instrMaps at: seqId) do: [ :assoc | |nextInstr|				nextInstr := assoc.				lastInstr key bytecodeIndex: ((nextInstr value - lastInstr value) > 0 ifTrue: [ 					stream position + lastInstr value]).				lastInstr := assoc.				  ].			lastInstr key bytecodeIndex: ((seqBytes at: seqId) size < lastInstr value ifFalse: [  stream position + lastInstr value]).			stream nextPutAll: (seqBytes at: seqId) ].	^ stream contents! !!Object methodsFor: '*OpalCompiler-Core' stamp: 'HenrikSperreJohansen 11/6/2015 11:18' prior: 33518946!mustBeBooleanInMagic: context	"Permits to redefine methods inlined by compiler.	Take the ast node corresponding to the mustBeBoolean error, compile it on the with Opal fly and executes it as a DoIt. Then resume the execution of the context."	| sendNode methodNode method |	"get the message send node that triggered mustBeBoolean"	sendNode := context sourceNode sourceNodeForPC: context pc - 1.	"Build node to perform send unoptimized"	methodNode := RBMethodNode 		selector: #ExecuteUnOptimizedIn: 		arguments: { RBVariableNode named:'ThisContext' } 		body: sendNode copy asSequenceNode.	"Rewrite temps to access the values in context"	methodNode rewriteTempsForContext: context.	"Rewrite non-local returns to return to the correct context from send"	RBParseTreeRewriter new 		replace: '^ ``@value' with: 'ThisContext home return: ``@value';		executeTree: methodNode.	"Add a return to the method body"	methodNode body transformLastToReturn.		"Keep same compilation context as the sender node's"	methodNode compilationContext: sendNode methodNode compilationContext copy.	"Disable inlining so the message send will be unoptimized"	methodNode compilationContext compilerOptions: #(- optionInlineIf optionInlineAndOr optionInlineWhile).	"Generate the method"		method := methodNode generate.	"resume the context at the instruction following the send when returning from deoptimized code"	context pc: sendNode irInstruction nextBytecodeOffsetAfterJump.	"Execute the generated method"	^ context receiver withArgs: {context} executeMethod: method! !"OpalCompiler-Core"!"OpalCompiler-Tests"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.808.mcz') load.ScriptLoader new update40625.!----End fileIn----!----QUIT----2015-11-11T20:43:23.195059+01:00 Pharo.image priorSource: 322490!----STARTUP----2015-11-11T20:43:23.372928+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-11-11T20:43:27.49757+01:00 Pharo.image priorSource: 340677!----STARTUP----2015-11-11T20:54:29.975887+01:00 as /builds/workspace/Pharo-4.0-Update-Step-5-Publish/Pharo.image!----SNAPSHOT----2015-11-11T20:54:30.056243+01:00 Pharo-40625.image priorSource: 340872!----STARTUP----2015-12-07T11:28:36.922327+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!!ScriptLoader methodsFor: 'public' stamp: 'TheIntegrator 12/7/2015 11:25' prior: 33877220!commentForCurrentUpdate ^ '17057 BackPort Pharo4: 13854 frameSize calculated wrongly for #lineSegmentsDo:	https://pharo.fogbugz.com/f/cases/1705717047 Backport pharo4: 17040 Morph HalosEnabled variable is not use.	https://pharo.fogbugz.com/f/cases/17047'! !!ScriptLoader methodsFor: 'pharo - scripts' stamp: 'TheIntegrator 12/7/2015 11:25'!script626	^ 'AST-Core-TheIntegrator.286.mczAST-Tests-Core-TheIntegrator.65.mczAnnouncements-Core-MarcusDenker.55.mczAnnouncements-Help-TheIntegrator.12.mczAnnouncements-Tests-Core-TheIntegrator.25.mczAsmJit-Core-MarcusDenker.8.mczAsmJit-Extension-MarcusDenker.8.mczAsmJit-Instructions-TheIntegrator.13.mczAsmJit-Operands-StephaneDucasse.14.mczAsmJit-StackManagement-SvenVanCaekenberghe.11.mczAsmJit-Tests-TheIntegrator.21.mczAsmJit-x86-TheIntegrator.40.mczAthens-Balloon-MarcusDenker.20.mczAthens-Cairo-MarcusDenker.85.mczAthens-CairoPools-NicolaiHess.14.mczAthens-Core-MarcusDenker.50.mczAthens-Examples-TudorGirba.43.mczAthens-Morphic-NicolaiHess.44.mczAthens-Text-NicolaiHess.16.mczBalloon-StephaneDucasse.118.mczBalloonTests-MarcusDenker.3.mczChroma-CubeHelix-TheIntegrator.2.mczCodeImport-TheIntegrator.48.mczCollections-Abstract-StephaneDucasse.276.mczCollections-Arithmetic-TheIntegrator.15.mczCollections-Atomic-MarcusDenker.10.mczCollections-Native-TheIntegrator.9.mczCollections-Sequenceable-TheIntegrator.192.mczCollections-Stack-MarcusDenker.7.mczCollections-Streams-TheIntegrator.168.mczCollections-Strings-TheIntegrator.350.mczCollections-Support-MarcusDenker.57.mczCollections-Unordered-TheIntegrator.207.mczCollections-Weak-TheIntegrator.88.mczCollectionsTests-TheIntegrator.685.mczCompiler-TheIntegrator.582.mczCompression-TheIntegrator.151.mczCompressionTests-TheIntegrator.29.mczConfigurationCommandLineHandler-Core-TheIntegrator.27.mczConfigurationCommandLineHandler-Tests-MarcusDenker.11.mczDebugger-Tests-TheIntegrator.2.mczDebuggerActions-MarcusDenker.74.mczDebuggerFilters-TheIntegrator.9.mczDebuggerModel-TheIntegrator.106.mczDeprecated40-TheIntegrator.48.mczEmbeddedFreeType-TheIntegrator.15.mczEmbeddedFreeType-Tests-TheIntegrator.4.mczEmergencyEvaluator-MarcusDenker.32.mczFileSystem-Core-TheIntegrator.175.mczFileSystem-Disk-TheIntegrator.79.mczFileSystem-Memory-TheIntegrator.57.mczFileSystem-Tests-Core-TheIntegrator.92.mczFileSystem-Tests-Disk-TheIntegrator.22.mczFileSystem-Tests-Memory-TheIntegrator.8.mczFileSystem-Zip-TheIntegrator.17.mczFiles-TheIntegrator.373.mczFontChooser-TheIntegrator.7.mczFontInfrastructure-TheIntegrator.8.mczFontInfrastructure-Tests-TheIntegrator.2.mczFreeType-TheIntegrator.695.mczFreeTypeTests-SvenVanCaekenberghe.5.mczFuel-TheIntegrator.804.mczFuelCommandLineHandler-TheIntegrator.27.mczFuelSystem-FileRegistry-EstebanLorenzano.3.mczFuelTests-TheIntegrator.384.mczFuelTools-Debugger-StephaneDucasse.12.mczGT-Inspector-TudorGirba.305.mczGT-InspectorExtensions-Core-TudorGirba.144.mczGT-Playground-TudorGirba.110.mczGT-Spotter-StefanReichhart.307.mczGT-Spotter-EventRecorder-JurajKubelka.89.mczGT-SpotterExtensions-Core-TudorGirba.141.mczGT-Tests-Inspector-StefanReichhart.33.mczGT-Tests-Playground-StefanReichhart.4.mczGT-Tests-Spotter-TudorGirba.8.mczGenerated-code-non-existing-package-EstebanLorenzano.2.mczGlamour-Announcements-AndreiChis.8.mczGlamour-Browsers-TorstenBergmann.109.mczGlamour-Core-StefanReichhart.299.mczGlamour-Examples-TorstenBergmann.291.mczGlamour-Helpers-AndreiChis.39.mczGlamour-Morphic-Brick-StefanReichhart.398.mczGlamour-Morphic-Brick-Tests-AliakseiSyrel.13.mczGlamour-Morphic-Pager-AndreiChis.103.mczGlamour-Morphic-Renderer-AndreiChis.320.mczGlamour-Morphic-Theme-StefanReichhart.212.mczGlamour-Morphic-Widgets-AndreiChis.177.mczGlamour-Presentations-AndreiChis.176.mczGlamour-Rubric-Presentations-AndreiChis.41.mczGlamour-Tests-Core-AliakseiSyrel.104.mczGlamour-Tests-Morphic-AndreiChis.124.mczGlamour-Tests-Resources-AndreiChis.3.mczGlamour-Tests-Rubric-AndreiChis.14.mczGofer-Core-TheIntegrator.228.mczGofer-Tests-TheIntegrator.164.mczGraphics-Canvas-TheIntegrator.2.mczGraphics-Display Objects-TheIntegrator.159.mczGraphics-Files-TheIntegrator.60.mczGraphics-Fonts-EstebanLorenzano.96.mczGraphics-Fonts-Tests-EstebanLorenzano.3.mczGraphics-Primitives-StephaneDucasse.157.mczGraphics-Resources-EstebanLorenzano.22.mczGraphics-Shapes-TheIntegrator.2.mczGraphics-Tests-TheIntegrator.72.mczGraphics-Transformations-TheIntegrator.12.mczGroupManager-TheIntegrator.72.mczGroupManagerUI-TheIntegrator.40.mczGrowl-TheIntegrator.37.mczHelpSystem-Core-TheIntegrator.122.mczHelpSystem-Tests-TheIntegrator.30.mczHudsonBuildTools20-TheIntegrator.65.mczJobs-EstebanLorenzano.4.mczKernel-TheIntegrator.2016.mczKernelTests-TheIntegrator.769.mczKeymapping-Core-EstebanLorenzano.195.mczKeymapping-KeyCombinations-EstebanLorenzano.45.mczKeymapping-Pragmas-TheIntegrator.50.mczKeymapping-Settings-StephaneDucasse.83.mczKeymapping-Tests-TheIntegrator.94.mczKeymapping-Tools-Spec-TheIntegrator.30.mczKomitter-TheIntegrator.117.mczManifest-Core-TheIntegrator.217.mczManifest-CriticBrowser-TheIntegrator.177.mczManifest-Resources-Tests-MarcusDenker.14.mczManifest-Tests-TheIntegrator.49.mczMenuRegistration-TheIntegrator.74.mczMessageBrowserRefactoringAddition-StephaneDucasse.2.mczMetacello-Base-EstebanLorenzano.114.mczMetacello-Core-MarcusDenker.722.mczMetacello-FileTree-EstebanLorenzano.30.mczMetacello-GitHub-StephaneDucasse.33.mczMetacello-MC-TheIntegrator.699.mczMetacello-PharoCommonPlatform-StephaneDucasse.12.mczMetacello-Platform.pharo20-EstebanLorenzano.36.mczMetacello-Platform.pharo30-StephaneDucasse.6.mczMetacello-ProfStef-MarcusDenker.16.mczMetacello-Reference-EstebanLorenzano.37.mczMetacello-TestsCore-EstebanLorenzano.36.mczMetacello-TestsMC-EstebanLorenzano.388.mczMetacello-TestsMCCore-EstebanLorenzano.6.mczMetacello-TestsMCResources-TheIntegrator.15.mczMetacello-TestsCommonMC.pharo20-EstebanLorenzano.4.mczMetacello-TestsPlatform.squeakCommon-MarcusDenker.19.mczMetacello-ToolBox-MarcusDenker.141.mczMetacello-Tutorial-EstebanLorenzano.27.mczMonticello-TheIntegrator.1011.mczMonticello-Tests-TheIntegrator.6.mczMonticelloConfigurations-MarcusDenker.70.mczMonticelloFileTree-Core-TheIntegrator.182.mczMonticelloFileTree-FileSystem-Utilities-MarcusDenker.32.mczMonticelloGUI-TheIntegrator.343.mczMonticelloMocks-EstebanLorenzano.2.mczMorphic-Base-TheIntegrator.443.mczMorphic-Core-TheIntegrator.170.mczMorphic-Examples-TheIntegrator.40.mczMorphic-Widgets-Basic-TheIntegrator.41.mczMorphic-Widgets-ColorPicker-StephaneDucasse.17.mczMorphic-Widgets-Extra-TheIntegrator.22.mczMorphic-Widgets-List-TheIntegrator.15.mczMorphic-Widgets-NewList-TheIntegrator.5.mczMorphic-Widgets-Pluggable-TheIntegrator.44.mczMorphic-Widgets-Scrolling-TheIntegrator.23.mczMorphic-Widgets-Tabs-TheIntegrator.12.mczMorphic-Widgets-Taskbar-StephaneDucasse.7.mczMorphic-Widgets-Tree-TheIntegrator.27.mczMorphic-Widgets-Windows-TheIntegrator.47.mczMorphicTests-TheIntegrator.101.mczMultilingual-Encodings-MarcusDenker.47.mczMultilingual-Languages-StephaneDucasse.40.mczMultilingual-OtherLanguages-MarcusDenker.12.mczMultilingual-Tests-MarcusDenker.35.mczMultilingual-TextConversion-TheIntegrator.70.mczMultilingual-TextConverterOtherLanguages-MarcusDenker.2.mczNECompletion-TheIntegrator.194.mczNECompletion-Tests-TheIntegrator.2.mczNativeBoost-Core-TheIntegrator.164.mczNativeBoost-Examples-CamilloBruni.16.mczNativeBoost-Mac-MarcusDenker.12.mczNativeBoost-Pools-CamilloBruni.13.mczNativeBoost-Tests-TheIntegrator.92.mczNativeBoost-Unix-MarcusDenker.17.mczNativeBoost-Win32-TheIntegrator.57.mczNautilus-TheIntegrator.914.mczNautilus-Tests-TheIntegrator.14.mczNautilusCommon-TheIntegrator.260.mczNautilusRefactoring-TheIntegrator.216.mczNetwork-Kernel-StephaneDucasse.112.mczNetwork-MIME-MarcusDenker.69.mczNetwork-Mail-StephaneDucasse.39.mczNetwork-Protocols-MarcusDenker.101.mczNetwork-UUID-MarcusDenker.29.mczNetwork-Url-MarcusDenker.99.mczNetworkTests-TheIntegrator.103.mczNewValueHolder-TheIntegrator.27.mczNodeNavigation-StephaneDucasse.51.mczNonInteractiveTranscript-TheIntegrator.15.mczOSWindow-Core-TheIntegrator.20.mczOSWindow-SDL2-EstebanLorenzano.19.mczOSWindow-VM-IgorStasenko.2.mczOpalCompiler-Core-TheIntegrator.649.mczOpalCompiler-Tests-TheIntegrator.287.mczOpalDecompiler-TheIntegrator.31.mczOpalTools-TheIntegrator.16.mczPharo-Help-TheIntegrator.15.mczPolymorph-TaskbarIcons-MarcusDenker.40.mczPolymorph-Widgets-TheIntegrator.1211.mczPragmaCollector-TheIntegrator.3.mczProfStef-Core-TheIntegrator.60.mczProfStef-Help-SvenVanCaekenberghe.14.mczProfStef-Tests-TheIntegrator.25.mczRPackage-Core-TheIntegrator.386.mczRPackage-SystemIntegration-TheIntegrator.232.mczRPackage-Tests-TheIntegrator.167.mczRecentSubmissions-StephaneDucasse.233.mczRefactoring-Changes-TheIntegrator.65.mczRefactoring-Core-TheIntegrator.272.mczRefactoring-Critics-TheIntegrator.165.mczRefactoring-Environment-TheIntegrator.49.mczRefactoring-Tests-Changes-MarcusDenker.38.mczRefactoring-Tests-Core-TheIntegrator.123.mczRefactoring-Tests-Critics-MarcusDenker.25.mczRefactoring-Tests-Environment-StephaneDucasse.11.mczReflectivity-StephaneDucasse.25.mczReflectivity-Tests-TheIntegrator.16.mczRegex-Core-MarcusDenker.33.mczRegex-Help-MarcusDenker.5.mczRegex-Tests-Core-MarcusDenker.9.mczReleaseTests-TheIntegrator.15.mczRing-Core-Containers-TheIntegrator.41.mczRing-Core-Kernel-TheIntegrator.207.mczRing-Monticello-TheIntegrator.31.mczRing-Tests-Containers-MarcusDenker.18.mczRing-Tests-Kernel-TheIntegrator.83.mczRing-Tests-Monticello-MarcusDenker.19.mczRubric-TheIntegrator.189.mczSUnit-Core-TheIntegrator.138.mczSUnit-Help-MarcusDenker.9.mczSUnit-Tests-TheIntegrator.48.mczSUnit-UI-TheIntegrator.113.mczSUnit-UITesting-TheIntegrator.21.mczScriptLoader-Tests-TheIntegrator.4.mczSettings-Graphics-StephaneDucasse.28.mczSettings-Polymorph-TheIntegrator.78.mczSettings-System-EstebanLorenzano.38.mczShoreLine-Report-Core-TommasoDalSasso.9.mczShoreLine-Report-Settings-TommasoDalSasso.2.mczShoreLine-Report-UI-TommasoDalSasso.12.mczShout-TheIntegrator.241.mczShoutTests-TheIntegrator.27.mczSlot-TheIntegrator.604.mczSlot-Tests-TheIntegrator.39.mczSmartSuggestions-TheIntegrator.147.mczSmartSuggestions-Tests-TheIntegrator.2.mczSpec-Core-StephaneDucasse.386.mczSpec-Debugger-TheIntegrator.236.mczSpec-Examples-TheIntegrator.91.mczSpec-Help-TheIntegrator.11.mczSpec-Inspector-TheIntegrator.238.mczSpec-Layout-TheIntegrator.67.mczSpec-MorphicAdapters-TheIntegrator.207.mczSpec-PolyWidgets-TheIntegrator.57.mczSpec-Tests-StephaneDucasse.45.mczSpec-Tools-StephaneDucasse.261.mczStartupPreferences-TheIntegrator.131.mczSystem-Announcements-TheIntegrator.98.mczSystem-Caching-TheIntegrator.23.mczSystem-CachingTests-TheIntegrator.12.mczSystem-Changes-StephaneDucasse.257.mczSystem-Clipboard-SvenVanCaekenberghe.32.mczSystem-CommandLine-TheIntegrator.167.mczSystem-CommandLineHandler-TheIntegrator.3.mczSystem-FilePackage-TheIntegrator.132.mczSystem-FileRegistry-StephaneDucasse.33.mczSystem-Finalization-TheIntegrator.19.mczSystem-Hashing-StephaneDucasse.45.mczSystem-History-EstebanLorenzano.7.mczSystem-History-Tests-EstebanLorenzano.3.mczSystem-Installers-SvenVanCaekenberghe.42.mczSystem-Localization-TheIntegrator.88.mczSystem-Localization-Tests-TheIntegrator.5.mczSystem-Object Events-MarcusDenker.15.mczSystem-Platforms-StephaneDucasse.61.mczSystem-Serial Port-StephaneDucasse.23.mczSystem-Settings-StephaneDucasse.309.mczSystem-Sound-StephaneDucasse.18.mczSystem-Support-EstebanLorenzano.1094.mczSystem-VMEvents-TheIntegrator.2.mczTests-TheIntegrator.724.mczText-Core-StephaneDucasse.31.mczText-Diff-StephaneDucasse.4.mczText-Edition-StephaneDucasse.77.mczText-Edition-Tests-EstebanLorenzano.3.mczText-Scanning-TheIntegrator.24.mczText-Tests-EstebanLorenzano.7.mczTool-Base-TheIntegrator.68.mczTool-Browser-Old-TheIntegrator.37.mczTool-Changes-TheIntegrator.22.mczTool-ConfigurationBrowser-TheIntegrator.15.mczTool-Diff-TheIntegrator.2.mczTool-FileList-TheIntegrator.34.mczTool-FileList-Tests-EstebanLorenzano.3.mczTool-FilePackageBrowser-TheIntegrator.7.mczTool-Finder-TheIntegrator.30.mczTool-ImageCleaner-TheIntegrator.10.mczTool-ProcessBrowser-StephaneDucasse.6.mczTool-Profilers-TheIntegrator.17.mczTool-SystemReporter-StephaneDucasse.10.mczTool-Transcript-TheIntegrator.12.mczTool-TxWorkspace-TheIntegrator.6.mczTool-Workspace-TheIntegrator.24.mczTools-TheIntegrator.1503.mczToolsTest-MarcusDenker.denker.71.mczTraits-TheIntegrator.757.mczTranscript-StephaneDucasse.32.mczTxText-Athens-TheIntegrator.44.mczTxText-AthensTests-IgorStasenko.9.mczTxText-Model-NicolaiHess.50.mczTxText-Styler-IgorStasenko.3.mczTxTextTests-Model-IgorStasenko.26.mczUIManager-TheIntegrator.141.mczUnicode-Initialization-MarcusDenker.10.mczUpdateStreamer-Core-TheIntegrator.34.mczUpdateStreamer-Tests-TheIntegrator.9.mczUserManager-Core-MarcusDenker.13.mczUserManager-Tests-TheIntegrator.5.mczVersionner-Core-Announcements-MarcusDenker.11.mczVersionner-Core-Commands-ChristopheDemarey.53.mczVersionner-Core-DependenciesModel-TheIntegrator.95.mczVersionner-Core-Model-ChristopheDemarey.49.mczVersionner-Spec-Browser-ChristopheDemarey.173.mczVersionner-Tests-Core-Commands-TheIntegrator.17.mczVersionner-Tests-Core-DependenciesModel-MarcusDenker.40.mczVersionner-Tests-Core-Model-ChristopheDemarey.33.mczVersionner-Tests-Resources-MarcusDenker.14.mczZinc-Character-Encoding-Core-SvenVanCaekenberghe.37.mczZinc-Character-Encoding-Tests-SvenVanCaekenberghe.22.mczZinc-FileSystem-SvenVanCaekenberghe.10.mczZinc-HTTP-SvenVanCaekenberghe.423.mczZinc-Resource-Meta-Core-SvenVanCaekenberghe.48.mczZinc-Resource-Meta-FileSystem-TheIntegrator.8.mczZinc-Resource-Meta-Tests-SvenVanCaekenberghe.33.mczZinc-Tests-SvenVanCaekenberghe.223.mczZinc-Zodiac-SvenVanCaekenberghe.34.mczZodiac-Core-SvenVanCaekenberghe.38.mczZodiac-Extra-StephaneDucasse.10.mczZodiac-Tests-SvenVanCaekenberghe.12.mcz'findTokens: String lf , String cr! !!ScriptLoader methodsFor: 'pharo - updates' stamp: 'TheIntegrator 12/7/2015 11:25'!update40626	"self new update40626"	SmalltalkImage compilerClass: Compiler.	self withUpdateLog: '17057 BackPort Pharo4: 13854 frameSize calculated wrongly for #lineSegmentsDo:	https://pharo.fogbugz.com/f/cases/1705717047 Backport pharo4: 17040 Morph HalosEnabled variable is not use.	https://pharo.fogbugz.com/f/cases/17047'.	self loadTogether: self script626 merge: false.	SmalltalkImage compilerClass: OpalCompiler.	self flushCaches.! !ScriptLoader removeSelector: #update40625!ScriptLoader removeSelector: #script625!"ScriptLoader40"!!IRClosureStackCount commentStamp: 'NicolaiHess 11/17/2015 23:57' prior: 0!IRClosureStackCount is used to distinguish between a stack in the method scope and a stack within a closure block. Theclosure stack size is independent of the number of tempvars from the compiled method, therefore that number is subtractedfrom this stack size length.!!IRClosureStackCount commentStamp: 'NicolaiHess 11/17/2015 23:57' prior: 33910657!IRClosureStackCount is used to distinguish between a stack in the method scope and a stack within a closure block. Theclosure stack size is independent of the number of tempvars from the compiled method, therefore that number is subtractedfrom this stack size length.!!IRClosureStackCount class methodsFor: 'instance creation' stamp: 'NicolaiHess 11/17/2015 23:58'!newOn: stack	^ (self startAt: stack position)		numMethodTempVars: stack numMethodTempVars;		yourself! !!IRClosureStackCount methodsFor: 'initialization' stamp: 'NicolaiHess 11/17/2015 23:59'!initialize	super initialize.	numMethodTempVars := 0.! !!IRClosureStackCount methodsFor: 'accessing' stamp: 'NicolaiHess 11/17/2015 23:59'!length	^ super length - self numMethodTempVars! !!IRClosureStackCount methodsFor: 'accessing' stamp: 'NicolaiHess 11/17/2015 23:59'!numMethodTempVars	^ numMethodTempVars! !!IRClosureStackCount methodsFor: 'accessing' stamp: 'NicolaiHess 11/17/2015 23:59'!numMethodTempVars: nilOrNumber	numMethodTempVars := nilOrNumber ifNil:[0]! !!IRStackCount class methodsFor: 'instance creation' stamp: 'NicolaiHess 11/18/2015 00:00'!newOn: stack	^ self startAt: stack position! !!IRStackCount methodsFor: 'results' stamp: 'NicolaiHess 11/18/2015 00:00' prior: 26641625!linkTo: stackOrNil	stackOrNil ifNil: [^  self class newOn: self].	^ self position = stackOrNil start		ifTrue: [stackOrNil]		ifFalse: [self error: 'stack out of sync in bytecode generator']! !!Morph methodsFor: '*Morphic-Base' stamp: 'CyrilFerlicot 11/24/2015 14:00' prior: 30963823!addHalo: evt	| halo |		(UserManager default canShowMorphHalo and: [ self halosEnabled ])		ifFalse: [ ^ self ].			halo := (Smalltalk globals at: self haloClass ifAbsent: [ HaloMorph ]) new.	halo bounds: (halo worldBoundsForMorph: self).	halo popUpFor: self event: evt.	^ halo! !!MorphTest methodsFor: 'test' stamp: 'CyrilFerlicot 11/24/2015 13:59'!testHaloIsDisable	| isHaloEnable |	isHaloEnable := Morph halosEnabled.	Morph halosEnabled: false.	self assert: (Morph new addHalo: nil) ~= (Smalltalk globals at: #HaloMorph).	Morph halosEnabled: isHaloEnable! !!IRBytecodeGenerator methodsFor: 'instructions' stamp: 'NicolaiHess 11/18/2015 00:01' prior: 26549711!label: seqId	lastSpecialReturn := nil.	currentSeqId := seqId.	currentSeqNum := currentSeqNum + 1.	seqOrder at: seqId put: currentSeqNum.	orderSeq at: currentSeqNum ifAbsentPut: [seqId].	bytes := seqBytes at: seqId ifAbsentPut: [OrderedCollection new].	jumps at: seqId ifAbsentPut: [nil].	instrMap := instrMaps at: seqId ifAbsentPut: [OrderedCollection new].	stack		ifNil: [ stack := stacks at: currentSeqId ifAbsentPut: [ IRStackCount new ] ]		ifNotNil: [stack := stacks at: currentSeqId ifAbsentPut: [ stack class newOn:stack ] ]	! !!IRBytecodeGenerator methodsFor: 'instructions' stamp: 'NicolaiHess 11/18/2015 00:02' prior: 26564410!pushClosureCopyNumCopiedValues: numCopied numArgs: numArgs2 to: toSeqId	| blockSeqId |	blockSeqId := self newDummySeqId.	stack pop: numCopied.	stacks at: blockSeqId put: ((IRClosureStackCount new numMethodTempVars:(numberOfTemps)) startAt: (numArgs2+numCopied)).	stack push.	stacks at: toSeqId put: (stack linkTo: (stacks at: toSeqId ifAbsentPut: [ nil ])).	self		saveLastJump:			(Message				selector: #closureFrom:to:copyNumCopiedValues:numArgs:				arguments:					{currentSeqId.					toSeqId.					numCopied.					numArgs2}).	self		closureFrom: currentSeqId		to: toSeqId		copyNumCopiedValues: numCopied		numArgs: numArgs2.	self label: blockSeqId! !!IRBytecodeGenerator methodsFor: 'instructions' stamp: 'NicolaiHess 11/18/2015 00:02' prior: 26554059!pushNClosureTemps: n	n = 0 ifTrue: [ ^ self ].	n timesRepeat:[ stack push].	encoder genPushNClosureTemps: n.! !"Morphic-Base"!"MorphicTests"!"OpalCompiler-Core"!"Postscript:Leave the line above, and replace the rest of this comment by a useful one.Executable statements should follow this comment, and shouldbe separated by periods, with no exclamation points (!!).Be sure to put any further comments in double-quotes, like this one."|repository|repository := MCHttpRepository                location: 'http://smalltalkhub.com/mc/Pharo/Pharo40/main'                user: ''                password: ''.(repository loadVersionFromFileNamed:'ScriptLoader40-TheIntegrator.809.mcz') load.ScriptLoader new update40626.!----End fileIn----!----QUIT----2015-12-07T11:28:40.621932+01:00 Pharo.image priorSource: 341066!----STARTUP----2015-12-07T11:28:40.78897+01:00 as /builds/workspace/Pharo-4.0-Update-Step-1-Tracker/Pharo.image!----QUIT----2015-12-07T11:28:44.770934+01:00 Pharo.image priorSource: 361007!!ClipboardMorph commentStamp: 'StephaneDucasse 8/20/2009 16:02' prior: 0!A morph that always displays the current contents of the text clipboard.	ClipboardMorph new openInWorld!!StarMorph commentStamp: '<historical>' prior: 0!I am a very flexible star.	StarMorph new openInHandAdd my handles using cmd-shift + click and you can move and resize me.The up and down arrows increase or reduce the number of my sides.The right and left arrows cycle thru different amounts of  pointiness.Use the arrows right and left of my center or get stars with a specific amount of pointyness.  The left side goes from fat to thin and then cycles around again. The right goes from thin to fat. Hold down the shift key if you wish to stop the cycling at the extremes.Use the arrows up and down to change the number of sides if you would like a different number of points.To add or remove just one side hold the shift key down as you use the arrows or use the menu items for that purpose.If you add or remove just one point I will have an odd number of sides.  When that happens I can only look like a regular polygon. The right and left arrows will have no effect.  Add or remove just one more side and you can shift drag the outer handle or use the arrows to restore my pointiness. That was too complicated. It is gone. You can get regular polygon shapes by adjusting my pointiness. For example the extreme of a five pointed star is a dodecahedron (10 sided regular polygon) and one step less extreme is a pentagon (5 sided regular polygon).At some time you will probably shift drag the outer handle thru the center handle.While I looked round as you shrunk me, I will look very much like an asterisk as you pull me away.  What happens is that inside bend shrunk on the way down because it can never be larger than the outer point (or it wouldn't be the innerbend would it).But on the way out it is perfectly happy to remain small. So I look like an asterisk.To fatten me up  (if you haven't already figured this out by fooling around)  hold the shift down an move the outer handle towards the center (but not quite all the way) then let the shift up and move the outer handle away.  A couple of cycles like this and I'll be looking fat and jolly again. Or you can now just use the right arrow to make me fatter.This is also the reason I don't let the inside bend get larger than the outer point.If I did the same process that fattened me when I was an asterisk would also grow an asterisk so large squeak would complain about not having enough memory.Historical note:The former star had two bugs that are fixed here.The outer handle now no longer jumps from one point to another.The other bug prevented some higher order stars from looking right. Which is why the former star didn't allow you to change the number of points. !!AnimatedImageMorph commentStamp: 'StephaneDucasse 8/20/2009 10:40' prior: 0!I am an ImageMorph that can hold more than one image. Each image has its own delay time.If you have an animated gif close to the image named 	(AnimatedImageMorph fromGIFFileNamed: 'animated.gif') openInWorld !!ImageMorphWithSpotlight commentStamp: 'StephaneDucasse 8/19/2009 23:34' prior: 0!This class implements an image that appears one way or another depending upon whether it lies within a spotlight shape that moves with the cursor.  As delivered, the shape is a simple circle, the spotlighted appearance is that of a ColorForm, and the non-highlighted apperarance is a derived gray-scale form.	(ImageMorphWithSpotlight new image: (Form fromUser)) openInWorld 	The implementation will space-efficient if supplied with a ColorForm, because the gray-scale derived form will share the same bitmap.In general, any two images can be used -- one could be blurred, the other sharp -- and the masking form can be any shape.At some point this class should be merged somehow with ScreeningMorph.-- Note from Stephane Ducasse - August 2009: Does not seem to work with ColorForm!!ClockMorph commentStamp: 'StephaneDucasse 8/19/2009 22:54' prior: 0!A ClockMorph is oneline clock	ClockMorph new openInWorld 	ClockMorph new openInHand!!FrameRateMorph commentStamp: 'StephaneDucasse 8/19/2009 22:59' prior: 0!A little Morph to show the speed of frame rate of the system.	FrameRateMorph new openInWorld.	FrameRateMorph new openInHand.!!InfoStringMorph commentStamp: '<historical>' prior: 0!A generalization of the clock morphTry	InfoStringMorph new openInWorldor	(InfoStringMorph on: [Smalltalk vm parameterAt: 9])		stepTime: 50;		openInWorld!!BackgroundMorph commentStamp: 'StephaneDucasse 8/20/2009 15:52' prior: 0!This morph incorporates tiling and regular motion with the intent of supporting, eg, panning of endless (toroidal) backgrounds.The idea is that embedded morphs get displayed at a moving offset relative to my position.  Moreover this display is tiled according to the bounding box of the submorphs (subBounds), as much as necesary to fill the rest of my bounds.	(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser)) openInWorld!!BouncingAtomsMorph commentStamp: '<historical>' prior: 0!This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:BouncingAtomsMorph new openInWorld   1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!MagnifierMorph commentStamp: 'TestRunner 11/14/2009 16:57' prior: 0!MagnifierMorph instances are magnifying lenses that magnify the morphs below them (if grabbed or if trackPointer is false) or the area around the mouse pointer.	MagnifierMorph newShowingPointer openInWorld 		MagnifierMorph new openInWorld	Instance variables:magnification	<Number> The magnification to use. If non-integer, smooths the magnified form.trackPointer		<Boolean> If set, magnifies the area around the Hand. If not, magnfies the area underneath the magnifier center.showPointer		<Boolean> If set, display a small reversed rectangle in the center of the lens. Also enables the display of Morphs in the Hand itself.srcExtent		<Rectangle> The extent of the source rectangle.		Class variables:RecursionLock	<MagnifierMorph|nil> Used to avoid infinite recursion when getting the source patch to display.!!FishEyeMorph commentStamp: 'StephaneDucasse 8/19/2009 23:43' prior: 0!A FishEyeMorph is an extreme-wide-angle lens MagnifierMorph	FishEyeMorph new openInWorld!!RectangleMorph commentStamp: 'PhilippeBack 8/8/2014 10:19' prior: 0!A RectangleMorph is  a compatibility class to allow this package to load as it is now replaced by BorderedMorph since Pharo 3.0!!DoubleClickExample commentStamp: 'StephaneDucasse 8/19/2009 22:55' prior: 0!Illustrates the double-click capabilities of Morphic.DoubleClickExample new openInWorld 	If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #click: to react to single-clicked mouse-down.(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.(5)  Reimplement #drag: to react to non-clicks.  This message is sent continuously until the button is released.  You can check the event argument to react differently on the first, intermediate, and last calls.!!HeadingMorph commentStamp: 'StephaneDucasse 8/19/2009 23:00' prior: 0!A HeadingMorph displays an arrow on a grid as well as its decomposition on x and y axis.Clicking on it changes the direction of the main arrow.	HeadingMorph new openInWorld!!StarWithABallMorph commentStamp: '<historical>' prior: 0!This is a example of how to use a morph. It consists of only two methods, initialize and step.	StarWithABallMorph new openInWorld.!!StickyPadMorph commentStamp: '<historical>' prior: 0!A colored sticker note: translucent, borderless Rectangles in a sequence of 6 colors.  StickyPadMorph minimics the stickyPad 			StickyPadMorph new openInWorld 	!!AtomMorph commentStamp: 'tbn 11/25/2004 09:06' prior: 0!AtomMorph represents an atom used in the simulation ofan ideal gas. It's container is typically a BouncingAtomsMorph.Try:	BouncingAtomsMorph  new openInWorldto open the gas simulation or:	AtomMorph exampleto open an instance in the current world!!Flasher commentStamp: 'StephaneDucasse 8/19/2009 22:56' prior: 0!A simple example - a circle that flashes.	Flasher new openInWorld The "onColor" instance variable indicates the color to use when "on",  A darker color is used to represent "off".The #step method, called every 500ms. by default, alternatively makes the flasher show its "on" and its "off" color.!!MovingEyeMorph commentStamp: '<historical>' prior: 0!A MovingEyeMorph is a morph representing an eye whose iris is following the mouse cursor.	MovingEyeMorph new openInWorld!!WatchMorph commentStamp: '<historical>' prior: 0!This class is a representation of a watch.The labels' font is changeble. Labels' font size increase or decrease when resizing me.WatchMorph new openInWorld(WatchMorph fontName: 'ComicPlain' bgColor: Color transparent centerColor: Color transparent) openInWorld		" transparent "(WatchMorph fontName: 'ComicBold' bgColor: Color white centerColor: Color black) openInWorldStructure:	fontName		String -- the labels' font name	cColor			Color -- center color	handsColor		Color	romanNumerals	Boolean	antialias		Boolean!!ClipboardMorph commentStamp: 'StephaneDucasse 8/20/2009 16:02' prior: 33915787!A morph that always displays the current contents of the text clipboard.	ClipboardMorph new openInWorld!----STARTUP----2016-02-17T11:25:33.15028+01:00 as D:\Users\Cédric\Desktop\Pharo4.0\Pharo4.0.image!!ClipboardMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 8/20/2009 16:00'!defaultBorderColor	"answer the default border color/fill style for the receiver"		^ Color		r: 1.0		g: 0.355		b: 0.452! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 6! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color blue! !!ClipboardMorph methodsFor: 'parts bin' stamp: 'StephaneDucasse 8/20/2009 16:01'!initialize	super initialize.	self extent: 250 @ 200.	self		backgroundColor: (Color				r: 0.484				g: 1.0				b: 0.484).	self setBalloonText: 'This shows the current contents of the text clipboard'.	self newContents: Clipboard clipboardText! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 14:15'!step	self newContents: Clipboard clipboardText! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 14:18'!stepTime	"Answer the interval between steps -- in this case a leisurely 1 seconds"	^ 1000! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 13:40'!wantsSteps	^ true! !!StarMorph commentStamp: '<historical>' prior: 33915944!I am a very flexible star.	StarMorph new openInHandAdd my handles using cmd-shift + click and you can move and resize me.The up and down arrows increase or reduce the number of my sides.The right and left arrows cycle thru different amounts of  pointiness.Use the arrows right and left of my center or get stars with a specific amount of pointyness.  The left side goes from fat to thin and then cycles around again. The right goes from thin to fat. Hold down the shift key if you wish to stop the cycling at the extremes.Use the arrows up and down to change the number of sides if you would like a different number of points.To add or remove just one side hold the shift key down as you use the arrows or use the menu items for that purpose.If you add or remove just one point I will have an odd number of sides.  When that happens I can only look like a regular polygon. The right and left arrows will have no effect.  Add or remove just one more side and you can shift drag the outer handle or use the arrows to restore my pointiness. That was too complicated. It is gone. You can get regular polygon shapes by adjusting my pointiness. For example the extreme of a five pointed star is a dodecahedron (10 sided regular polygon) and one step less extreme is a pentagon (5 sided regular polygon).At some time you will probably shift drag the outer handle thru the center handle.While I looked round as you shrunk me, I will look very much like an asterisk as you pull me away.  What happens is that inside bend shrunk on the way down because it can never be larger than the outer point (or it wouldn't be the innerbend would it).But on the way out it is perfectly happy to remain small. So I look like an asterisk.To fatten me up  (if you haven't already figured this out by fooling around)  hold the shift down an move the outer handle towards the center (but not quite all the way) then let the shift up and move the outer handle away.  A couple of cycles like this and I'll be looking fat and jolly again. Or you can now just use the right arrow to make me fatter.This is also the reason I don't let the inside bend get larger than the outer point.If I did the same process that fattened me when I was an asterisk would also grow an asterisk so large squeak would complain about not having enough memory.Historical note:The former star had two bugs that are fixed here.The outer handle now no longer jumps from one point to another.The other bug prevented some higher order stars from looking right. Which is why the former star didn't allow you to change the number of points. !!StarMorph methodsFor: 'menu' stamp: 'wiz 9/5/2005 23:08'!addChangeSidesMenuItems: aCustomMenu hand: aHandMorph 	"Menu items to change number of sides."	aCustomMenu addLine.	aCustomMenu add: 'more sides' translated action: #moreVertices.	aCustomMenu add: 'fewer sides' translated action: #lessVertices."	Regular polygons can be simulated with the one of the skip stars 	and it would confuse users to have stars be limited to Regular polygons.	So we've removed those menu items - wiz""	aCustomMenu add: 'one more side' translated action: #oneMoreVertex.	aCustomMenu add: 'one fewer side' translated action: #oneLessVertex"! !!StarMorph methodsFor: 'menu' stamp: 'wiz 1/11/2005 14:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.self addChangeSidesMenuItems: aCustomMenu hand: aHandMorph.self addTwinkleMenuItems: aCustomMenu hand: aHandMorph.	! !!StarMorph methodsFor: 'editing' stamp: 'wiz 12/15/2004 00:59'!addHandles	self addStarHandles! !!StarMorph methodsFor: 'editing' stamp: 'StephaneDucasse 2/27/2013 20:08'!addStarHandles	"Outer handle must not be blocked so it comes first. 	The editing routine expects to find the center handle second.	The side and shape changing handles follow these."	| center |	self removeHandles.	"Check for old stars and correct order of vertices."	handles := OrderedCollection new.	center := vertices average rounded.	self 		withCenterOuterHandles; 		withUpDownLeftRightHandlesAround: 6 center: center.	self placeHandles.	self changed.	! !!StarMorph methodsFor: 'menu' stamp: 'wiz 1/11/2005 20:38'!addTwinkleMenuItems: aCustomMenu hand: aHandMorph 	"Menu items to change the sharpness of the star."	aCustomMenu addLine.	aCustomMenu add: 'twinkle fatter' translated action: #nextTwinkle.	aCustomMenu add: 'twinkle thinner' translated action: #prevTwinkle."	aCustomMenu add: 'fatter star' translated action: #nextFatter.	aCustomMenu add: 'thinner star' translated action: #prevThinner"		! !!StarMorph methodsFor: 'editing' stamp: 'wiz 9/5/2005 23:12'!changeVertices: label event: evt fromHandle: handle 	| |	label == #more		ifTrue: [evt shiftPressed				ifTrue: [self moreVertices "not oneMoreVertex"]				ifFalse: [self moreVertices]].	label == #less		ifTrue: [evt shiftPressed				ifTrue: [self lessVertices "not oneLessVertex"]				ifFalse: [self lessVertices]].	label == #next		ifTrue: [evt shiftPressed				ifTrue: [self makeVertices: vertices size starRatio: self nextSkip]				ifFalse: [self makeVertices: vertices size starRatio: self nextTwinkleSkip]].	label == #prev		ifTrue: [evt shiftPressed				ifTrue: [self makeVertices: vertices size starRatio: self prevSkip]				ifFalse: [self makeVertices: vertices size starRatio: self prevTwinkleSkip]].	self computeBounds! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:09'!defaultCenter	"answer the default center for the receiver"	^ 0@0! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:09'!defaultFirstVertex	"answer the default first outer point for the receiver.	This with the center determines the angle and size of the outer radius."	^ 10@10! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:28'!defaultSides	"answer the default number of sides for the receiver"	^ 10! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:29'!defaultStarRatio	"answer the default ratio of outer radius to inner radius for the receiver"	^ 5.0 / 12.0! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/20/2005 19:07'!dragVertex: label event: evt fromHandle: handle 	| center r1 rN rNext a1 rTotal |	label == #outside		ifTrue: [center := handles second center.			r1 := center dist: vertices first.			"Rounding and what happens as the outer handle			approached the center, 			requires we guard the inner radius 			from becoming larger than the outer radius."			rN := r1						min: (center dist: vertices last).			rNext := 1						max: (center dist: evt cursorPoint).			a1 := 270.0						+ (center bearingToPoint: evt cursorPoint).			rTotal := vertices size even						ifTrue: [evt shiftPressed								ifTrue: [rNext + rNext min: rNext + rN]								ifFalse: [r1 + rN * rNext / r1]]						ifFalse: [rNext + rNext].			rNext := rTotal - rNext.			vertices := ((a1 to: a1 + 359.999 by: 360.0 / vertices size)						collect: [:angle | center								+ (Point r: (rNext := rTotal - rNext) degrees: angle)]) .			handle align: handle center with: evt cursorPoint].	label == #center		ifTrue: [evt shiftPressed				ifTrue: [self updateFormFromUser]				ifFalse: [self position: self position + (evt cursorPoint - handle center)]].	self computeBounds! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:36'!initialize	"initialize the state of the receiver"	super initialize.	self		makeVertices: self defaultSides		starRatio: self defaultStarRatio		withCenter: self defaultCenter		withPoint: self defaultFirstVertex.	self computeBounds! !!StarMorph methodsFor: 'parts bin' stamp: 'sw 7/2/2001 11:07'!initializeToStandAlone	^ self initialize removeHandles! !!StarMorph methodsFor: 'menus' stamp: 'wiz 12/12/2004 16:43'!lessVertices"Reduce the number of points by one until we are  a diamond. If odd reduce the number of sides by two until we become a triangle. See class comment."	| nVerts |	( nVerts := 2 negated + vertices size) < 3 ifFalse: [	self		makeVertices: nVerts]! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:10'!makeVertices: nSides 	"Assuming vertices has at least one point, make a new star 	or regular polygon (for odd sided polygons).	The center of the polygon and the first vertex remain in	place. The inner distances for stars remain the same also if	possible."	| center r1 rN rNext a1 rTotal |	center := vertices average rounded.	r1 := center dist: vertices first.	rN := center dist: vertices last.	rNext := 1 max: r1.	a1 := 270.0 + (center bearingToPoint: vertices first).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed .	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/4/2005 19:31'!makeVertices: nSides starRatio: fraction	"Assuming vertices has at least one point, make a new star 	or regular polygon (for odd sided polygons).	The center of the polygon and the first vertex remain in	place. The inner distances for stars remain the same also if	possible."	| center r1 rN rNext a1 rTotal |	center := vertices average rounded.	r1 := center dist: vertices first.	rNext := 1 max: r1.	rN := (1.0 min: fraction) * rNext.	a1 := 270.0				+ (center bearingToPoint: vertices first).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed .	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:10'!makeVertices: nSides starRatio: fraction withCenter: center withPoint: aPoint 	"Make a new star or regular polygon (for odd sided polygons).	This makes star vertices from scratch without any feedback from existing vertices."	| r1 rN rNext a1 rTotal |	r1 := center dist: aPoint.	rNext := 1 max: r1.	rN := (1.0 min: fraction) * rNext.	a1 := 270.0 + (center bearingToPoint: aPoint).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed.	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'menus' stamp: 'wiz 12/11/2004 16:45'!moreVertices	self makeVertices: 2+ vertices size! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!nextSkip	"Set starRatio to next skip wrapping if needed."	| skips n c r1 rN |	c := vertices average rounded.	r1 := (c dist: vertices first) truncated asFloat.	rN := c dist: vertices last.	skips := self skipRatios.	n := skips * r1 findFirst: [:r | r > (rN + 1.0)].	"n = 0		ifTrue: [n := skips size]."	^ skips atWrap: n! !!StarMorph methodsFor: 'menus' stamp: 'wiz 1/11/2005 20:37'!nextTwinkle	self makeVertices: vertices size starRatio: self nextTwinkleSkip .	self computeBounds.! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!nextTwinkleSkip	"Set starRatio to next skip wrapping if needed."	| skips n c r1 rN |	c := vertices average rounded.	r1 := (c dist: vertices first) truncated asFloat.	rN := c dist: vertices last.	skips := self skipRatios.	n := skips * r1 findFirst: [:r | r > (rN + 1.0)].	n = 0		ifTrue: [ n := 1].	^ skips atWrap: n! !!StarMorph methodsFor: 'menu' stamp: 'StephaneDucasse 2/27/2013 20:11'!oneLessVertex	self makeVertices: (3 max: 1 negated + vertices size)! !!StarMorph methodsFor: 'menu' stamp: 'wiz 12/11/2004 16:46'!oneMoreVertex	self makeVertices: 1 + vertices size! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/15/2005 00:19'!placeHandles	"Add the handles to my submorphs."	handles reverseDo: [:each | self addMorphFront: each ] .		! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!prevSkip	"Set starRatio to next skip wrapping if necessary"	| skips n c r1 rN |	c := vertices average rounded.	r1 := c dist: vertices first.	rN := (c dist: vertices last) truncated asFloat.	skips := self skipRatios.	n := skips * r1 findLast: [:r | r + 1.0 < rN].	n = 0		ifTrue: [n := 1].	^ skips at: n! !!StarMorph methodsFor: 'menus' stamp: 'wiz 1/11/2005 20:37'!prevTwinkle	self makeVertices: vertices size starRatio: self prevTwinkleSkip .	self computeBounds.! !!StarMorph methodsFor: 'geometry' stamp: 'wiz 1/19/2005 22:19'!prevTwinkleSkip	"Set starRatio to next skip wrapping if necessary"	| skips n c r1 rN |	c := vertices average rounded.	r1 := c dist: vertices first.	rN := (c dist: vertices last) truncated asFloat.	skips := self skipRatios.	n := skips * r1				findLast: [:r | r + 1.0 < rN].	"n = 0	ifTrue: [^ oldR]."	^ skips atWrap: n! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:07'!skipRatios	"Return an array of  ratios  of the inner radius to the outer radius.	Ratios are in ascending order from 0.0 to 1.0."	"Assume we have at least one vertex.	Always return a number <= 1.0"	| n  alpha  |	"Odd vertices sizes can not be stars only regular polygons"	n := vertices size . n odd ifTrue: [ ^ #(  1.0) ] .	alpha := Float pi / (n//2)  asFloat .	^ ((((Float halfPi -alpha  to: alpha /2.0  by: alpha  negated ) 			collect:  [:angle | angle sin /	(angle + alpha ) sin ]		) copyWith: 0.0) copyWithFirst: 1.0) reversed.! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:06'!starRatio	"Return the ratio of the inner radius to the outer radius."	"Assume we have at least one vertex.	Always returns a number <= 1.0"		| r c |	c := vertices average rounded.	r := (c dist: vertices last) / (c dist:  vertices first).	^ r > 1.0  ifTrue: [  r reciprocal ] ifFalse: [r ].! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:08'!starRatio: r	"Set the star s.t. the ratio of the inner radius to the outer radius is r.	If r is > 1 use the reciprocal to keep the outer radius first."	"Assume we have at least one vertex.All ways return a number <= 1.0"	self 		makeVertices: vertices size 		starRatio: ( r > 1.0  ifTrue: [ r reciprocal ] ifFalse: [r ] ).! !!StarMorph methodsFor: 'menus' stamp: 'StephaneDucasse 2/27/2013 20:16'!updateFormFromUser	"Does nothing here. Overridden in subclasses e.g. Kaleidoscope."	^ self.! !!StarMorph methodsFor: 'editing' stamp: 'di 9/26/97 11:11'!updateHandles! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/11/2005 19:39'!withCenterOuterHandles	"Add to our handles the center positioning and outer resizing	handles. Outer handle must not be blocked so it comes first. 	The editing routine expects to find the center handle second.	The side and shape changing handles follow these."	| center v1 hExtent holder |	center := vertices average rounded.	hExtent := 8 @ 8.	v1 := vertices first.	holder := {(EllipseMorph				newBounds: (Rectangle center: v1 extent: hExtent)				color: Color yellow)				setBalloonText: 'Move me to adjust size. Shift move to adjust pointiness'. (EllipseMorph				newBounds: (Rectangle center: center extent: hExtent)				color: Color yellow)				setBalloonText: 'Move me to adjust position'}.	holder		with: {#outside. #center}		do: [:handle :which | handle				on: #mouseDown				send: #dragVertex:event:fromHandle:				to: self				withValue: which;								on: #mouseMove				send: #dragVertex:event:fromHandle:				to: self				withValue: which].	handles addAll: holder! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/11/2005 19:47'!withUpDownLeftRightHandlesAround: radius center: center	"Add to our handles the side and shape changing handles."	| tri  above holder  triAbove triBelow triRight triLeft |	above := 0 @ radius negated.		tri := Array				with: 0 @ -5				with: 4 @ 3				with: -4 @ 3.	triAbove := tri + (center + above).	triBelow := triAbove				collect: [:pt | pt rotateBy: #pi centerAt: center].	triRight := triAbove				collect: [:pt | pt rotateBy: #right centerAt: center].	triLeft := triAbove				collect: [:pt | pt rotateBy: #left centerAt: center].					holder := { (PolygonMorph				vertices: triAbove				color: Color green				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'More points.'. 								(PolygonMorph				vertices: triBelow				color: Color magenta				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Fewer points.'. 								(PolygonMorph				vertices: triRight				color: Color green				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Twinkle fatter.'. 								(PolygonMorph				vertices: triLeft				color: Color magenta				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Twinkle thinner.'}.		holder		with: {#more. #less. #next. #prev}		do: [:handle :which | handle				on: #mouseDown				send: #changeVertices:event:fromHandle:				to: self				withValue: which;								on: #mouseMove				send: #changeVertices:event:fromHandle:				to: self				withValue: which].	^ handles addAll: holder! !!AnimatedImageMorph commentStamp: 'StephaneDucasse 8/20/2009 10:40' prior: 33918641!I am an ImageMorph that can hold more than one image. Each image has its own delay time.If you have an animated gif close to the image named 	(AnimatedImageMorph fromGIFFileNamed: 'animated.gif') openInWorld !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'nk 6/12/2004 13:11'!fileReaderServicesForFile: fullName suffix: suffix	^((AnimatedGIFReadWriter typicalFileExtensions asSet		add: '*'; add: 'form'; yourself)		includes: suffix)		ifTrue: [ self services ]		ifFalse: [#()]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:23'!fromGIFFileNamed: fileName	| reader |	reader := AnimatedGIFReadWriter formsFromFileNamed: fileName.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:27'!fromStream: aStream	| reader |	reader := AnimatedGIFReadWriter formsFromStream: aStream.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!AnimatedImageMorph class methodsFor: 'initialization' stamp: 'asm 12/11/2003 21:05'!initialize	"register the receiver in the global registries"	self environment		at: #FileList		ifPresent: [:cl | cl registerFileReader: self]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 16:57'!openGIFInWindow: aStream	^(self fromStream: aStream binary) openInWorld! !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'dgd 4/3/2006 13:36'!serviceOpenGIFInWindow	"Answer a service for opening a gif graphic in a window"	^ (SimpleServiceEntry		provider: self		label: 'open the graphic as a morph'		selector: #openGIFInWindow:		description: 'open a GIF graphic file as a morph'		buttonLabel: 'open')		argumentGetter: [:fileList | fileList readOnlyStream]! !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'dgd 4/3/2006 13:36'!services	^ Array		with: self serviceOpenGIFInWindow		"with: Form serviceImageImports"		with: Form serviceImageAsBackground! !!AnimatedImageMorph class methodsFor: 'initialization' stamp: 'asm 12/11/2003 21:01'!unload	"Unload the receiver from global registries"	self environment		at: #FileList		ifPresent: [:cl | cl unregisterFileReader: self]! !!AnimatedImageMorph methodsFor: 'private' stamp: 'nk 2/15/2004 15:20'!fromGIFFileNamed: fileName	self fromReader: (AnimatedGIFReadWriter formsFromFileNamed: fileName)! !!AnimatedImageMorph methodsFor: 'private' stamp: 'bf 2/25/2005 11:18'!fromReader: reader	images := reader forms.	delays := reader delays.	imageIndex := 0.	self image: (Form extent: images first extent depth: 32).	self step! !!AnimatedImageMorph methodsFor: 'private' stamp: 'nk 2/15/2004 15:20'!fromStream: aStream	self fromReader: (AnimatedGIFReadWriter formsFromStream: aStream)! !!AnimatedImageMorph methodsFor: 'private' stamp: 'mir 11/19/2003 13:42'!images	^images! !!AnimatedImageMorph methodsFor: 'private' stamp: 'bf 2/25/2005 11:09'!initialize	nextTime := Time millisecondClockValue.	imageIndex := 1.	stepTime := 10.	super initialize! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'marcus.denker 9/14/2008 19:13'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue ifTrue: [^self].	self changed.	self image: (images at: (imageIndex := imageIndex \\ images size + 1)).	self changed . 	d := (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'mir 11/19/2003 13:40'!stepTime	^stepTime ifNil: [super stepTime]! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'mir 11/19/2003 13:40'!stepTime: anInteger	stepTime := anInteger! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'StephaneDucasse 2/27/2013 21:20'!wantsSteps	^ images size > 1! !!ImageMorphWithSpotlight commentStamp: 'StephaneDucasse 8/19/2009 23:34' prior: 33918938!This class implements an image that appears one way or another depending upon whether it lies within a spotlight shape that moves with the cursor.  As delivered, the shape is a simple circle, the spotlighted appearance is that of a ColorForm, and the non-highlighted apperarance is a derived gray-scale form.	(ImageMorphWithSpotlight new image: (Form fromUser)) openInWorld 	The implementation will space-efficient if supplied with a ColorForm, because the gray-scale derived form will share the same bitmap.In general, any two images can be used -- one could be blurred, the other sharp -- and the masking form can be any shape.At some point this class should be merged somehow with ScreeningMorph.-- Note from Stephane Ducasse - August 2009: Does not seem to work with ColorForm!!ImageMorphWithSpotlight class methodsFor: 'example' stamp: 'StephaneDucasse 8/19/2009 23:05'!example1	"self example1"		(self new image: (Form fromUser)) openInWorld! !!ImageMorphWithSpotlight methodsFor: 'accessing' stamp: 'di 5/26/1999 07:51'!backgroundImage: bkgndImage spotImage: anImage spotShape: formOfDepth1	"See class comment."	spotImage := anImage.	spotShape := formOfDepth1.	spotBuffer := Form extent: spotShape extent depth: spotImage depth.	super image: bkgndImage.	spotOn := false.! !!ImageMorphWithSpotlight methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.	spotOn ifTrue:		[aCanvas paintImage: spotBuffer at: spotBuffer offset].! !!ImageMorphWithSpotlight methodsFor: 'accessing' stamp: 'di 5/26/1999 08:05'!image: anImage	"The spotlight will reveal the original  form supplied	while the background form will be derived grayscale."	"See class comment."	self backgroundImage: anImage asGrayScale		spotImage: anImage		spotShape: (Form dotOfSize: 100)! !!ImageMorphWithSpotlight methodsFor: 'drawing' stamp: 'di 5/24/1999 22:37'!spotChanged	self invalidRect:		((spotBuffer offset extent: spotBuffer extent) "intersect: self bounds")! !!ImageMorphWithSpotlight methodsFor: 'stepping and presenter' stamp: 'ar 5/28/2000 12:09'!step	| cp |	((self bounds expandBy: spotBuffer extent // 2) containsPoint: (cp := self cursorPoint))		ifTrue:		[(cp - (spotBuffer extent // 2)) = spotBuffer offset ifTrue: [^ self].  "No change"		"Cursor has moved where its spotShape is visible"		spotOn := true.		self spotChanged.		spotBuffer offset: cp - (spotBuffer extent // 2).		self spotChanged.		(BitBlt current toForm: spotBuffer)			"clear the buffer"			fill: spotBuffer boundingBox fillColor: (Bitmap with: 0) rule: Form over;			"Clip anything outside the base form"			clipRect: (spotBuffer boundingBox				intersect: (self bounds translateBy: spotBuffer offset negated));			"Fill the spotBuffer with the spot image"			copyForm: spotImage to: self position - spotBuffer offset rule: Form over;			"Mask everything outside the spot shape to 0 (transparent)."			copyForm: spotShape to: spotShape offset negated rule: Form and				colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)]		ifFalse:		[spotOn ifTrue: [self spotChanged. spotOn := false]]! !!ImageMorphWithSpotlight methodsFor: 'stepping and presenter' stamp: 'di 5/24/1999 21:43'!stepTime	^ 20! !!ClockMorph commentStamp: 'StephaneDucasse 8/19/2009 22:54' prior: 33919801!A ClockMorph is oneline clock	ClockMorph new openInWorld 	ClockMorph new openInHand!!ClockMorph methodsFor: 'menu' stamp: 'stephane.ducasse 2/14/2009 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Note minor loose end here -- if the menu is persistent, then the wording will be wrong half the time"	| item |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	item := showSeconds 		ifTrue:	['stop showing seconds']		ifFalse: ['start showing seconds'].	aCustomMenu add: item translated target: self action: #toggleShowingSeconds.	item := show24hr		ifTrue: ['display Am/Pm']		ifFalse: ['display 24 hour'].	aCustomMenu add: item translated target: self action: #toggleShowing24hr.			! !!ClockMorph methodsFor: 'initialization' stamp: 'stephane.ducasse 2/14/2009 17:37'!initialize	"initialize the state of the receiver"		super initialize.	showSeconds := true.	show24hr := false.	self step! !!ClockMorph methodsFor: 'parts bin' stamp: 'sw 7/12/2001 17:41'!initializeToStandAlone	super initializeToStandAlone.	showSeconds := true.	self step! !!ClockMorph methodsFor: '24hr' stamp: 'fc 2/8/2004 11:38'!show24hr: aBoolean	show24hr := aBoolean! !!ClockMorph methodsFor: 'seconds' stamp: 'sw 2/17/1999 14:39'!showSeconds: aBoolean	showSeconds := aBoolean! !!ClockMorph methodsFor: 'stepping and presenter' stamp: 'stephane.ducasse 2/14/2009 17:37'!step	| time |	super step.	time := String streamContents:		[:aStrm | Time now print24: show24hr  showSeconds: showSeconds on: aStrm].	self contents: time			! !!ClockMorph methodsFor: 'testing'!stepTime	"Answer the desired time between steps in milliseconds."	^ 1000! !!ClockMorph methodsFor: '24hr' stamp: 'stephane.ducasse 2/14/2009 17:37'!toggleShowing24hr	show24hr := show24hr not! !!ClockMorph methodsFor: 'seconds' stamp: 'stephane.ducasse 2/14/2009 17:37'!toggleShowingSeconds	showSeconds := showSeconds not! !!FrameRateMorph commentStamp: 'StephaneDucasse 8/19/2009 22:59' prior: 33919963!A little Morph to show the speed of frame rate of the system.	FrameRateMorph new openInWorld.	FrameRateMorph new openInHand.!!FrameRateMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:11'!initialize	"initialize the state of the receiver"	super initialize.	lastDisplayTime := 0.	framesSinceLastDisplay := 0! !!FrameRateMorph methodsFor: 'parts bin' stamp: 'sw 7/19/2001 13:39'!initializeToStandAlone	"Initialize the receiver as a stand-alone entity"	super initializeToStandAlone.	self color: Color blue.	self step! !!FrameRateMorph methodsFor: 'stepping and presenter' stamp: 'sw 10/5/2000 06:52'!step	"Compute and display (every half second or so) the current framerate"	| now mSecs mSecsPerFrame framesPerSec newContents |	framesSinceLastDisplay := framesSinceLastDisplay + 1.	now := Time millisecondClockValue.	mSecs := now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: 		[mSecsPerFrame := mSecs // framesSinceLastDisplay.		framesPerSec := (framesSinceLastDisplay * 1000) // mSecs.		newContents := mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frame', (framesPerSec == 1 ifTrue: [''] ifFalse: ['s']), '/sec)'.		self contents: newContents.		lastDisplayTime := now.		framesSinceLastDisplay := 0]! !!FrameRateMorph methodsFor: 'testing' stamp: 'jm 2/23/98 18:41'!stepTime	"Answer the desired time between steps in milliseconds."	^ 0! !!InfoStringMorph commentStamp: '<historical>' prior: 33920150!A generalization of the clock morphTry	InfoStringMorph new openInWorldor	(InfoStringMorph on: [Smalltalk vm parameterAt: 9])		stepTime: 50;		openInWorld!!InfoStringMorph class methodsFor: 'instance creation' stamp: 'sma 6/1/2000 14:07'!on: aBlock	^ self new block: aBlock! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:06'!block	^ block! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:05'!block: aBlock	block := aBlock! !!InfoStringMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:28'!initialize	"initialize the state of the receiver"	super initialize.	stepTime := 1000.	block := [Time now]! !!InfoStringMorph methodsFor: 'stepping and presenter' stamp: 'sma 6/1/2000 14:03'!step	self contents: block value asString! !!InfoStringMorph methodsFor: 'testing' stamp: 'sma 6/1/2000 14:03'!stepTime	^ stepTime! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:06'!stepTime: anInteger	stepTime := anInteger! !!BackgroundMorph commentStamp: 'StephaneDucasse 8/20/2009 15:52' prior: 33920386!This morph incorporates tiling and regular motion with the intent of supporting, eg, panning of endless (toroidal) backgrounds.The idea is that embedded morphs get displayed at a moving offset relative to my position.  Moreover this display is tiled according to the bounding box of the submorphs (subBounds), as much as necesary to fill the rest of my bounds.	(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser)) openInWorld!!BackgroundMorph class methodsFor: 'as yet unclassified' stamp: 'kfr 8/7/2004 16:10'!test	"BackgroundMorph test"	^(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser))openInWorld.! !!BackgroundMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 20:56'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	running		ifTrue: [aCustomMenu add: 'stop' translated action: #stopRunning]		ifFalse: [aCustomMenu add: 'start' translated action: #startRunning]! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 12:23'!delta	^delta! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 12:24'!delta: aPoint	delta := aPoint.! !!BackgroundMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:06'!drawOn: aCanvas	"The tiling is solely determined by bounds, subBounds and offset.	The extent of display is determined by bounds and the clipRect of the canvas."	| start d subBnds |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	subBnds := self subBounds.	running ifFalse:		[super drawOn: aCanvas.		^ aCanvas fillRectangle: subBnds color: Color lightBlue].	start := subBnds topLeft + offset - bounds topLeft - (1@1) \\ subBnds extent - subBnds extent + (1@1).	d := subBnds topLeft - bounds topLeft."Sensor redButtonPressed ifTrue: [self halt]."	start x to: bounds width - 1 by: subBnds width do:		[:x |		start y to: bounds height - 1 by: subBnds height do:			[:y | aCanvas translateBy: (x@y) - d clippingTo: bounds				during:[:tileCanvas| self drawSubmorphsOn: tileCanvas]]].! !!BackgroundMorph methodsFor: 'layout'!fullBounds	^ self bounds! !!BackgroundMorph methodsFor: 'drawing' stamp: 'ar 12/30/2001 19:16'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	running ifFalse: [		^aCanvas clipBy: (bounds translateBy: aCanvas origin)				during:[:clippedCanvas| super fullDrawOn: clippedCanvas]].	(aCanvas isVisible: self bounds) ifTrue:[aCanvas drawMorph: self].! !!BackgroundMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:18'!initialize	"initialize the state of the receiver"	super initialize.	offset := 0 @ 0.	delta := 1 @ 0.	running := true! !!BackgroundMorph methodsFor: 'layout'!layoutChanged	"Do nothing, since I clip my submorphs"! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:50'!offset	^offset! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:50'!offset: aPoint	offset := aPoint! !!BackgroundMorph methodsFor: 'accessing'!slideBy: inc	submorphs isEmpty ifTrue: [^ self].	offset := offset + inc \\ self subBounds extent.	self changed! !!BackgroundMorph methodsFor: 'accessing'!startRunning	running := true.	self changed! !!BackgroundMorph methodsFor: 'stepping and presenter' stamp: 'fc 7/24/2004 13:47'!step		running ifTrue: [self slideBy: delta]! !!BackgroundMorph methodsFor: 'testing'!stepTime	"Answer the desired time between steps in milliseconds."	^ 20! !!BackgroundMorph methodsFor: 'accessing'!stopRunning	running := false.	self changed! !!BackgroundMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:20'!subBounds	"calculate the submorph bounds"	| subBounds |	subBounds := nil.	self submorphsDo: 			[:m | 			subBounds := subBounds isNil						ifTrue: [m fullBounds]						ifFalse: [subBounds merge: m fullBounds]].	^subBounds! !!BouncingAtomsMorph commentStamp: '<historical>' prior: 33920893!This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:BouncingAtomsMorph new openInWorld   1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!BouncingAtomsMorph class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'BouncingAtoms'		categories:		#('Demo')		documentation:	'The original, intensively-optimized bouncing-atoms simulation by John Maloney'! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:57'!initialize	self registerInFlapsRegistry.	! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:58'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(BouncingAtomsMorph	new	'Bouncing Atoms'	'Atoms, mate')						forFlapNamed: 'Widgets']! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/11/2003 12:32'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a := AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' translated action: #startInfection.	aCustomMenu add: 'set atom count' translated action: #setAtomCount.	aCustomMenu add: 'show infection history' translated action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'submorphs-add/remove'!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].! !!BouncingAtomsMorph methodsFor: 'drawing' stamp: 'di 1/4/1999 20:22'!areasRemainingToFill: aRectangle	color isTranslucent		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'aoy 2/15/2003 21:38'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to becircles of known radius. This version uses the morph's positions--i.e.the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared m1 m2 |	count := submorphs size.	sortedAtoms := submorphs 				asSortedCollection: [:mt1 :mt2 | mt1 position x < mt2 position x].	radius := 8.	twoRadii := 2 * radius.	radiiSquared := radius squared * 2.	collisions := OrderedCollection new.	1 to: count - 1		do: 			[:i | 			m1 := sortedAtoms at: i.			p1 := m1 position.			continue := (j := i + 1) <= count.			[continue] whileTrue: 					[m2 := sortedAtoms at: j.					p2 := m2 position.					continue := p2 x - p1 x <= twoRadii  								ifTrue: 									[distSquared := (p1 x - p2 x) squared + (p1 y - p2 y) squared.									distSquared < radiiSquared 										ifTrue: [collisions add: (Array with: m1 with: m2)].									(j := j + 1) <= count]								ifFalse: [false]]].	^collisions! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.8! !!BouncingAtomsMorph methodsFor: 'drawing'!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported := false.! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:17'!initialize	"initialize the state of the receiver"	super initialize.	damageReported := false.	self extent: 400 @ 250.	infectionHistory := OrderedCollection new.	transmitInfection := false.	self addAtoms: 30! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'ar 8/13/2003 11:41'!intoWorld: aWorld	"Make sure report damage at least once"	damageReported := false.	super intoWorld: aWorld.! !!BouncingAtomsMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:42'!invalidRect: damageRect from: aMorph	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw := true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds from: self].  "just report once"		damageReported := true.	] ifFalse: [super invalidRect: damageRect from: aMorph].  "ordinary damage report"! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'DamienCassou 9/29/2009 09:03'!setAtomCount	| countString count |	countString := UIManager default		request: 'Number of atoms?' translated		initialAnswer: self submorphCount printString.	countString isEmptyOrNil ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph := GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'menu'!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory := OrderedCollection new: 500.	transmitInfection := true.	self startStepping.! !!BouncingAtomsMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces := 0.	r := bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces := bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'testing' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected := false.		pair do: [:atom | atom infected ifTrue: [infected := true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count := 0.	self submorphsDo: [:m | m infected ifTrue: [count := count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection := false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'dgd 2/22/2003 13:36'!updateTemperature: currentTemperature 	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures isNil 		ifTrue: 			[recentTemperatures := OrderedCollection new.			20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature := recentTemperatures sum asFloat / recentTemperatures size! !!MagnifierMorph commentStamp: 'TestRunner 11/14/2009 16:57' prior: 33921830!MagnifierMorph instances are magnifying lenses that magnify the morphs below them (if grabbed or if trackPointer is false) or the area around the mouse pointer.	MagnifierMorph newShowingPointer openInWorld 		MagnifierMorph new openInWorld	Instance variables:magnification	<Number> The magnification to use. If non-integer, smooths the magnified form.trackPointer		<Boolean> If set, magnifies the area around the Hand. If not, magnfies the area underneath the magnifier center.showPointer		<Boolean> If set, display a small reversed rectangle in the center of the lens. Also enables the display of Morphs in the Hand itself.srcExtent		<Rectangle> The extent of the source rectangle.		Class variables:RecursionLock	<MagnifierMorph|nil> Used to avoid infinite recursion when getting the source patch to display.!!FishEyeMorph commentStamp: 'StephaneDucasse 8/19/2009 23:43' prior: 33922730!A FishEyeMorph is an extreme-wide-angle lens MagnifierMorph	FishEyeMorph new openInWorld!!FishEyeMorph methodsFor: 'initialization' stamp: 'yo 12/17/1999 12:00'!calculateTransform	| stepX stepY rect tx ty arrayX arrayY |	(gridNum x = 0 or: [gridNum y = 0]) ifTrue: [^self].	stepX := srcExtent x // gridNum x.	stepY := srcExtent y // gridNum y.	arrayX := (1 to: gridNum y + 1) collect: [:j | FloatArray new: gridNum x + 1].	arrayY := (1 to: gridNum y + 1) collect: [:j |  FloatArray new: gridNum x + 1].	0 to: gridNum y do: [:j |		0 to: gridNum x do: [:i |			(arrayX at: (j + 1)) at: (i + 1) put: i*stepX.			(arrayY at: (j + 1)) at: (i + 1) put: j*stepY.		].	].	0 to: gridNum y do: [:j |		self transformX: (arrayX at: (j+1)).		self transformY: (arrayY at: (j+1)).	].	0 to: gridNum y do: [:j |		arrayX at: (j+1) put: ((1 to: gridNum x +1) collect: [:i | ((arrayX at: (j+1)) at: i) asInteger]).		arrayY at: (j+1) put: ((1 to: gridNum x +1) collect: [:i | ((arrayY at: (j+1)) at: i) asInteger]).	].	clipRects := (1 to: gridNum y) collect: [:j | Array new: gridNum x].	toRects := (1 to: gridNum y) collect: [:j |  Array new: gridNum x].	quads := (1 to: gridNum y) collect: [:j |  Array new: gridNum x].	0 to: gridNum y - 1 do: [:j |		0 to: gridNum x- 1 do: [:i |			rect := (((arrayX at: (j+1)) at: (i+1))@((arrayY at: (j+1)) at: (i+1)))						corner: ((arrayX at: (j+2)) at: (i+2))@((arrayY at: (j+2)) at: (i+2)).			(clipRects at: j+1) at: i+1 put: rect.			rect width >= stepX ifTrue: [rect := rect expandBy: (1@0)].			rect height >= stepY ifTrue: [rect := rect expandBy: (0@1)].			(toRects at: j+1) at: i+1 put: rect.			tx := (i)*stepX.			ty := (j)*stepY.			(quads at: j+1) at: i+1						put: {(tx)@(ty). (tx)@(ty+stepY). (tx+stepX)@(ty+stepY). (tx+stepX)@(ty)}.		].	].! !!FishEyeMorph methodsFor: 'menus' stamp: 'dgd 9/21/2003 17:55'!chooseMagnification	self inform: 'Magnification is fixed, sorry.' translated! !!FishEyeMorph methodsFor: 'menu' stamp: 'yo 12/17/1999 12:03'!chooseMagnification: evt! !!FishEyeMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:19'!extent: aPoint	"Round to a number divisible by grid.  Note that the superclass has its own implementation."		| g gridSize |	gridSize := self gridSizeFor: aPoint.	"self halt."	g := (aPoint - (2 * borderWidth)) // gridSize.	srcExtent := g * gridSize.	gridNum := g.	^super extent: self defaultExtent! !!FishEyeMorph methodsFor: 'initialization' stamp: 'yo 12/17/1999 10:15'!g: aFloatArray max: max focus: focus	| dNormX array |	dNormX := aFloatArray - focus.		array := dNormX / max.	array *= d.	array += 1.0.	array := 1.0 / array.	dNormX *= (d+1.0).	array *= dNormX.	^array += focus.! !!FishEyeMorph methodsFor: 'private' stamp: 'yo 12/17/1999 11:15'!gridSizeFor: aPoint	"returns appropriate size for specified argument"	| g |	g := aPoint x min: aPoint y.	g <= 256 ifTrue: [^8].	^16.! !!FishEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:21'!initialize	"initialize the state of the receiver"		super initialize.	"magnification should be always 1"	magnification := 1.	d := 1.3.	self extent: 130 @ 130! !!FishEyeMorph methodsFor: 'parts bin' stamp: 'sw 6/28/2001 11:32'!initializeToStandAlone	super initializeToStandAlone.	"magnification should be always 1"	magnification := 1.	d := 1.3.	self extent: 130@130.! !!FishEyeMorph methodsFor: 'magnifying' stamp: 'ar 5/28/2000 12:12'!magnifiedForm	| warp warpForm fromForm |	savedExtent ~= srcExtent ifTrue: [		savedExtent := srcExtent.		self calculateTransform].	warpForm := Form extent: srcExtent depth: Display depth.	fromForm := super magnifiedForm.	warp :=  (WarpBlt current toForm: warpForm)		sourceForm: fromForm;		colorMap: nil;		cellSize: 2;		combinationRule: Form over.	1 to: gridNum y do: [:j |		1 to: gridNum x do: [:i |			warp				clipRect: ((clipRects at: j) at: i);				copyQuad: ((quads at: j) at: i)					toRect: ((toRects at: j) at: i).		].	].	^warpForm! !!FishEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:20'!transformX: aFloatArray	| focus gridNum2 subArray dMaxX |	focus := srcExtent x asFloat / 2.	gridNum2 := (aFloatArray findFirst: [:x | x > focus]) - 1.	dMaxX := 0.0 - focus.	subArray := self 					g: (aFloatArray copyFrom: 1 to: gridNum2) 					max: dMaxX focus: focus.	aFloatArray replaceFrom: 1 to: gridNum2 with: subArray startingAt: 1.	dMaxX := focus.    " = (size - focus)"	subArray := self 					g: (aFloatArray copyFrom: gridNum2 + 1 to: gridNum x + 1)					max: dMaxX focus: focus.	aFloatArray replaceFrom: gridNum2 + 1 to: gridNum x + 1 with: subArray startingAt: 1.! !!FishEyeMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:04'!transformY: aFloatArray 	| focus subArray dMaxY |	focus := srcExtent y asFloat / 2.	dMaxY := (aFloatArray first) <= focus 				ifTrue: [0.0 - focus]				ifFalse: [focus].	subArray := self 				g: (aFloatArray copyFrom: 1 to: gridNum x + 1)				max: dMaxY				focus: focus.	aFloatArray 		replaceFrom: 1		to: gridNum x + 1		with: subArray		startingAt: 1! !!MagnifierMorph class methodsFor: 'instance creation' stamp: 'StephaneDucasse 2/27/2013 20:21'!newShowingPointer	"Answer a Magnifier that also displays Morphs in the Hand and the Hand position"	^ self new		showPointer: true;		yourself! !!MagnifierMorph methodsFor: 'menu' stamp: 'TestRunner 11/14/2009 17:01'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu		addLine;		add: 'magnification...' translated action: #chooseMagnification;		addUpdating: #trackingPointerString action: #toggleTrackingPointer;		addUpdating: #showingPointerString action: #toggleShowingPointer! !!MagnifierMorph methodsFor: 'accessing' stamp: 'bf 9/21/1999 09:31'!borderWidth: anInteger	"Grow outwards preserving innerBounds"	| c |  	c := self center.	super borderWidth: anInteger.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'menu' stamp: 'alain.plantec 2/6/2009 17:08'!chooseMagnification	| result possibleMagnifications title |	possibleMagnifications := #(1.5 2 4 8).	title := 'Choose magnification' translated, '\(' , 'currently' translated, ' {1})' format: {magnification}.	result := UIManager default chooseFrom: possibleMagnifications values: possibleMagnifications title: title.	(result isNil or: [result = magnification]) ifTrue: [^ self].	magnification := result.	self extent: self extent. "round to new magnification"	self changed. "redraw even if extent wasn't changed"! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:02'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag := magnification.	aHand := evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin := aHand position y.	handle := HandleMorph new forEachPointDo:		[:newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag].	aHand attachMorph: handle.	handle startStepping.	self changed. "Magnify handle"! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:22'!defaultExtent	^(srcExtent * magnification) truncated + (2 * borderWidth)! !!MagnifierMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.		"border and fill"	aCanvas isShadowDrawing ifFalse: [		"Optimize because #magnifiedForm is expensive"		aCanvas paintImage: self magnifiedForm at: self innerBounds origin]! !!MagnifierMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:23'!extent: aPoint	"Round to multiples of magnification"		srcExtent := (aPoint - (2 * borderWidth)) // magnification.	^super extent: self defaultExtent! !!MagnifierMorph methodsFor: 'event handling' stamp: 'bf 9/18/1999 20:42'!handlesMouseDown: evt	^evt yellowButtonPressed		or: [super handlesMouseDown: evt]! !!MagnifierMorph methodsFor: 'testing' stamp: 'bf 9/21/1999 08:51'!hasTranslucentColor	"I may show what's behind me, so tell the hand to don't cache"	^self sourceRect intersects: self bounds! !!MagnifierMorph methodsFor: 'initialization' stamp: 'nk 3/6/2004 10:47'!initialize	"initialize the state of the receiver"	super initialize.	trackPointer := true.	showPointer := false.	magnification := 2.	self extent: 128 @ 128! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 12:27'!magnification: aNumber	| c |  	magnification := aNumber min: 8 max: 0.5.	magnification := magnification roundTo:		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).	srcExtent := srcExtent min: (512@512) // magnification. "to prevent accidents"	c := self center.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'TestRunner 11/14/2009 17:02'!magnifiedForm	"Answer the magnified form"	| srcRect form magnified |	srcRect := self sourceRectFrom: self sourcePoint.	(RecursionLock isNil and: [ self showPointer or: [ srcRect intersects: self bounds ]])		ifTrue: [RecursionLock := self.			form := self currentWorld						patchAt: srcRect						without: self						andNothingAbove: false.			RecursionLock := nil]		ifFalse: ["cheaper method if the source is not occluded"			form := Display copy: srcRect].	"smooth if non-integer scale"	magnified := form				magnify: form boundingBox				by: magnification				smoothing: (magnification isInteger						ifTrue: [1]						ifFalse: [2]).	"display the pointer rectangle if desired"	self showPointer		ifTrue: [magnified				reverse: (magnified center - (2 @ 2) extent: 4 @ 4)				fillColor: Color white].	^ magnified! !!MagnifierMorph methodsFor: 'event handling' stamp: 'bf 9/21/1999 10:45'!mouseDown: evt	evt yellowButtonPressed		ifTrue: [self chooseMagnification: evt]		ifFalse: [super mouseDown: evt]! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:34'!showPointer	^showPointer ifNil: [ showPointer := false ].! !!MagnifierMorph methodsFor: 'accessing' stamp: 'nk 3/6/2004 10:14'!showPointer: aBoolean	"If aBoolean is true, display the current pointer position as a small square in the center of the lens."	showPointer == aBoolean ifTrue: [ ^self ].	showPointer := aBoolean.	self changed.! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:34'!showingPointerString	^ (self showPointer		ifTrue: ['stop showing pointer']		ifFalse: ['start showing pointer']) translated! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 11/1/2000 16:02'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^(trackPointer not or: [owner notNil and: [owner isHandMorph]])		ifTrue: [self center]		ifFalse: [self currentHand position]! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 08:47'!sourceRect	^self sourceRectFrom: self sourcePoint! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'di 12/17/1999 13:42'!sourceRectFrom: aPoint	^ (aPoint extent: srcExtent) translateBy: (srcExtent // -2) + 1.! !!MagnifierMorph methodsFor: 'stepping and presenter' stamp: 'di 9/28/1999 07:57'!step	self changed! !!MagnifierMorph methodsFor: 'stepping and presenter' stamp: 'di 9/28/1999 07:57'!stepTime	^ 0! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:35'!toggleShowingPointer	self showPointer: self showPointer not! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:48'!toggleTrackingPointer	trackPointer := trackPointer not! !!MagnifierMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:51'!trackingPointerString	^ (trackPointer		ifTrue: ['stop tracking pointer']		ifFalse: ['start tracking pointer']) translated! !!RectangleMorph commentStamp: 'PhilippeBack 8/8/2014 10:19' prior: 33922892!A RectangleMorph is  a compatibility class to allow this package to load as it is now replaced by BorderedMorph since Pharo 3.0!!DoubleClickExample commentStamp: 'StephaneDucasse 8/19/2009 22:55' prior: 33923099!Illustrates the double-click capabilities of Morphic.DoubleClickExample new openInWorld 	If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #click: to react to single-clicked mouse-down.(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.(5)  Reimplement #drag: to react to non-clicks.  This message is sent continuously until the button is released.  You can check the event argument to react differently on the first, intermediate, and last calls.!!DoubleClickExample methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 21:13'!balloonText	^ 'Double-click on me to change my color; single-click on me to change border color;hold mouse down within me and then move it to grow (if I''m red) or shrink (if I''m blue).'! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!click: evt	self showBalloon: 'click' hand: evt hand.	self borderColor: (self borderColor = Color black ifTrue: [Color yellow] ifFalse: [Color black])! !!DoubleClickExample methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:22'!defaultColor"answer the default color/fill style for the receiver"	^ Color red! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!doubleClick: evt	self showBalloon: 'doubleClick' hand: evt hand.	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'event handling' stamp: 'sw 9/14/1999 16:05'!handlesMouseDown: evt	^ true! !!DoubleClickExample methodsFor: 'event handling' stamp: 'bf 9/28/1999 17:20'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!startDrag: evt	"We'll get a mouseDown first, some mouseMoves, and a mouseUp event last"	| oldCenter |	evt isMouseDown ifTrue:		[self showBalloon: 'drag (mouse down)' hand: evt hand.		self world displayWorld.		(Delay forMilliseconds: 750) wait].	evt isMouseUp ifTrue:		[self showBalloon: 'drag (mouse up)' hand: evt hand].	(evt isMouseUp or: [evt isMouseDown]) ifFalse:		[self showBalloon: 'drag (mouse still down)' hand: evt hand].	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter := self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !!HeadingMorph commentStamp: 'StephaneDucasse 8/19/2009 23:00' prior: 33923841!A HeadingMorph displays an arrow on a grid as well as its decomposition on x and y axis.Clicking on it changes the direction of the main arrow.	HeadingMorph new openInWorld!!HeadingMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:34'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!HeadingMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:10'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 1.0		b: 1.0! !!HeadingMorph methodsFor: 'accessing'!degrees	^ (degrees + 90.0) \\ 360.0! !!HeadingMorph methodsFor: 'accessing'!degrees: aNumber	degrees := (aNumber asFloat + 270.0) \\ 360.0.! !!HeadingMorph methodsFor: 'drawing'!drawArrowFrom: p1 to: p2 width: w color: aColor on: aCanvas	| d p |	d := (p1 - p2) theta radiansToDegrees.	aCanvas line: p1 to: p2 width: w color: aColor.	p := p2 + (Point r: 5 degrees: d - 50).	aCanvas line: p to: p2 width: w color: aColor.	p := p2 + (Point r: 5 degrees: d + 50).	aCanvas line: p to: p2 width: w color: aColor.! !!HeadingMorph methodsFor: 'drawing'!drawOn: aCanvas	| x y r center box |	super drawOn: aCanvas.	box := self innerBounds.	1 to: 9 do: [:i |		x := box left + ((box width * i) // 10).		aCanvas line: (x@box top) to: (x@(box bottom - 1)) color: Color black.		y := box top + ((box height * i) // 10).		aCanvas line: (box left@y) to: ((box right - 1)@y) color: Color black].	r := ((box width asFloat * magnitude asFloat) / 2.0) - 1.0.	center := box center.	self drawArrowFrom: center - (1@1)		to: center + ((r * degrees degreesToRadians cos)@0) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (0@(r * degrees degreesToRadians sin)) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (Point r: r degrees: degrees) - (1@1)		width: 3		color: Color black		on: aCanvas.! !!HeadingMorph methodsFor: 'geometry'!extent: aPoint	"Contrain extent to be square."	| d |	d := aPoint x min: aPoint y.	super extent: d@d.! !!HeadingMorph methodsFor: 'event handling'!handlesMouseDown: evt	^ true! !!HeadingMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:10'!initialize	"initialize the state of the receiver"	super initialize.	degrees := 90.0.	magnitude := 1.0.	self extent: 160 @ 160! !!HeadingMorph methodsFor: 'accessing'!magnitude	^ magnitude! !!HeadingMorph methodsFor: 'accessing'!magnitude: aNumber	magnitude := (aNumber asFloat max: 0.0) min: 1.0.! !!HeadingMorph methodsFor: 'events' stamp: 'mk 11/7/2003 11:35'!mouseDown: evt	| v |	self changed.	v := evt cursorPoint - bounds center.	degrees := v theta radiansToDegrees.	magnitude := (v r asFloat / (bounds width asFloat / 2.0)) min: 1.0.! !!HeadingMorph methodsFor: 'events' stamp: 'mk 11/7/2003 11:36'!mouseMove: evt	self mouseDown: evt! !!StarWithABallMorph commentStamp: '<historical>' prior: 33924077!This is a example of how to use a morph. It consists of only two methods, initialize and step.	StarWithABallMorph new openInWorld.!!StarWithABallMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 19:59'!initialize	"initialize the state of the receiver"	super initialize.	phase := 1.	self extent: 200 @ 200.	ball := EllipseMorph new extent: 30 @ 30.	self		addMorph: ((star := StarMorph new extent: 150 @ 150) center: self center)! !!StarWithABallMorph methodsFor: 'stepping and presenter' stamp: 'kfr 10/26/2003 18:33'!step	phase := phase\\8 + 1.	phase = 1 ifTrue: [^ ball delete].	phase < 4 ifTrue:[^self].	phase = 4 ifTrue: [self addMorph: ball].	ball align: ball center with: (star vertices at: (phase-3*2)).! !!StickyPadMorph commentStamp: '<historical>' prior: 33924272!A colored sticker note: translucent, borderless Rectangles in a sequence of 6 colors.  StickyPadMorph minimics the stickyPad 			StickyPadMorph new openInWorld 	!!StickyPadMorph class methodsFor: 'initialization' stamp: 'PhilippeBack 8/8/2014 09:57'!initialize	"Class initialization"	LastColorIndex := 0.	Colors :=  {		Color r: 0.0 g: 0.0 b: 0.839 alpha: 0.267.		Color r: 0.484 g: 1.0 b: 0.452 alpha: 0.706.		Color r: 1.0 g: 0.355 b: 0.71 alpha: 0.569.		Color r: 1.0 g: 1.0 b: 0.03 alpha: 0.561.		Color r: 0.484 g: 0.161 b: 1.0 alpha: 0.529.		Color r: 0.097 g: 0.097 b: 0.097 alpha: 0.192.	}.		"self registerInFlapsRegistry.	""StickyPadMorph initialize"! !!StickyPadMorph methodsFor: 'visual properties' stamp: 'dgd 9/18/2004 18:52'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just 	colors. This method is for gradually converting old morphs."	^ true! !!StickyPadMorph methodsFor: 'parts bin' stamp: 'StephaneDucasse 2/27/2013 19:58'!initialize	"Initialize the receiver to stand alone.  Use the next color in the standard sequence."	Colors ifNil: [self class initialize].	LastColorIndex := 		LastColorIndex			ifNil:				[1]			ifNotNil:				[(LastColorIndex \\ Colors size) + 1].	super initialize.	self color: (Colors at: LastColorIndex).	self extent: 200@160.	self borderWidth: 0	! !!AtomMorph commentStamp: 'tbn 11/25/2004 09:06' prior: 33924497!AtomMorph represents an atom used in the simulation ofan ideal gas. It's container is typically a BouncingAtomsMorph.Try:	BouncingAtomsMorph  new openInWorldto open the gas simulation or:	AtomMorph exampleto open an instance in the current world!!AtomMorph class methodsFor: 'examples' stamp: 'StephaneDucasse 2/27/2013 21:19'!example	"AtomMorph example"	|a|	a := AtomMorph new openInWorld. 	a color: Color random. 	[1000 timesRepeat:  [a bounceIn: World bounds.  (Delay forMilliseconds: 50) wait]. 	 a delete] fork.! !!AtomMorph methodsFor: 'private' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p := self position.	vx := velocity x.		vy := velocity y.	px := p x + vx.		py := p y + vy.	bounced := false.	px > aRect right ifTrue: [		px := aRect right - (px - aRect right).		vx := velocity x negated.		bounced := true].	py > aRect bottom ifTrue: [		py :=  aRect bottom - (py - aRect bottom).		vy := velocity y negated.		bounced := true].	px < aRect left ifTrue: [		px := aRect left - (px - aRect left).		vx := velocity x negated.		bounced := true].	py < aRect top ifTrue: [		py :=  aRect top - (py - aRect top).		vy := velocity y negated.		bounced := true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue! !!AtomMorph methodsFor: 'drawing'!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect := false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!AtomMorph methodsFor: 'accessing'!infected	^ color = Color red! !!AtomMorph methodsFor: 'accessing'!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].! !!AtomMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:19'!initialize	"Make a new atom with a random position and velocity."	super initialize.	self extent: 8 @ 7.	self		randomPositionIn: (0 @ 0 corner: 300 @ 300)		maxVelocity: 10! !!AtomMorph methodsFor: 'initialization' stamp: 'RAA 12/15/2000 07:32'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin := aRectangle origin.	extent := (aRectangle extent - self bounds extent) rounded.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity :=		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!AtomMorph methodsFor: 'accessing'!velocity	^ velocity! !!AtomMorph methodsFor: 'accessing'!velocity: newVelocity	velocity := newVelocity.! !!Flasher commentStamp: 'StephaneDucasse 8/19/2009 22:56' prior: 33924822!A simple example - a circle that flashes.	Flasher new openInWorld The "onColor" instance variable indicates the color to use when "on",  A darker color is used to represent "off".The #step method, called every 500ms. by default, alternatively makes the flasher show its "on" and its "off" color.!!Flasher methodsFor: 'parts bin' stamp: 'sd 4/21/2002 09:36'!initializeToStandAlone	"Initialize the flasher."	super initializeToStandAlone.	self color: Color red.	self onColor: Color red. 	self borderWidth: 2.	self extent: 25@25! !!Flasher methodsFor: 'operations' stamp: 'sw 5/28/2002 18:44'!onColor	"Answer my onColor"	^ onColor ifNil: [onColor := Color red]! !!Flasher methodsFor: 'operations' stamp: 'sd 4/21/2002 09:55'!onColor: aColor	"Change my on color to be aColor"	onColor := aColor.	self color: aColor! !!Flasher methodsFor: 'stepping and presenter' stamp: 'sw 5/28/2002 18:45'!step	"Perform my standard periodic action"	super step.	self color = self onColor		ifTrue: [self color: (onColor alphaMixed: 0.5 with: Color black)]		ifFalse: [self color: onColor]! !!Flasher methodsFor: 'stepping and presenter' stamp: 'sw 4/17/2002 12:05'!stepTime	"Answer the desired time between steps, in milliseconds."	^ 500! !!MovingEyeMorph commentStamp: '<historical>' prior: 33925180!A MovingEyeMorph is a morph representing an eye whose iris is following the mouse cursor.	MovingEyeMorph new openInWorld!!MovingEyeMorph class methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:17'!initialize	"MovingEyeMorph initialize"	IrisSize := (0.42@0.50).! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:18'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!MovingEyeMorph methodsFor: 'geometry' stamp: 'yo 2/15/2001 15:59'!extent: aPoint	super extent: aPoint.	inner extent: (self extent * ((1.0@1.0)-IrisSize)) asIntegerPoint.	iris extent: (self extent * IrisSize) asIntegerPoint.	inner position: (self center - (inner extent // 2)) asIntegerPoint.! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:18'!initialize	"initialize the state of the receiver"		super initialize.	inner := EllipseMorph new.	inner color: self color.	inner extent: (self extent * (1.0 @ 1.0 - IrisSize)) asIntegerPoint.	inner borderColor: self color.	inner borderWidth: 0.	iris := EllipseMorph new.	iris color: Color white.	iris extent: (self extent * IrisSize) asIntegerPoint.	self addMorphCentered: inner.	inner addMorphCentered: iris.	self extent: 26 @ 33! !!MovingEyeMorph methodsFor: 'accessing' stamp: 'yo 2/15/2001 15:24'!irisPos: cp	| a b theta x y |	theta := (cp - self center) theta.	a := inner width // 2.	b := inner height // 2.	x := a * (theta cos).	y := b * (theta sin).	iris position: ((x@y) asIntegerPoint) + self center - (iris extent // 2).! !!MovingEyeMorph methodsFor: 'stepping and presenter' stamp: 'di 2/18/2001 00:10'!step	| cp |	cp := self globalPointToLocal: World primaryHand position.	(inner containsPoint: cp)		ifTrue: [iris position: (cp - (iris extent // 2))]		ifFalse: [self irisPos: cp].	self changed "cover up gribblies if embedded in Flash"! !!MovingEyeMorph methodsFor: 'testing' stamp: 'StephaneDucasse 2/27/2013 20:18'!stepTime	^ 100! !!WatchMorph commentStamp: '<historical>' prior: 33925355!This class is a representation of a watch.The labels' font is changeble. Labels' font size increase or decrease when resizing me.WatchMorph new openInWorld(WatchMorph fontName: 'ComicPlain' bgColor: Color transparent centerColor: Color transparent) openInWorld		" transparent "(WatchMorph fontName: 'ComicBold' bgColor: Color white centerColor: Color black) openInWorldStructure:	fontName		String -- the labels' font name	cColor			Color -- center color	handsColor		Color	romanNumerals	Boolean	antialias		Boolean!!WatchMorph class methodsFor: 'instance creation' stamp: 'di 5/16/2000 21:43'!fontName: aString bgColor: aColor centerColor: otherColor	^ self new		fontName: aString;		color: aColor;		centerColor: otherColor! !!WatchMorph methodsFor: 'menus' stamp: 'mara 7/17/2010 16:36'!addCustomMenuItems: aMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu addUpdating: #romanNumeralString action: #toggleRoman.	aMenu addUpdating: #antiAliasString action: #toggleAntialias.	aMenu addLine.	aMenu add: 'change font...' translated action: #changeFont.	aMenu balloonTextForLastItem: 'Allows you to change the font used to display the numbers.' translated.	aMenu balloonTextForLastItem: 'Allows you to specify a new color for the hands of the watch.  Note that actual *watch* color can be changed simply by using the halo''s recoloring handle.' translated.	aMenu balloonTextForLastItem: 'Allows you to specify a new color to be used during PM hours for the center portion of the watch; during AM hours, a lighter shade of the same color will be used.' translated.! !!WatchMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 22:25'!antiAliasString	^ (antialias		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'anti-aliasing' translated! !!WatchMorph methodsFor: 'accessing' stamp: 'bf 5/18/2000 11:06'!antialias: aBoolean	antialias := aBoolean! !!WatchMorph methodsFor: 'accessing' stamp: 'sw 7/4/2002 00:19'!centerColor: aColor	"Set the center color as indicated; map nil into transparent"	cColor := aColor ifNil: [Color transparent]! !!WatchMorph methodsFor: 'menus' stamp: 'alain.plantec 2/6/2009 17:47'!changeFont	| choice |	choice := UIManager default chooseFrom: StrikeFont familyNames values: StrikeFont familyNames.	choice ifNotNil: [self fontName: choice]! !!WatchMorph methodsFor: 'labels' stamp: 'di 5/16/2000 21:42'!createLabels	| numeral font h r |	self removeAllMorphs.	font := StrikeFont familyName: fontName size: (h := self height min: self width)//8.	r := 1.0 - (1.4 * font height / h).	1 to: 12 do:		[:hour |		numeral := romanNumerals			ifTrue: [#('I' 'II' 'III' 'IV' 'V' 'VI' 'VII' ' VIII' 'IX' 'X' 'XI' 'XII') at: hour]			ifFalse: [hour asString].		self addMorphBack: ((StringMorph contents: numeral font: font emphasis: 1)			center: (self radius: r hourAngle: hour)) lock].! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!defaultColor"answer the default color/fill style for the receiver"	^ Color green! !!WatchMorph methodsFor: 'drawing' stamp: 'sw 7/4/2002 00:22'!drawOn: aCanvas	"Draw the watch on the given canvas"	| pHour pMin pSec time centerColor |	time := Time now.	pHour := self radius: 0.6 hourAngle: time hours + (time minutes/60.0).	pMin := self radius: 0.72 hourAngle: (time minutes / 5.0).	pSec := self radius: 0.8 hourAngle: (time seconds / 5.0).	centerColor := cColor		ifNil:			[Color transparent]		ifNotNil:			[time hours < 12				ifTrue: [cColor muchLighter]				ifFalse: [cColor]].	antialias ifTrue:		[aCanvas asBalloonCanvas			aaLevel: 4;			drawOval: (bounds insetBy: borderWidth // 2 + 1) color: self fillStyle				borderWidth: borderWidth borderColor: borderColor;			drawOval: (bounds insetBy: self extent*0.35) color: centerColor				borderWidth: 0 borderColor: Color black;			drawPolygon: {self center. pHour}				color: Color transparent borderWidth: 3 borderColor: handsColor;			drawPolygon: {self center. pMin}				color: Color transparent borderWidth: 2 borderColor: handsColor;			drawPolygon: {self center. pSec}				color: Color transparent borderWidth: 1 borderColor: handsColor]		ifFalse:			[super drawOn: aCanvas.			aCanvas				fillOval: (bounds insetBy: self extent*0.35) color: centerColor;				line: self center to: pHour width: 3 color: handsColor;				line: self center to: pMin width: 2 color: handsColor;				line: self center to: pSec width: 1 color: handsColor]! !!WatchMorph methodsFor: 'geometry' stamp: 'di 5/16/2000 21:18'!extent: newExtent	super extent: newExtent.	self createLabels! !!WatchMorph methodsFor: 'accessing' stamp: 'di 5/16/2000 21:45'!fontName: aString	fontName := aString.	self createLabels! !!WatchMorph methodsFor: 'accessing' stamp: 'bf 9/25/2008 15:17'!handsColor: aColor	handsColor := aColor! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!initialize	"initialize the state of the receiver"	super initialize.	""	self handsColor: Color red.	self centerColor: Color gray.	romanNumerals := false.	antialias := false.	fontName := 'NewYork'.	self extent: 130 @ 130.	self start! !!WatchMorph methodsFor: 'private' stamp: 'di 5/16/2000 22:22'!radius: unitRadius hourAngle: hourAngle	"unitRadius goes from 0.0 at the center to 1.0 on the circumference.	hourAngle runs from 0.0 clockwise around to 12.0 with wrapping."	^ self center + (self extent * (Point r: 0.5 * unitRadius									degrees: hourAngle * 30.0 - 90.0)).! !!WatchMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 22:24'!romanNumeralString	"Answer a string governing the roman-numerals checkbox"	^ (romanNumerals		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'roman numerals' translated! !!WatchMorph methodsFor: 'stepping and presenter' stamp: 'bf 9/25/2008 15:17'!step	self changed.! !!WatchMorph methodsFor: 'menus' stamp: 'bf 5/17/2000 18:46'!toggleAntialias	antialias := antialias not! !!WatchMorph methodsFor: 'menus' stamp: 'di 5/16/2000 21:19'!toggleRoman	romanNumerals := romanNumerals not.	self createLabels! !"MorphExamplesAndDemos"!!ClipboardMorph commentStamp: 'StephaneDucasse 8/20/2009 16:02' prior: 0!A morph that always displays the current contents of the text clipboard.	ClipboardMorph new openInWorld!!StarMorph commentStamp: '<historical>' prior: 0!I am a very flexible star.	StarMorph new openInHandAdd my handles using cmd-shift + click and you can move and resize me.The up and down arrows increase or reduce the number of my sides.The right and left arrows cycle thru different amounts of  pointiness.Use the arrows right and left of my center or get stars with a specific amount of pointyness.  The left side goes from fat to thin and then cycles around again. The right goes from thin to fat. Hold down the shift key if you wish to stop the cycling at the extremes.Use the arrows up and down to change the number of sides if you would like a different number of points.To add or remove just one side hold the shift key down as you use the arrows or use the menu items for that purpose.If you add or remove just one point I will have an odd number of sides.  When that happens I can only look like a regular polygon. The right and left arrows will have no effect.  Add or remove just one more side and you can shift drag the outer handle or use the arrows to restore my pointiness. That was too complicated. It is gone. You can get regular polygon shapes by adjusting my pointiness. For example the extreme of a five pointed star is a dodecahedron (10 sided regular polygon) and one step less extreme is a pentagon (5 sided regular polygon).At some time you will probably shift drag the outer handle thru the center handle.While I looked round as you shrunk me, I will look very much like an asterisk as you pull me away.  What happens is that inside bend shrunk on the way down because it can never be larger than the outer point (or it wouldn't be the innerbend would it).But on the way out it is perfectly happy to remain small. So I look like an asterisk.To fatten me up  (if you haven't already figured this out by fooling around)  hold the shift down an move the outer handle towards the center (but not quite all the way) then let the shift up and move the outer handle away.  A couple of cycles like this and I'll be looking fat and jolly again. Or you can now just use the right arrow to make me fatter.This is also the reason I don't let the inside bend get larger than the outer point.If I did the same process that fattened me when I was an asterisk would also grow an asterisk so large squeak would complain about not having enough memory.Historical note:The former star had two bugs that are fixed here.The outer handle now no longer jumps from one point to another.The other bug prevented some higher order stars from looking right. Which is why the former star didn't allow you to change the number of points. !!AnimatedImageMorph commentStamp: 'StephaneDucasse 8/20/2009 10:40' prior: 0!I am an ImageMorph that can hold more than one image. Each image has its own delay time.If you have an animated gif close to the image named 	(AnimatedImageMorph fromGIFFileNamed: 'animated.gif') openInWorld !!ImageMorphWithSpotlight commentStamp: 'StephaneDucasse 8/19/2009 23:34' prior: 0!This class implements an image that appears one way or another depending upon whether it lies within a spotlight shape that moves with the cursor.  As delivered, the shape is a simple circle, the spotlighted appearance is that of a ColorForm, and the non-highlighted apperarance is a derived gray-scale form.	(ImageMorphWithSpotlight new image: (Form fromUser)) openInWorld 	The implementation will space-efficient if supplied with a ColorForm, because the gray-scale derived form will share the same bitmap.In general, any two images can be used -- one could be blurred, the other sharp -- and the masking form can be any shape.At some point this class should be merged somehow with ScreeningMorph.-- Note from Stephane Ducasse - August 2009: Does not seem to work with ColorForm!!ClockMorph commentStamp: 'StephaneDucasse 8/19/2009 22:54' prior: 0!A ClockMorph is oneline clock	ClockMorph new openInWorld 	ClockMorph new openInHand!!FrameRateMorph commentStamp: 'StephaneDucasse 8/19/2009 22:59' prior: 0!A little Morph to show the speed of frame rate of the system.	FrameRateMorph new openInWorld.	FrameRateMorph new openInHand.!!InfoStringMorph commentStamp: '<historical>' prior: 0!A generalization of the clock morphTry	InfoStringMorph new openInWorldor	(InfoStringMorph on: [Smalltalk vm parameterAt: 9])		stepTime: 50;		openInWorld!!BackgroundMorph commentStamp: 'StephaneDucasse 8/20/2009 15:52' prior: 0!This morph incorporates tiling and regular motion with the intent of supporting, eg, panning of endless (toroidal) backgrounds.The idea is that embedded morphs get displayed at a moving offset relative to my position.  Moreover this display is tiled according to the bounding box of the submorphs (subBounds), as much as necesary to fill the rest of my bounds.	(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser)) openInWorld!!BouncingAtomsMorph commentStamp: '<historical>' prior: 0!This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:BouncingAtomsMorph new openInWorld   1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!MagnifierMorph commentStamp: 'TestRunner 11/14/2009 16:57' prior: 0!MagnifierMorph instances are magnifying lenses that magnify the morphs below them (if grabbed or if trackPointer is false) or the area around the mouse pointer.	MagnifierMorph newShowingPointer openInWorld 		MagnifierMorph new openInWorld	Instance variables:magnification	<Number> The magnification to use. If non-integer, smooths the magnified form.trackPointer		<Boolean> If set, magnifies the area around the Hand. If not, magnfies the area underneath the magnifier center.showPointer		<Boolean> If set, display a small reversed rectangle in the center of the lens. Also enables the display of Morphs in the Hand itself.srcExtent		<Rectangle> The extent of the source rectangle.		Class variables:RecursionLock	<MagnifierMorph|nil> Used to avoid infinite recursion when getting the source patch to display.!!FishEyeMorph commentStamp: 'StephaneDucasse 8/19/2009 23:43' prior: 0!A FishEyeMorph is an extreme-wide-angle lens MagnifierMorph	FishEyeMorph new openInWorld!!RectangleMorph commentStamp: 'PhilippeBack 8/8/2014 10:19' prior: 0!A RectangleMorph is  a compatibility class to allow this package to load as it is now replaced by BorderedMorph since Pharo 3.0!!DoubleClickExample commentStamp: 'StephaneDucasse 8/19/2009 22:55' prior: 0!Illustrates the double-click capabilities of Morphic.DoubleClickExample new openInWorld 	If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #click: to react to single-clicked mouse-down.(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.(5)  Reimplement #drag: to react to non-clicks.  This message is sent continuously until the button is released.  You can check the event argument to react differently on the first, intermediate, and last calls.!!HeadingMorph commentStamp: 'StephaneDucasse 8/19/2009 23:00' prior: 0!A HeadingMorph displays an arrow on a grid as well as its decomposition on x and y axis.Clicking on it changes the direction of the main arrow.	HeadingMorph new openInWorld!!StarWithABallMorph commentStamp: '<historical>' prior: 0!This is a example of how to use a morph. It consists of only two methods, initialize and step.	StarWithABallMorph new openInWorld.!!StickyPadMorph commentStamp: '<historical>' prior: 0!A colored sticker note: translucent, borderless Rectangles in a sequence of 6 colors.  StickyPadMorph minimics the stickyPad 			StickyPadMorph new openInWorld 	!!AtomMorph commentStamp: 'tbn 11/25/2004 09:06' prior: 0!AtomMorph represents an atom used in the simulation ofan ideal gas. It's container is typically a BouncingAtomsMorph.Try:	BouncingAtomsMorph  new openInWorldto open the gas simulation or:	AtomMorph exampleto open an instance in the current world!!Flasher commentStamp: 'StephaneDucasse 8/19/2009 22:56' prior: 0!A simple example - a circle that flashes.	Flasher new openInWorld The "onColor" instance variable indicates the color to use when "on",  A darker color is used to represent "off".The #step method, called every 500ms. by default, alternatively makes the flasher show its "on" and its "off" color.!!MovingEyeMorph commentStamp: '<historical>' prior: 0!A MovingEyeMorph is a morph representing an eye whose iris is following the mouse cursor.	MovingEyeMorph new openInWorld!!WatchMorph commentStamp: '<historical>' prior: 0!This class is a representation of a watch.The labels' font is changeble. Labels' font size increase or decrease when resizing me.WatchMorph new openInWorld(WatchMorph fontName: 'ComicPlain' bgColor: Color transparent centerColor: Color transparent) openInWorld		" transparent "(WatchMorph fontName: 'ComicBold' bgColor: Color white centerColor: Color black) openInWorldStructure:	fontName		String -- the labels' font name	cColor			Color -- center color	handsColor		Color	romanNumerals	Boolean	antialias		Boolean!!ClipboardMorph commentStamp: 'StephaneDucasse 8/20/2009 16:02' prior: 34004940!A morph that always displays the current contents of the text clipboard.	ClipboardMorph new openInWorld!----STARTUP----2016-02-17T11:44:40.92206+01:00 as D:\Users\Cédric\Desktop\Pharo4.0\Pharo4.0.image!!ClipboardMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 8/20/2009 16:00'!defaultBorderColor	"answer the default border color/fill style for the receiver"		^ Color		r: 1.0		g: 0.355		b: 0.452! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:36'!defaultBorderWidth	"answer the default border width for the receiver"	^ 6! !!ClipboardMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:24'!defaultColor	"answer the default color/fill style for the receiver"	^ Color blue! !!ClipboardMorph methodsFor: 'parts bin' stamp: 'StephaneDucasse 8/20/2009 16:01'!initialize	super initialize.	self extent: 250 @ 200.	self		backgroundColor: (Color				r: 0.484				g: 1.0				b: 0.484).	self setBalloonText: 'This shows the current contents of the text clipboard'.	self newContents: Clipboard clipboardText! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 14:15'!step	self newContents: Clipboard clipboardText! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 14:18'!stepTime	"Answer the interval between steps -- in this case a leisurely 1 seconds"	^ 1000! !!ClipboardMorph methodsFor: 'stepping and presenter' stamp: 'sw 6/27/2001 13:40'!wantsSteps	^ true! !!StarMorph commentStamp: '<historical>' prior: 34005097!I am a very flexible star.	StarMorph new openInHandAdd my handles using cmd-shift + click and you can move and resize me.The up and down arrows increase or reduce the number of my sides.The right and left arrows cycle thru different amounts of  pointiness.Use the arrows right and left of my center or get stars with a specific amount of pointyness.  The left side goes from fat to thin and then cycles around again. The right goes from thin to fat. Hold down the shift key if you wish to stop the cycling at the extremes.Use the arrows up and down to change the number of sides if you would like a different number of points.To add or remove just one side hold the shift key down as you use the arrows or use the menu items for that purpose.If you add or remove just one point I will have an odd number of sides.  When that happens I can only look like a regular polygon. The right and left arrows will have no effect.  Add or remove just one more side and you can shift drag the outer handle or use the arrows to restore my pointiness. That was too complicated. It is gone. You can get regular polygon shapes by adjusting my pointiness. For example the extreme of a five pointed star is a dodecahedron (10 sided regular polygon) and one step less extreme is a pentagon (5 sided regular polygon).At some time you will probably shift drag the outer handle thru the center handle.While I looked round as you shrunk me, I will look very much like an asterisk as you pull me away.  What happens is that inside bend shrunk on the way down because it can never be larger than the outer point (or it wouldn't be the innerbend would it).But on the way out it is perfectly happy to remain small. So I look like an asterisk.To fatten me up  (if you haven't already figured this out by fooling around)  hold the shift down an move the outer handle towards the center (but not quite all the way) then let the shift up and move the outer handle away.  A couple of cycles like this and I'll be looking fat and jolly again. Or you can now just use the right arrow to make me fatter.This is also the reason I don't let the inside bend get larger than the outer point.If I did the same process that fattened me when I was an asterisk would also grow an asterisk so large squeak would complain about not having enough memory.Historical note:The former star had two bugs that are fixed here.The outer handle now no longer jumps from one point to another.The other bug prevented some higher order stars from looking right. Which is why the former star didn't allow you to change the number of points. !!StarMorph methodsFor: 'menu' stamp: 'wiz 9/5/2005 23:08'!addChangeSidesMenuItems: aCustomMenu hand: aHandMorph 	"Menu items to change number of sides."	aCustomMenu addLine.	aCustomMenu add: 'more sides' translated action: #moreVertices.	aCustomMenu add: 'fewer sides' translated action: #lessVertices."	Regular polygons can be simulated with the one of the skip stars 	and it would confuse users to have stars be limited to Regular polygons.	So we've removed those menu items - wiz""	aCustomMenu add: 'one more side' translated action: #oneMoreVertex.	aCustomMenu add: 'one fewer side' translated action: #oneLessVertex"! !!StarMorph methodsFor: 'menu' stamp: 'wiz 1/11/2005 14:55'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.self addChangeSidesMenuItems: aCustomMenu hand: aHandMorph.self addTwinkleMenuItems: aCustomMenu hand: aHandMorph.	! !!StarMorph methodsFor: 'editing' stamp: 'wiz 12/15/2004 00:59'!addHandles	self addStarHandles! !!StarMorph methodsFor: 'editing' stamp: 'StephaneDucasse 2/27/2013 20:08'!addStarHandles	"Outer handle must not be blocked so it comes first. 	The editing routine expects to find the center handle second.	The side and shape changing handles follow these."	| center |	self removeHandles.	"Check for old stars and correct order of vertices."	handles := OrderedCollection new.	center := vertices average rounded.	self 		withCenterOuterHandles; 		withUpDownLeftRightHandlesAround: 6 center: center.	self placeHandles.	self changed.	! !!StarMorph methodsFor: 'menu' stamp: 'wiz 1/11/2005 20:38'!addTwinkleMenuItems: aCustomMenu hand: aHandMorph 	"Menu items to change the sharpness of the star."	aCustomMenu addLine.	aCustomMenu add: 'twinkle fatter' translated action: #nextTwinkle.	aCustomMenu add: 'twinkle thinner' translated action: #prevTwinkle."	aCustomMenu add: 'fatter star' translated action: #nextFatter.	aCustomMenu add: 'thinner star' translated action: #prevThinner"		! !!StarMorph methodsFor: 'editing' stamp: 'wiz 9/5/2005 23:12'!changeVertices: label event: evt fromHandle: handle 	| |	label == #more		ifTrue: [evt shiftPressed				ifTrue: [self moreVertices "not oneMoreVertex"]				ifFalse: [self moreVertices]].	label == #less		ifTrue: [evt shiftPressed				ifTrue: [self lessVertices "not oneLessVertex"]				ifFalse: [self lessVertices]].	label == #next		ifTrue: [evt shiftPressed				ifTrue: [self makeVertices: vertices size starRatio: self nextSkip]				ifFalse: [self makeVertices: vertices size starRatio: self nextTwinkleSkip]].	label == #prev		ifTrue: [evt shiftPressed				ifTrue: [self makeVertices: vertices size starRatio: self prevSkip]				ifFalse: [self makeVertices: vertices size starRatio: self prevTwinkleSkip]].	self computeBounds! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:35'!defaultBorderColor	"answer the default border color/fill style for the receiver"	^ Color black! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:40'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:09'!defaultCenter	"answer the default center for the receiver"	^ 0@0! !!StarMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:31'!defaultColor	"answer the default color/fill style for the receiver"	^ Color lightBlue! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:09'!defaultFirstVertex	"answer the default first outer point for the receiver.	This with the center determines the angle and size of the outer radius."	^ 10@10! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:28'!defaultSides	"answer the default number of sides for the receiver"	^ 10! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:29'!defaultStarRatio	"answer the default ratio of outer radius to inner radius for the receiver"	^ 5.0 / 12.0! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/20/2005 19:07'!dragVertex: label event: evt fromHandle: handle 	| center r1 rN rNext a1 rTotal |	label == #outside		ifTrue: [center := handles second center.			r1 := center dist: vertices first.			"Rounding and what happens as the outer handle			approached the center, 			requires we guard the inner radius 			from becoming larger than the outer radius."			rN := r1						min: (center dist: vertices last).			rNext := 1						max: (center dist: evt cursorPoint).			a1 := 270.0						+ (center bearingToPoint: evt cursorPoint).			rTotal := vertices size even						ifTrue: [evt shiftPressed								ifTrue: [rNext + rNext min: rNext + rN]								ifFalse: [r1 + rN * rNext / r1]]						ifFalse: [rNext + rNext].			rNext := rTotal - rNext.			vertices := ((a1 to: a1 + 359.999 by: 360.0 / vertices size)						collect: [:angle | center								+ (Point r: (rNext := rTotal - rNext) degrees: angle)]) .			handle align: handle center with: evt cursorPoint].	label == #center		ifTrue: [evt shiftPressed				ifTrue: [self updateFormFromUser]				ifFalse: [self position: self position + (evt cursorPoint - handle center)]].	self computeBounds! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/11/2005 14:36'!initialize	"initialize the state of the receiver"	super initialize.	self		makeVertices: self defaultSides		starRatio: self defaultStarRatio		withCenter: self defaultCenter		withPoint: self defaultFirstVertex.	self computeBounds! !!StarMorph methodsFor: 'parts bin' stamp: 'sw 7/2/2001 11:07'!initializeToStandAlone	^ self initialize removeHandles! !!StarMorph methodsFor: 'menus' stamp: 'wiz 12/12/2004 16:43'!lessVertices"Reduce the number of points by one until we are  a diamond. If odd reduce the number of sides by two until we become a triangle. See class comment."	| nVerts |	( nVerts := 2 negated + vertices size) < 3 ifFalse: [	self		makeVertices: nVerts]! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:10'!makeVertices: nSides 	"Assuming vertices has at least one point, make a new star 	or regular polygon (for odd sided polygons).	The center of the polygon and the first vertex remain in	place. The inner distances for stars remain the same also if	possible."	| center r1 rN rNext a1 rTotal |	center := vertices average rounded.	r1 := center dist: vertices first.	rN := center dist: vertices last.	rNext := 1 max: r1.	a1 := 270.0 + (center bearingToPoint: vertices first).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed .	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'initialization' stamp: 'wiz 1/4/2005 19:31'!makeVertices: nSides starRatio: fraction	"Assuming vertices has at least one point, make a new star 	or regular polygon (for odd sided polygons).	The center of the polygon and the first vertex remain in	place. The inner distances for stars remain the same also if	possible."	| center r1 rN rNext a1 rTotal |	center := vertices average rounded.	r1 := center dist: vertices first.	rNext := 1 max: r1.	rN := (1.0 min: fraction) * rNext.	a1 := 270.0				+ (center bearingToPoint: vertices first).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed .	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:10'!makeVertices: nSides starRatio: fraction withCenter: center withPoint: aPoint 	"Make a new star or regular polygon (for odd sided polygons).	This makes star vertices from scratch without any feedback from existing vertices."	| r1 rN rNext a1 rTotal |	r1 := center dist: aPoint.	rNext := 1 max: r1.	rN := (1.0 min: fraction) * rNext.	a1 := 270.0 + (center bearingToPoint: aPoint).	rTotal := nSides even				ifTrue: [rNext + rNext min: rNext + rN]				ifFalse: [rNext + rNext].	rNext := rTotal - rNext.	self changed.	vertices := (a1 to: a1 + 359.999 by: 360.0 / nSides)				collect: [:angle | center						+ (Point r: (rNext := rTotal - rNext) degrees: angle)].	self computeBounds.	self changed! !!StarMorph methodsFor: 'menus' stamp: 'wiz 12/11/2004 16:45'!moreVertices	self makeVertices: 2+ vertices size! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!nextSkip	"Set starRatio to next skip wrapping if needed."	| skips n c r1 rN |	c := vertices average rounded.	r1 := (c dist: vertices first) truncated asFloat.	rN := c dist: vertices last.	skips := self skipRatios.	n := skips * r1 findFirst: [:r | r > (rN + 1.0)].	"n = 0		ifTrue: [n := skips size]."	^ skips atWrap: n! !!StarMorph methodsFor: 'menus' stamp: 'wiz 1/11/2005 20:37'!nextTwinkle	self makeVertices: vertices size starRatio: self nextTwinkleSkip .	self computeBounds.! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!nextTwinkleSkip	"Set starRatio to next skip wrapping if needed."	| skips n c r1 rN |	c := vertices average rounded.	r1 := (c dist: vertices first) truncated asFloat.	rN := c dist: vertices last.	skips := self skipRatios.	n := skips * r1 findFirst: [:r | r > (rN + 1.0)].	n = 0		ifTrue: [ n := 1].	^ skips atWrap: n! !!StarMorph methodsFor: 'menu' stamp: 'StephaneDucasse 2/27/2013 20:11'!oneLessVertex	self makeVertices: (3 max: 1 negated + vertices size)! !!StarMorph methodsFor: 'menu' stamp: 'wiz 12/11/2004 16:46'!oneMoreVertex	self makeVertices: 1 + vertices size! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/15/2005 00:19'!placeHandles	"Add the handles to my submorphs."	handles reverseDo: [:each | self addMorphFront: each ] .		! !!StarMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:10'!prevSkip	"Set starRatio to next skip wrapping if necessary"	| skips n c r1 rN |	c := vertices average rounded.	r1 := c dist: vertices first.	rN := (c dist: vertices last) truncated asFloat.	skips := self skipRatios.	n := skips * r1 findLast: [:r | r + 1.0 < rN].	n = 0		ifTrue: [n := 1].	^ skips at: n! !!StarMorph methodsFor: 'menus' stamp: 'wiz 1/11/2005 20:37'!prevTwinkle	self makeVertices: vertices size starRatio: self prevTwinkleSkip .	self computeBounds.! !!StarMorph methodsFor: 'geometry' stamp: 'wiz 1/19/2005 22:19'!prevTwinkleSkip	"Set starRatio to next skip wrapping if necessary"	| skips n c r1 rN |	c := vertices average rounded.	r1 := c dist: vertices first.	rN := (c dist: vertices last) truncated asFloat.	skips := self skipRatios.	n := skips * r1				findLast: [:r | r + 1.0 < rN].	"n = 0	ifTrue: [^ oldR]."	^ skips atWrap: n! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:07'!skipRatios	"Return an array of  ratios  of the inner radius to the outer radius.	Ratios are in ascending order from 0.0 to 1.0."	"Assume we have at least one vertex.	Always return a number <= 1.0"	| n  alpha  |	"Odd vertices sizes can not be stars only regular polygons"	n := vertices size . n odd ifTrue: [ ^ #(  1.0) ] .	alpha := Float pi / (n//2)  asFloat .	^ ((((Float halfPi -alpha  to: alpha /2.0  by: alpha  negated ) 			collect:  [:angle | angle sin /	(angle + alpha ) sin ]		) copyWith: 0.0) copyWithFirst: 1.0) reversed.! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:06'!starRatio	"Return the ratio of the inner radius to the outer radius."	"Assume we have at least one vertex.	Always returns a number <= 1.0"		| r c |	c := vertices average rounded.	r := (c dist: vertices last) / (c dist:  vertices first).	^ r > 1.0  ifTrue: [  r reciprocal ] ifFalse: [r ].! !!StarMorph methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 20:08'!starRatio: r	"Set the star s.t. the ratio of the inner radius to the outer radius is r.	If r is > 1 use the reciprocal to keep the outer radius first."	"Assume we have at least one vertex.All ways return a number <= 1.0"	self 		makeVertices: vertices size 		starRatio: ( r > 1.0  ifTrue: [ r reciprocal ] ifFalse: [r ] ).! !!StarMorph methodsFor: 'menus' stamp: 'StephaneDucasse 2/27/2013 20:16'!updateFormFromUser	"Does nothing here. Overridden in subclasses e.g. Kaleidoscope."	^ self.! !!StarMorph methodsFor: 'editing' stamp: 'di 9/26/97 11:11'!updateHandles! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/11/2005 19:39'!withCenterOuterHandles	"Add to our handles the center positioning and outer resizing	handles. Outer handle must not be blocked so it comes first. 	The editing routine expects to find the center handle second.	The side and shape changing handles follow these."	| center v1 hExtent holder |	center := vertices average rounded.	hExtent := 8 @ 8.	v1 := vertices first.	holder := {(EllipseMorph				newBounds: (Rectangle center: v1 extent: hExtent)				color: Color yellow)				setBalloonText: 'Move me to adjust size. Shift move to adjust pointiness'. (EllipseMorph				newBounds: (Rectangle center: center extent: hExtent)				color: Color yellow)				setBalloonText: 'Move me to adjust position'}.	holder		with: {#outside. #center}		do: [:handle :which | handle				on: #mouseDown				send: #dragVertex:event:fromHandle:				to: self				withValue: which;								on: #mouseMove				send: #dragVertex:event:fromHandle:				to: self				withValue: which].	handles addAll: holder! !!StarMorph methodsFor: 'editing' stamp: 'wiz 1/11/2005 19:47'!withUpDownLeftRightHandlesAround: radius center: center	"Add to our handles the side and shape changing handles."	| tri  above holder  triAbove triBelow triRight triLeft |	above := 0 @ radius negated.		tri := Array				with: 0 @ -5				with: 4 @ 3				with: -4 @ 3.	triAbove := tri + (center + above).	triBelow := triAbove				collect: [:pt | pt rotateBy: #pi centerAt: center].	triRight := triAbove				collect: [:pt | pt rotateBy: #right centerAt: center].	triLeft := triAbove				collect: [:pt | pt rotateBy: #left centerAt: center].					holder := { (PolygonMorph				vertices: triAbove				color: Color green				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'More points.'. 								(PolygonMorph				vertices: triBelow				color: Color magenta				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Fewer points.'. 								(PolygonMorph				vertices: triRight				color: Color green				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Twinkle fatter.'. 								(PolygonMorph				vertices: triLeft				color: Color magenta				borderWidth: 1				borderColor: Color black)				 setBalloonText: 'Twinkle thinner.'}.		holder		with: {#more. #less. #next. #prev}		do: [:handle :which | handle				on: #mouseDown				send: #changeVertices:event:fromHandle:				to: self				withValue: which;								on: #mouseMove				send: #changeVertices:event:fromHandle:				to: self				withValue: which].	^ handles addAll: holder! !!AnimatedImageMorph commentStamp: 'StephaneDucasse 8/20/2009 10:40' prior: 34007794!I am an ImageMorph that can hold more than one image. Each image has its own delay time.If you have an animated gif close to the image named 	(AnimatedImageMorph fromGIFFileNamed: 'animated.gif') openInWorld !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'nk 6/12/2004 13:11'!fileReaderServicesForFile: fullName suffix: suffix	^((AnimatedGIFReadWriter typicalFileExtensions asSet		add: '*'; add: 'form'; yourself)		includes: suffix)		ifTrue: [ self services ]		ifFalse: [#()]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:23'!fromGIFFileNamed: fileName	| reader |	reader := AnimatedGIFReadWriter formsFromFileNamed: fileName.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 15:27'!fromStream: aStream	| reader |	reader := AnimatedGIFReadWriter formsFromStream: aStream.	^reader forms size = 1		ifTrue: [ ImageMorph new image: reader forms first ]		ifFalse: [ self new fromReader: reader ]! !!AnimatedImageMorph class methodsFor: 'initialization' stamp: 'asm 12/11/2003 21:05'!initialize	"register the receiver in the global registries"	self environment		at: #FileList		ifPresent: [:cl | cl registerFileReader: self]! !!AnimatedImageMorph class methodsFor: 'instance creation' stamp: 'nk 2/15/2004 16:57'!openGIFInWindow: aStream	^(self fromStream: aStream binary) openInWorld! !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'dgd 4/3/2006 13:36'!serviceOpenGIFInWindow	"Answer a service for opening a gif graphic in a window"	^ (SimpleServiceEntry		provider: self		label: 'open the graphic as a morph'		selector: #openGIFInWindow:		description: 'open a GIF graphic file as a morph'		buttonLabel: 'open')		argumentGetter: [:fileList | fileList readOnlyStream]! !!AnimatedImageMorph class methodsFor: 'filein/out' stamp: 'dgd 4/3/2006 13:36'!services	^ Array		with: self serviceOpenGIFInWindow		"with: Form serviceImageImports"		with: Form serviceImageAsBackground! !!AnimatedImageMorph class methodsFor: 'initialization' stamp: 'asm 12/11/2003 21:01'!unload	"Unload the receiver from global registries"	self environment		at: #FileList		ifPresent: [:cl | cl unregisterFileReader: self]! !!AnimatedImageMorph methodsFor: 'private' stamp: 'nk 2/15/2004 15:20'!fromGIFFileNamed: fileName	self fromReader: (AnimatedGIFReadWriter formsFromFileNamed: fileName)! !!AnimatedImageMorph methodsFor: 'private' stamp: 'bf 2/25/2005 11:18'!fromReader: reader	images := reader forms.	delays := reader delays.	imageIndex := 0.	self image: (Form extent: images first extent depth: 32).	self step! !!AnimatedImageMorph methodsFor: 'private' stamp: 'nk 2/15/2004 15:20'!fromStream: aStream	self fromReader: (AnimatedGIFReadWriter formsFromStream: aStream)! !!AnimatedImageMorph methodsFor: 'private' stamp: 'mir 11/19/2003 13:42'!images	^images! !!AnimatedImageMorph methodsFor: 'private' stamp: 'bf 2/25/2005 11:09'!initialize	nextTime := Time millisecondClockValue.	imageIndex := 1.	stepTime := 10.	super initialize! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'marcus.denker 9/14/2008 19:13'!step	| d |	images isEmpty ifTrue: [^ self].			nextTime > Time millisecondClockValue ifTrue: [^self].	self changed.	self image: (images at: (imageIndex := imageIndex \\ images size + 1)).	self changed . 	d := (delays at: imageIndex) ifNil: [0].	nextTime := Time millisecondClockValue + d! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'mir 11/19/2003 13:40'!stepTime	^stepTime ifNil: [super stepTime]! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'mir 11/19/2003 13:40'!stepTime: anInteger	stepTime := anInteger! !!AnimatedImageMorph methodsFor: 'stepping and presenter' stamp: 'StephaneDucasse 2/27/2013 21:20'!wantsSteps	^ images size > 1! !!ImageMorphWithSpotlight commentStamp: 'StephaneDucasse 8/19/2009 23:34' prior: 34008091!This class implements an image that appears one way or another depending upon whether it lies within a spotlight shape that moves with the cursor.  As delivered, the shape is a simple circle, the spotlighted appearance is that of a ColorForm, and the non-highlighted apperarance is a derived gray-scale form.	(ImageMorphWithSpotlight new image: (Form fromUser)) openInWorld 	The implementation will space-efficient if supplied with a ColorForm, because the gray-scale derived form will share the same bitmap.In general, any two images can be used -- one could be blurred, the other sharp -- and the masking form can be any shape.At some point this class should be merged somehow with ScreeningMorph.-- Note from Stephane Ducasse - August 2009: Does not seem to work with ColorForm!!ImageMorphWithSpotlight class methodsFor: 'example' stamp: 'StephaneDucasse 8/19/2009 23:05'!example1	"self example1"		(self new image: (Form fromUser)) openInWorld! !!ImageMorphWithSpotlight methodsFor: 'accessing' stamp: 'di 5/26/1999 07:51'!backgroundImage: bkgndImage spotImage: anImage spotShape: formOfDepth1	"See class comment."	spotImage := anImage.	spotShape := formOfDepth1.	spotBuffer := Form extent: spotShape extent depth: spotImage depth.	super image: bkgndImage.	spotOn := false.! !!ImageMorphWithSpotlight methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.	spotOn ifTrue:		[aCanvas paintImage: spotBuffer at: spotBuffer offset].! !!ImageMorphWithSpotlight methodsFor: 'accessing' stamp: 'di 5/26/1999 08:05'!image: anImage	"The spotlight will reveal the original  form supplied	while the background form will be derived grayscale."	"See class comment."	self backgroundImage: anImage asGrayScale		spotImage: anImage		spotShape: (Form dotOfSize: 100)! !!ImageMorphWithSpotlight methodsFor: 'drawing' stamp: 'di 5/24/1999 22:37'!spotChanged	self invalidRect:		((spotBuffer offset extent: spotBuffer extent) "intersect: self bounds")! !!ImageMorphWithSpotlight methodsFor: 'stepping and presenter' stamp: 'ar 5/28/2000 12:09'!step	| cp |	((self bounds expandBy: spotBuffer extent // 2) containsPoint: (cp := self cursorPoint))		ifTrue:		[(cp - (spotBuffer extent // 2)) = spotBuffer offset ifTrue: [^ self].  "No change"		"Cursor has moved where its spotShape is visible"		spotOn := true.		self spotChanged.		spotBuffer offset: cp - (spotBuffer extent // 2).		self spotChanged.		(BitBlt current toForm: spotBuffer)			"clear the buffer"			fill: spotBuffer boundingBox fillColor: (Bitmap with: 0) rule: Form over;			"Clip anything outside the base form"			clipRect: (spotBuffer boundingBox				intersect: (self bounds translateBy: spotBuffer offset negated));			"Fill the spotBuffer with the spot image"			copyForm: spotImage to: self position - spotBuffer offset rule: Form over;			"Mask everything outside the spot shape to 0 (transparent)."			copyForm: spotShape to: spotShape offset negated rule: Form and				colorMap: (Bitmap with: 0 with: 16rFFFFFFFF)]		ifFalse:		[spotOn ifTrue: [self spotChanged. spotOn := false]]! !!ImageMorphWithSpotlight methodsFor: 'stepping and presenter' stamp: 'di 5/24/1999 21:43'!stepTime	^ 20! !!ClockMorph commentStamp: 'StephaneDucasse 8/19/2009 22:54' prior: 34008954!A ClockMorph is oneline clock	ClockMorph new openInWorld 	ClockMorph new openInHand!!ClockMorph methodsFor: 'menu' stamp: 'stephane.ducasse 2/14/2009 17:36'!addCustomMenuItems: aCustomMenu hand: aHandMorph	"Note minor loose end here -- if the menu is persistent, then the wording will be wrong half the time"	| item |	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	item := showSeconds 		ifTrue:	['stop showing seconds']		ifFalse: ['start showing seconds'].	aCustomMenu add: item translated target: self action: #toggleShowingSeconds.	item := show24hr		ifTrue: ['display Am/Pm']		ifFalse: ['display 24 hour'].	aCustomMenu add: item translated target: self action: #toggleShowing24hr.			! !!ClockMorph methodsFor: 'initialization' stamp: 'stephane.ducasse 2/14/2009 17:37'!initialize	"initialize the state of the receiver"		super initialize.	showSeconds := true.	show24hr := false.	self step! !!ClockMorph methodsFor: 'parts bin' stamp: 'sw 7/12/2001 17:41'!initializeToStandAlone	super initializeToStandAlone.	showSeconds := true.	self step! !!ClockMorph methodsFor: '24hr' stamp: 'fc 2/8/2004 11:38'!show24hr: aBoolean	show24hr := aBoolean! !!ClockMorph methodsFor: 'seconds' stamp: 'sw 2/17/1999 14:39'!showSeconds: aBoolean	showSeconds := aBoolean! !!ClockMorph methodsFor: 'stepping and presenter' stamp: 'stephane.ducasse 2/14/2009 17:37'!step	| time |	super step.	time := String streamContents:		[:aStrm | Time now print24: show24hr  showSeconds: showSeconds on: aStrm].	self contents: time			! !!ClockMorph methodsFor: 'testing'!stepTime	"Answer the desired time between steps in milliseconds."	^ 1000! !!ClockMorph methodsFor: '24hr' stamp: 'stephane.ducasse 2/14/2009 17:37'!toggleShowing24hr	show24hr := show24hr not! !!ClockMorph methodsFor: 'seconds' stamp: 'stephane.ducasse 2/14/2009 17:37'!toggleShowingSeconds	showSeconds := showSeconds not! !!FrameRateMorph commentStamp: 'StephaneDucasse 8/19/2009 22:59' prior: 34009116!A little Morph to show the speed of frame rate of the system.	FrameRateMorph new openInWorld.	FrameRateMorph new openInHand.!!FrameRateMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:11'!initialize	"initialize the state of the receiver"	super initialize.	lastDisplayTime := 0.	framesSinceLastDisplay := 0! !!FrameRateMorph methodsFor: 'parts bin' stamp: 'sw 7/19/2001 13:39'!initializeToStandAlone	"Initialize the receiver as a stand-alone entity"	super initializeToStandAlone.	self color: Color blue.	self step! !!FrameRateMorph methodsFor: 'stepping and presenter' stamp: 'sw 10/5/2000 06:52'!step	"Compute and display (every half second or so) the current framerate"	| now mSecs mSecsPerFrame framesPerSec newContents |	framesSinceLastDisplay := framesSinceLastDisplay + 1.	now := Time millisecondClockValue.	mSecs := now - lastDisplayTime.	(mSecs > 500 or: [mSecs < 0 "clock wrap-around"]) ifTrue: 		[mSecsPerFrame := mSecs // framesSinceLastDisplay.		framesPerSec := (framesSinceLastDisplay * 1000) // mSecs.		newContents := mSecsPerFrame printString, ' mSecs (', framesPerSec printString, ' frame', (framesPerSec == 1 ifTrue: [''] ifFalse: ['s']), '/sec)'.		self contents: newContents.		lastDisplayTime := now.		framesSinceLastDisplay := 0]! !!FrameRateMorph methodsFor: 'testing' stamp: 'jm 2/23/98 18:41'!stepTime	"Answer the desired time between steps in milliseconds."	^ 0! !!InfoStringMorph commentStamp: '<historical>' prior: 34009303!A generalization of the clock morphTry	InfoStringMorph new openInWorldor	(InfoStringMorph on: [Smalltalk vm parameterAt: 9])		stepTime: 50;		openInWorld!!InfoStringMorph class methodsFor: 'instance creation' stamp: 'sma 6/1/2000 14:07'!on: aBlock	^ self new block: aBlock! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:06'!block	^ block! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:05'!block: aBlock	block := aBlock! !!InfoStringMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:28'!initialize	"initialize the state of the receiver"	super initialize.	stepTime := 1000.	block := [Time now]! !!InfoStringMorph methodsFor: 'stepping and presenter' stamp: 'sma 6/1/2000 14:03'!step	self contents: block value asString! !!InfoStringMorph methodsFor: 'testing' stamp: 'sma 6/1/2000 14:03'!stepTime	^ stepTime! !!InfoStringMorph methodsFor: 'accessing' stamp: 'sma 6/1/2000 14:06'!stepTime: anInteger	stepTime := anInteger! !!BackgroundMorph commentStamp: 'StephaneDucasse 8/20/2009 15:52' prior: 34009539!This morph incorporates tiling and regular motion with the intent of supporting, eg, panning of endless (toroidal) backgrounds.The idea is that embedded morphs get displayed at a moving offset relative to my position.  Moreover this display is tiled according to the bounding box of the submorphs (subBounds), as much as necesary to fill the rest of my bounds.	(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser)) openInWorld!!BackgroundMorph class methodsFor: 'as yet unclassified' stamp: 'kfr 8/7/2004 16:10'!test	"BackgroundMorph test"	^(BackgroundMorph new addMorph: (ImageMorph new image: Form fromUser))openInWorld.! !!BackgroundMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 20:56'!addCustomMenuItems: aCustomMenu hand: aHandMorph 	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	running		ifTrue: [aCustomMenu add: 'stop' translated action: #stopRunning]		ifFalse: [aCustomMenu add: 'start' translated action: #startRunning]! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 12:23'!delta	^delta! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 12:24'!delta: aPoint	delta := aPoint.! !!BackgroundMorph methodsFor: 'drawing' stamp: 'ar 6/17/1999 01:06'!drawOn: aCanvas	"The tiling is solely determined by bounds, subBounds and offset.	The extent of display is determined by bounds and the clipRect of the canvas."	| start d subBnds |	submorphs isEmpty ifTrue: [^ super drawOn: aCanvas].	subBnds := self subBounds.	running ifFalse:		[super drawOn: aCanvas.		^ aCanvas fillRectangle: subBnds color: Color lightBlue].	start := subBnds topLeft + offset - bounds topLeft - (1@1) \\ subBnds extent - subBnds extent + (1@1).	d := subBnds topLeft - bounds topLeft."Sensor redButtonPressed ifTrue: [self halt]."	start x to: bounds width - 1 by: subBnds width do:		[:x |		start y to: bounds height - 1 by: subBnds height do:			[:y | aCanvas translateBy: (x@y) - d clippingTo: bounds				during:[:tileCanvas| self drawSubmorphsOn: tileCanvas]]].! !!BackgroundMorph methodsFor: 'layout'!fullBounds	^ self bounds! !!BackgroundMorph methodsFor: 'drawing' stamp: 'ar 12/30/2001 19:16'!fullDrawOn: aCanvas	(aCanvas isVisible: self fullBounds) ifFalse:[^self].	running ifFalse: [		^aCanvas clipBy: (bounds translateBy: aCanvas origin)				during:[:clippedCanvas| super fullDrawOn: clippedCanvas]].	(aCanvas isVisible: self bounds) ifTrue:[aCanvas drawMorph: self].! !!BackgroundMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:18'!initialize	"initialize the state of the receiver"	super initialize.	offset := 0 @ 0.	delta := 1 @ 0.	running := true! !!BackgroundMorph methodsFor: 'layout'!layoutChanged	"Do nothing, since I clip my submorphs"! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:50'!offset	^offset! !!BackgroundMorph methodsFor: 'accessing' stamp: 'fc 7/24/2004 13:50'!offset: aPoint	offset := aPoint! !!BackgroundMorph methodsFor: 'accessing'!slideBy: inc	submorphs isEmpty ifTrue: [^ self].	offset := offset + inc \\ self subBounds extent.	self changed! !!BackgroundMorph methodsFor: 'accessing'!startRunning	running := true.	self changed! !!BackgroundMorph methodsFor: 'stepping and presenter' stamp: 'fc 7/24/2004 13:47'!step		running ifTrue: [self slideBy: delta]! !!BackgroundMorph methodsFor: 'testing'!stepTime	"Answer the desired time between steps in milliseconds."	^ 20! !!BackgroundMorph methodsFor: 'accessing'!stopRunning	running := false.	self changed! !!BackgroundMorph methodsFor: 'accessing' stamp: 'aoy 2/17/2003 01:20'!subBounds	"calculate the submorph bounds"	| subBounds |	subBounds := nil.	self submorphsDo: 			[:m | 			subBounds := subBounds isNil						ifTrue: [m fullBounds]						ifFalse: [subBounds merge: m fullBounds]].	^subBounds! !!BouncingAtomsMorph commentStamp: '<historical>' prior: 34010046!This morph shows how an ideal gas simulation might work. When it gets step messages, it makes all its atom submorphs move along their velocity vectors, bouncing when they hit a wall. It also exercises the Morphic damage reporting and display architecture. Here are some things to try:BouncingAtomsMorph new openInWorld   1. Resize this morph as the atoms bounce around.  2. In an inspector on this morph, evaluate "self addAtoms: 10."  3. Try setting quickRedraw to false in invalidRect:. This gives the     default damage reporting and incremental redraw. Try it for     100 atoms.  4. In the drawOn: method of AtomMorph, change drawAsRect to true.  5. Create a HeaterCoolerMorph and embed it in the simulation. Extract	it and use an inspector on it to evaluate "self velocityDelta: -5", then     re-embed it. Note the effect on atoms passing over it.!!BouncingAtomsMorph class methodsFor: 'parts bin' stamp: 'sw 8/2/2001 01:21'!descriptionForPartsBin	^ self partName:	'BouncingAtoms'		categories:		#('Demo')		documentation:	'The original, intensively-optimized bouncing-atoms simulation by John Maloney'! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:57'!initialize	self registerInFlapsRegistry.	! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/10/2003 12:58'!registerInFlapsRegistry	"Register the receiver in the system's flaps registry"	self environment		at: #Flaps		ifPresent: [:cl | cl registerQuad: #(BouncingAtomsMorph	new	'Bouncing Atoms'	'Atoms, mate')						forFlapNamed: 'Widgets']! !!BouncingAtomsMorph class methodsFor: 'initialization' stamp: 'asm 4/11/2003 12:32'!unload	"Unload the receiver from global registries"	self environment at: #Flaps ifPresent: [:cl |	cl unregisterQuadsWithReceiver: self] ! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:10'!addAtoms: n	"Add a bunch of new atoms."	| a |	n timesRepeat: [		a := AtomMorph new.		a randomPositionIn: bounds maxVelocity: 10.		self addMorph: a].	self stopStepping.! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:15'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu add: 'startInfection' translated action: #startInfection.	aCustomMenu add: 'set atom count' translated action: #setAtomCount.	aCustomMenu add: 'show infection history' translated action: #showInfectionHistory:.! !!BouncingAtomsMorph methodsFor: 'submorphs-add/remove'!addMorphFront: aMorph	"Called by the 'embed' meta action. We want non-atoms to go to the back."	"Note: A user would not be expected to write this method. However, a sufficiently advanced user (e.g, an e-toy author) might do something equivalent by overridding the drag-n-drop messages when they are implemented."	(aMorph isMemberOf: AtomMorph)		ifTrue: [super addMorphFront: aMorph]		ifFalse: [super addMorphBack: aMorph].! !!BouncingAtomsMorph methodsFor: 'drawing' stamp: 'di 1/4/1999 20:22'!areasRemainingToFill: aRectangle	color isTranslucent		ifTrue: [^ Array with: aRectangle]		ifFalse: [^ aRectangle areasOutside: self bounds]! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'aoy 2/15/2003 21:38'!collisionPairs	"Return a list of pairs of colliding atoms, which are assumed to becircles of known radius. This version uses the morph's positions--i.e.the top-left of their bounds rectangles--rather than their centers."	| count sortedAtoms radius twoRadii radiiSquared collisions p1 continue j p2 distSquared m1 m2 |	count := submorphs size.	sortedAtoms := submorphs 				asSortedCollection: [:mt1 :mt2 | mt1 position x < mt2 position x].	radius := 8.	twoRadii := 2 * radius.	radiiSquared := radius squared * 2.	collisions := OrderedCollection new.	1 to: count - 1		do: 			[:i | 			m1 := sortedAtoms at: i.			p1 := m1 position.			continue := (j := i + 1) <= count.			[continue] whileTrue: 					[m2 := sortedAtoms at: j.					p2 := m2 position.					continue := p2 x - p1 x <= twoRadii  								ifTrue: 									[distSquared := (p1 x - p2 x) squared + (p1 y - p2 y) squared.									distSquared < radiiSquared 										ifTrue: [collisions add: (Array with: m1 with: m2)].									(j := j + 1) <= count]								ifFalse: [false]]].	^collisions! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:14'!defaultColor"answer the default color/fill style for the receiver"	^ Color		r: 0.8		g: 1.0		b: 0.8! !!BouncingAtomsMorph methodsFor: 'drawing'!drawOn: aCanvas	"Clear the damageReported flag when redrawn."	super drawOn: aCanvas.	damageReported := false.! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:17'!initialize	"initialize the state of the receiver"	super initialize.	damageReported := false.	self extent: 400 @ 250.	infectionHistory := OrderedCollection new.	transmitInfection := false.	self addAtoms: 30! !!BouncingAtomsMorph methodsFor: 'initialization' stamp: 'ar 8/13/2003 11:41'!intoWorld: aWorld	"Make sure report damage at least once"	damageReported := false.	super intoWorld: aWorld.! !!BouncingAtomsMorph methodsFor: 'change reporting' stamp: 'ar 11/12/2000 18:42'!invalidRect: damageRect from: aMorph	"Try setting 'quickRedraw' to true. This invalidates the entire morph, whose bounds typically subsume all it's submorphs. (However, this code checks that assumption and passes through any damage reports for out-of-bounds submorphs. Note that atoms with super-high velocities do occaisionally shoot through the walls!!) An additional optimization is to only submit only damage report per display cycle by using the damageReported flag, which is reset to false when the morph is drawn."	| quickRedraw |	quickRedraw := true.  "false gives the original invalidRect: behavior"	(quickRedraw and:	 [(bounds origin <= damageRect topLeft) and:	 [damageRect bottomRight <= bounds corner]]) ifTrue: [		"can use quick redraw if damage is within my bounds"		damageReported ifFalse: [super invalidRect: bounds from: self].  "just report once"		damageReported := true.	] ifFalse: [super invalidRect: damageRect from: aMorph].  "ordinary damage report"! !!BouncingAtomsMorph methodsFor: 'menu' stamp: 'DamienCassou 9/29/2009 09:03'!setAtomCount	| countString count |	countString := UIManager default		request: 'Number of atoms?' translated		initialAnswer: self submorphCount printString.	countString isEmptyOrNil ifTrue: [^ self].	count := Integer readFrom: (ReadStream on: countString).	self removeAllMorphs.	self addAtoms: count.! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:31'!showInfectionHistory: evt	"Place a graph of the infection history in the world."	| graph |	infectionHistory isEmpty ifTrue: [^ self].	graph := GraphMorph new data: infectionHistory.	graph extent: ((infectionHistory size + (2 * graph borderWidth) + 5)@(infectionHistory last max: 50)).	evt hand attachMorph: graph.! !!BouncingAtomsMorph methodsFor: 'menu'!startInfection	self submorphsDo: [:m | m infected: false].	self firstSubmorph infected: true.	infectionHistory := OrderedCollection new: 500.	transmitInfection := true.	self startStepping.! !!BouncingAtomsMorph methodsFor: 'stepping and presenter' stamp: 'sw 7/15/1999 07:32'!step	"Bounce those atoms!!"	| r bounces |	super step.	bounces := 0.	r := bounds origin corner: (bounds corner - (8@8)).	self submorphsDo: [ :m |		(m isMemberOf: AtomMorph) ifTrue: [			(m bounceIn: r) ifTrue: [bounces := bounces + 1]]].	"compute a 'temperature' that is proportional to the number of bounces	 divided by the circumference of the enclosing rectangle"	self updateTemperature: (10000.0 * bounces) / (r width + r height).	transmitInfection ifTrue: [self transmitInfection].! !!BouncingAtomsMorph methodsFor: 'testing' stamp: 'jm 6/28/1998 18:10'!stepTime	"As fast as possible."	^ 0! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'jm 6/28/1998 18:20'!transmitInfection	| infected count |	self collisionPairs do: [:pair |		infected := false.		pair do: [:atom | atom infected ifTrue: [infected := true]].		infected			ifTrue: [pair do: [:atom | atom infected: true]]].	count := 0.	self submorphsDo: [:m | m infected ifTrue: [count := count + 1]].	infectionHistory addLast: count.	count = submorphs size ifTrue: [		transmitInfection := false.		self stopStepping].! !!BouncingAtomsMorph methodsFor: 'other' stamp: 'dgd 2/22/2003 13:36'!updateTemperature: currentTemperature 	"Record the current temperature, which is taken to be the number of atoms that have bounced in the last cycle. To avoid too much jitter in the reading, the last several readings are averaged."	recentTemperatures isNil 		ifTrue: 			[recentTemperatures := OrderedCollection new.			20 timesRepeat: [recentTemperatures add: 0]].	recentTemperatures removeLast.	recentTemperatures addFirst: currentTemperature.	temperature := recentTemperatures sum asFloat / recentTemperatures size! !!MagnifierMorph commentStamp: 'TestRunner 11/14/2009 16:57' prior: 34010983!MagnifierMorph instances are magnifying lenses that magnify the morphs below them (if grabbed or if trackPointer is false) or the area around the mouse pointer.	MagnifierMorph newShowingPointer openInWorld 		MagnifierMorph new openInWorld	Instance variables:magnification	<Number> The magnification to use. If non-integer, smooths the magnified form.trackPointer		<Boolean> If set, magnifies the area around the Hand. If not, magnfies the area underneath the magnifier center.showPointer		<Boolean> If set, display a small reversed rectangle in the center of the lens. Also enables the display of Morphs in the Hand itself.srcExtent		<Rectangle> The extent of the source rectangle.		Class variables:RecursionLock	<MagnifierMorph|nil> Used to avoid infinite recursion when getting the source patch to display.!!FishEyeMorph commentStamp: 'StephaneDucasse 8/19/2009 23:43' prior: 34011883!A FishEyeMorph is an extreme-wide-angle lens MagnifierMorph	FishEyeMorph new openInWorld!!FishEyeMorph methodsFor: 'initialization' stamp: 'yo 12/17/1999 12:00'!calculateTransform	| stepX stepY rect tx ty arrayX arrayY |	(gridNum x = 0 or: [gridNum y = 0]) ifTrue: [^self].	stepX := srcExtent x // gridNum x.	stepY := srcExtent y // gridNum y.	arrayX := (1 to: gridNum y + 1) collect: [:j | FloatArray new: gridNum x + 1].	arrayY := (1 to: gridNum y + 1) collect: [:j |  FloatArray new: gridNum x + 1].	0 to: gridNum y do: [:j |		0 to: gridNum x do: [:i |			(arrayX at: (j + 1)) at: (i + 1) put: i*stepX.			(arrayY at: (j + 1)) at: (i + 1) put: j*stepY.		].	].	0 to: gridNum y do: [:j |		self transformX: (arrayX at: (j+1)).		self transformY: (arrayY at: (j+1)).	].	0 to: gridNum y do: [:j |		arrayX at: (j+1) put: ((1 to: gridNum x +1) collect: [:i | ((arrayX at: (j+1)) at: i) asInteger]).		arrayY at: (j+1) put: ((1 to: gridNum x +1) collect: [:i | ((arrayY at: (j+1)) at: i) asInteger]).	].	clipRects := (1 to: gridNum y) collect: [:j | Array new: gridNum x].	toRects := (1 to: gridNum y) collect: [:j |  Array new: gridNum x].	quads := (1 to: gridNum y) collect: [:j |  Array new: gridNum x].	0 to: gridNum y - 1 do: [:j |		0 to: gridNum x- 1 do: [:i |			rect := (((arrayX at: (j+1)) at: (i+1))@((arrayY at: (j+1)) at: (i+1)))						corner: ((arrayX at: (j+2)) at: (i+2))@((arrayY at: (j+2)) at: (i+2)).			(clipRects at: j+1) at: i+1 put: rect.			rect width >= stepX ifTrue: [rect := rect expandBy: (1@0)].			rect height >= stepY ifTrue: [rect := rect expandBy: (0@1)].			(toRects at: j+1) at: i+1 put: rect.			tx := (i)*stepX.			ty := (j)*stepY.			(quads at: j+1) at: i+1						put: {(tx)@(ty). (tx)@(ty+stepY). (tx+stepX)@(ty+stepY). (tx+stepX)@(ty)}.		].	].! !!FishEyeMorph methodsFor: 'menus' stamp: 'dgd 9/21/2003 17:55'!chooseMagnification	self inform: 'Magnification is fixed, sorry.' translated! !!FishEyeMorph methodsFor: 'menu' stamp: 'yo 12/17/1999 12:03'!chooseMagnification: evt! !!FishEyeMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:19'!extent: aPoint	"Round to a number divisible by grid.  Note that the superclass has its own implementation."		| g gridSize |	gridSize := self gridSizeFor: aPoint.	"self halt."	g := (aPoint - (2 * borderWidth)) // gridSize.	srcExtent := g * gridSize.	gridNum := g.	^super extent: self defaultExtent! !!FishEyeMorph methodsFor: 'initialization' stamp: 'yo 12/17/1999 10:15'!g: aFloatArray max: max focus: focus	| dNormX array |	dNormX := aFloatArray - focus.		array := dNormX / max.	array *= d.	array += 1.0.	array := 1.0 / array.	dNormX *= (d+1.0).	array *= dNormX.	^array += focus.! !!FishEyeMorph methodsFor: 'private' stamp: 'yo 12/17/1999 11:15'!gridSizeFor: aPoint	"returns appropriate size for specified argument"	| g |	g := aPoint x min: aPoint y.	g <= 256 ifTrue: [^8].	^16.! !!FishEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:21'!initialize	"initialize the state of the receiver"		super initialize.	"magnification should be always 1"	magnification := 1.	d := 1.3.	self extent: 130 @ 130! !!FishEyeMorph methodsFor: 'parts bin' stamp: 'sw 6/28/2001 11:32'!initializeToStandAlone	super initializeToStandAlone.	"magnification should be always 1"	magnification := 1.	d := 1.3.	self extent: 130@130.! !!FishEyeMorph methodsFor: 'magnifying' stamp: 'ar 5/28/2000 12:12'!magnifiedForm	| warp warpForm fromForm |	savedExtent ~= srcExtent ifTrue: [		savedExtent := srcExtent.		self calculateTransform].	warpForm := Form extent: srcExtent depth: Display depth.	fromForm := super magnifiedForm.	warp :=  (WarpBlt current toForm: warpForm)		sourceForm: fromForm;		colorMap: nil;		cellSize: 2;		combinationRule: Form over.	1 to: gridNum y do: [:j |		1 to: gridNum x do: [:i |			warp				clipRect: ((clipRects at: j) at: i);				copyQuad: ((quads at: j) at: i)					toRect: ((toRects at: j) at: i).		].	].	^warpForm! !!FishEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:20'!transformX: aFloatArray	| focus gridNum2 subArray dMaxX |	focus := srcExtent x asFloat / 2.	gridNum2 := (aFloatArray findFirst: [:x | x > focus]) - 1.	dMaxX := 0.0 - focus.	subArray := self 					g: (aFloatArray copyFrom: 1 to: gridNum2) 					max: dMaxX focus: focus.	aFloatArray replaceFrom: 1 to: gridNum2 with: subArray startingAt: 1.	dMaxX := focus.    " = (size - focus)"	subArray := self 					g: (aFloatArray copyFrom: gridNum2 + 1 to: gridNum x + 1)					max: dMaxX focus: focus.	aFloatArray replaceFrom: gridNum2 + 1 to: gridNum x + 1 with: subArray startingAt: 1.! !!FishEyeMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 23:04'!transformY: aFloatArray 	| focus subArray dMaxY |	focus := srcExtent y asFloat / 2.	dMaxY := (aFloatArray first) <= focus 				ifTrue: [0.0 - focus]				ifFalse: [focus].	subArray := self 				g: (aFloatArray copyFrom: 1 to: gridNum x + 1)				max: dMaxY				focus: focus.	aFloatArray 		replaceFrom: 1		to: gridNum x + 1		with: subArray		startingAt: 1! !!MagnifierMorph class methodsFor: 'instance creation' stamp: 'StephaneDucasse 2/27/2013 20:21'!newShowingPointer	"Answer a Magnifier that also displays Morphs in the Hand and the Hand position"	^ self new		showPointer: true;		yourself! !!MagnifierMorph methodsFor: 'menu' stamp: 'TestRunner 11/14/2009 17:01'!addCustomMenuItems: aCustomMenu hand: aHandMorph	super addCustomMenuItems: aCustomMenu hand: aHandMorph.	aCustomMenu		addLine;		add: 'magnification...' translated action: #chooseMagnification;		addUpdating: #trackingPointerString action: #toggleTrackingPointer;		addUpdating: #showingPointerString action: #toggleShowingPointer! !!MagnifierMorph methodsFor: 'accessing' stamp: 'bf 9/21/1999 09:31'!borderWidth: anInteger	"Grow outwards preserving innerBounds"	| c |  	c := self center.	super borderWidth: anInteger.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'menu' stamp: 'alain.plantec 2/6/2009 17:08'!chooseMagnification	| result possibleMagnifications title |	possibleMagnifications := #(1.5 2 4 8).	title := 'Choose magnification' translated, '\(' , 'currently' translated, ' {1})' format: {magnification}.	result := UIManager default chooseFrom: possibleMagnifications values: possibleMagnifications title: title.	(result isNil or: [result = magnification]) ifTrue: [^ self].	magnification := result.	self extent: self extent. "round to new magnification"	self changed. "redraw even if extent wasn't changed"! !!MagnifierMorph methodsFor: 'menu' stamp: 'di 8/24/2000 14:02'!chooseMagnification: evt	| handle origin aHand currentMag |	currentMag := magnification.	aHand := evt ifNil: [self currentHand] ifNotNil: [evt hand].	origin := aHand position y.	handle := HandleMorph new forEachPointDo:		[:newPoint | self magnification: (newPoint y - origin) / 8.0 + currentMag].	aHand attachMorph: handle.	handle startStepping.	self changed. "Magnify handle"! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:38'!defaultBorderWidth	"answer the default border width for the receiver"	^ 1! !!MagnifierMorph methodsFor: 'initialization' stamp: 'dgd 2/14/2003 22:28'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!MagnifierMorph methodsFor: 'geometry' stamp: 'bf 9/21/1999 09:22'!defaultExtent	^(srcExtent * magnification) truncated + (2 * borderWidth)! !!MagnifierMorph methodsFor: 'drawing' stamp: 'ar 2/12/2000 18:06'!drawOn: aCanvas	super drawOn: aCanvas.		"border and fill"	aCanvas isShadowDrawing ifFalse: [		"Optimize because #magnifiedForm is expensive"		aCanvas paintImage: self magnifiedForm at: self innerBounds origin]! !!MagnifierMorph methodsFor: 'geometry' stamp: 'StephaneDucasse 2/27/2013 20:23'!extent: aPoint	"Round to multiples of magnification"		srcExtent := (aPoint - (2 * borderWidth)) // magnification.	^super extent: self defaultExtent! !!MagnifierMorph methodsFor: 'event handling' stamp: 'bf 9/18/1999 20:42'!handlesMouseDown: evt	^evt yellowButtonPressed		or: [super handlesMouseDown: evt]! !!MagnifierMorph methodsFor: 'testing' stamp: 'bf 9/21/1999 08:51'!hasTranslucentColor	"I may show what's behind me, so tell the hand to don't cache"	^self sourceRect intersects: self bounds! !!MagnifierMorph methodsFor: 'initialization' stamp: 'nk 3/6/2004 10:47'!initialize	"initialize the state of the receiver"	super initialize.	trackPointer := true.	showPointer := false.	magnification := 2.	self extent: 128 @ 128! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 12:27'!magnification: aNumber	| c |  	magnification := aNumber min: 8 max: 0.5.	magnification := magnification roundTo:		(magnification < 3 ifTrue: [0.5] ifFalse: [1]).	srcExtent := srcExtent min: (512@512) // magnification. "to prevent accidents"	c := self center.	super extent: self defaultExtent.	self center: c.! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'TestRunner 11/14/2009 17:02'!magnifiedForm	"Answer the magnified form"	| srcRect form magnified |	srcRect := self sourceRectFrom: self sourcePoint.	(RecursionLock isNil and: [ self showPointer or: [ srcRect intersects: self bounds ]])		ifTrue: [RecursionLock := self.			form := self currentWorld						patchAt: srcRect						without: self						andNothingAbove: false.			RecursionLock := nil]		ifFalse: ["cheaper method if the source is not occluded"			form := Display copy: srcRect].	"smooth if non-integer scale"	magnified := form				magnify: form boundingBox				by: magnification				smoothing: (magnification isInteger						ifTrue: [1]						ifFalse: [2]).	"display the pointer rectangle if desired"	self showPointer		ifTrue: [magnified				reverse: (magnified center - (2 @ 2) extent: 4 @ 4)				fillColor: Color white].	^ magnified! !!MagnifierMorph methodsFor: 'event handling' stamp: 'bf 9/21/1999 10:45'!mouseDown: evt	evt yellowButtonPressed		ifTrue: [self chooseMagnification: evt]		ifFalse: [super mouseDown: evt]! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:34'!showPointer	^showPointer ifNil: [ showPointer := false ].! !!MagnifierMorph methodsFor: 'accessing' stamp: 'nk 3/6/2004 10:14'!showPointer: aBoolean	"If aBoolean is true, display the current pointer position as a small square in the center of the lens."	showPointer == aBoolean ifTrue: [ ^self ].	showPointer := aBoolean.	self changed.! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:34'!showingPointerString	^ (self showPointer		ifTrue: ['stop showing pointer']		ifFalse: ['start showing pointer']) translated! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 11/1/2000 16:02'!sourcePoint	"If we are being dragged use our center, otherwise use pointer position"	^(trackPointer not or: [owner notNil and: [owner isHandMorph]])		ifTrue: [self center]		ifFalse: [self currentHand position]! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'bf 9/21/1999 08:47'!sourceRect	^self sourceRectFrom: self sourcePoint! !!MagnifierMorph methodsFor: 'magnifying' stamp: 'di 12/17/1999 13:42'!sourceRectFrom: aPoint	^ (aPoint extent: srcExtent) translateBy: (srcExtent // -2) + 1.! !!MagnifierMorph methodsFor: 'stepping and presenter' stamp: 'di 9/28/1999 07:57'!step	self changed! !!MagnifierMorph methodsFor: 'stepping and presenter' stamp: 'di 9/28/1999 07:57'!stepTime	^ 0! !!MagnifierMorph methodsFor: 'menu' stamp: 'nk 3/17/2004 11:35'!toggleShowingPointer	self showPointer: self showPointer not! !!MagnifierMorph methodsFor: 'menu' stamp: 'bf 9/20/1999 15:48'!toggleTrackingPointer	trackPointer := trackPointer not! !!MagnifierMorph methodsFor: 'menu' stamp: 'dgd 8/30/2003 21:51'!trackingPointerString	^ (trackPointer		ifTrue: ['stop tracking pointer']		ifFalse: ['start tracking pointer']) translated! !!RectangleMorph commentStamp: 'PhilippeBack 8/8/2014 10:19' prior: 34012045!A RectangleMorph is  a compatibility class to allow this package to load as it is now replaced by BorderedMorph since Pharo 3.0!!DoubleClickExample commentStamp: 'StephaneDucasse 8/19/2009 22:55' prior: 34012252!Illustrates the double-click capabilities of Morphic.DoubleClickExample new openInWorld 	If you have a kind of morph you wish to have respond specially to a double-click, it should:(1)  Respond "true" to #handlesMouseDown:(2)  In its mouseDown: method, send #waitForClicksOrDrag:event: to the hand.(3)  Reimplement #click: to react to single-clicked mouse-down.(4)  Reimplement #doubleClick: to make the appropriate response to a double-click.(5)  Reimplement #drag: to react to non-clicks.  This message is sent continuously until the button is released.  You can check the event argument to react differently on the first, intermediate, and last calls.!!DoubleClickExample methodsFor: 'accessing' stamp: 'StephaneDucasse 2/27/2013 21:13'!balloonText	^ 'Double-click on me to change my color; single-click on me to change border color;hold mouse down within me and then move it to grow (if I''m red) or shrink (if I''m blue).'! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!click: evt	self showBalloon: 'click' hand: evt hand.	self borderColor: (self borderColor = Color black ifTrue: [Color yellow] ifFalse: [Color black])! !!DoubleClickExample methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:22'!defaultColor"answer the default color/fill style for the receiver"	^ Color red! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!doubleClick: evt	self showBalloon: 'doubleClick' hand: evt hand.	self color: ((color = Color blue) ifTrue: [Color red] ifFalse: [Color blue])! !!DoubleClickExample methodsFor: 'event handling' stamp: 'sw 9/14/1999 16:05'!handlesMouseDown: evt	^ true! !!DoubleClickExample methodsFor: 'event handling' stamp: 'bf 9/28/1999 17:20'!mouseDown: evt	"Do nothing upon mouse-down except inform the hand to watch for a double-click; wait until an ensuing click:, doubleClick:, or drag: message gets dispatched"	evt hand waitForClicksOrDrag: self event: evt! !!DoubleClickExample methodsFor: 'event handling' stamp: 'ar 10/3/2000 17:05'!startDrag: evt	"We'll get a mouseDown first, some mouseMoves, and a mouseUp event last"	| oldCenter |	evt isMouseDown ifTrue:		[self showBalloon: 'drag (mouse down)' hand: evt hand.		self world displayWorld.		(Delay forMilliseconds: 750) wait].	evt isMouseUp ifTrue:		[self showBalloon: 'drag (mouse up)' hand: evt hand].	(evt isMouseUp or: [evt isMouseDown]) ifFalse:		[self showBalloon: 'drag (mouse still down)' hand: evt hand].	(self containsPoint: evt cursorPoint)		ifFalse: [^ self].	oldCenter := self center.	color = Color red		ifTrue:			[self extent: self extent + (1@1)]		ifFalse:			[self extent: ((self extent - (1@1)) max: (16@16))].	self center: oldCenter! !!HeadingMorph commentStamp: 'StephaneDucasse 8/19/2009 23:00' prior: 34012994!A HeadingMorph displays an arrow on a grid as well as its decomposition on x and y axis.Clicking on it changes the direction of the main arrow.	HeadingMorph new openInWorld!!HeadingMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:34'!defaultBorderWidth"answer the default border width for the receiver"	^ 1! !!HeadingMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:10'!defaultColor	"answer the default color/fill style for the receiver"	^ Color		r: 0.6		g: 1.0		b: 1.0! !!HeadingMorph methodsFor: 'accessing'!degrees	^ (degrees + 90.0) \\ 360.0! !!HeadingMorph methodsFor: 'accessing'!degrees: aNumber	degrees := (aNumber asFloat + 270.0) \\ 360.0.! !!HeadingMorph methodsFor: 'drawing'!drawArrowFrom: p1 to: p2 width: w color: aColor on: aCanvas	| d p |	d := (p1 - p2) theta radiansToDegrees.	aCanvas line: p1 to: p2 width: w color: aColor.	p := p2 + (Point r: 5 degrees: d - 50).	aCanvas line: p to: p2 width: w color: aColor.	p := p2 + (Point r: 5 degrees: d + 50).	aCanvas line: p to: p2 width: w color: aColor.! !!HeadingMorph methodsFor: 'drawing'!drawOn: aCanvas	| x y r center box |	super drawOn: aCanvas.	box := self innerBounds.	1 to: 9 do: [:i |		x := box left + ((box width * i) // 10).		aCanvas line: (x@box top) to: (x@(box bottom - 1)) color: Color black.		y := box top + ((box height * i) // 10).		aCanvas line: (box left@y) to: ((box right - 1)@y) color: Color black].	r := ((box width asFloat * magnitude asFloat) / 2.0) - 1.0.	center := box center.	self drawArrowFrom: center - (1@1)		to: center + ((r * degrees degreesToRadians cos)@0) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (0@(r * degrees degreesToRadians sin)) - (1@1)		width: 3		color: (Color red)		on: aCanvas.	self drawArrowFrom: center - (1@1)		to: center + (Point r: r degrees: degrees) - (1@1)		width: 3		color: Color black		on: aCanvas.! !!HeadingMorph methodsFor: 'geometry'!extent: aPoint	"Contrain extent to be square."	| d |	d := aPoint x min: aPoint y.	super extent: d@d.! !!HeadingMorph methodsFor: 'event handling'!handlesMouseDown: evt	^ true! !!HeadingMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:10'!initialize	"initialize the state of the receiver"	super initialize.	degrees := 90.0.	magnitude := 1.0.	self extent: 160 @ 160! !!HeadingMorph methodsFor: 'accessing'!magnitude	^ magnitude! !!HeadingMorph methodsFor: 'accessing'!magnitude: aNumber	magnitude := (aNumber asFloat max: 0.0) min: 1.0.! !!HeadingMorph methodsFor: 'events' stamp: 'mk 11/7/2003 11:35'!mouseDown: evt	| v |	self changed.	v := evt cursorPoint - bounds center.	degrees := v theta radiansToDegrees.	magnitude := (v r asFloat / (bounds width asFloat / 2.0)) min: 1.0.! !!HeadingMorph methodsFor: 'events' stamp: 'mk 11/7/2003 11:36'!mouseMove: evt	self mouseDown: evt! !!StarWithABallMorph commentStamp: '<historical>' prior: 34013230!This is a example of how to use a morph. It consists of only two methods, initialize and step.	StarWithABallMorph new openInWorld.!!StarWithABallMorph methodsFor: 'initialization' stamp: 'dgd 2/21/2003 19:59'!initialize	"initialize the state of the receiver"	super initialize.	phase := 1.	self extent: 200 @ 200.	ball := EllipseMorph new extent: 30 @ 30.	self		addMorph: ((star := StarMorph new extent: 150 @ 150) center: self center)! !!StarWithABallMorph methodsFor: 'stepping and presenter' stamp: 'kfr 10/26/2003 18:33'!step	phase := phase\\8 + 1.	phase = 1 ifTrue: [^ ball delete].	phase < 4 ifTrue:[^self].	phase = 4 ifTrue: [self addMorph: ball].	ball align: ball center with: (star vertices at: (phase-3*2)).! !!StickyPadMorph commentStamp: '<historical>' prior: 34013425!A colored sticker note: translucent, borderless Rectangles in a sequence of 6 colors.  StickyPadMorph minimics the stickyPad 			StickyPadMorph new openInWorld 	!!StickyPadMorph class methodsFor: 'initialization' stamp: 'PhilippeBack 8/8/2014 09:57'!initialize	"Class initialization"	LastColorIndex := 0.	Colors :=  {		Color r: 0.0 g: 0.0 b: 0.839 alpha: 0.267.		Color r: 0.484 g: 1.0 b: 0.452 alpha: 0.706.		Color r: 1.0 g: 0.355 b: 0.71 alpha: 0.569.		Color r: 1.0 g: 1.0 b: 0.03 alpha: 0.561.		Color r: 0.484 g: 0.161 b: 1.0 alpha: 0.529.		Color r: 0.097 g: 0.097 b: 0.097 alpha: 0.192.	}.		"self registerInFlapsRegistry.	""StickyPadMorph initialize"! !!StickyPadMorph methodsFor: 'visual properties' stamp: 'dgd 9/18/2004 18:52'!canHaveFillStyles	"Return true if the receiver can have general fill styles; not just 	colors. This method is for gradually converting old morphs."	^ true! !!StickyPadMorph methodsFor: 'parts bin' stamp: 'StephaneDucasse 2/27/2013 19:58'!initialize	"Initialize the receiver to stand alone.  Use the next color in the standard sequence."	Colors ifNil: [self class initialize].	LastColorIndex := 		LastColorIndex			ifNil:				[1]			ifNotNil:				[(LastColorIndex \\ Colors size) + 1].	super initialize.	self color: (Colors at: LastColorIndex).	self extent: 200@160.	self borderWidth: 0	! !!AtomMorph commentStamp: 'tbn 11/25/2004 09:06' prior: 34013650!AtomMorph represents an atom used in the simulation ofan ideal gas. It's container is typically a BouncingAtomsMorph.Try:	BouncingAtomsMorph  new openInWorldto open the gas simulation or:	AtomMorph exampleto open an instance in the current world!!AtomMorph class methodsFor: 'examples' stamp: 'StephaneDucasse 2/27/2013 21:19'!example	"AtomMorph example"	|a|	a := AtomMorph new openInWorld. 	a color: Color random. 	[1000 timesRepeat:  [a bounceIn: World bounds.  (Delay forMilliseconds: 50) wait]. 	 a delete] fork.! !!AtomMorph methodsFor: 'private' stamp: 'jm 8/10/1998 17:40'!bounceIn: aRect	"Move this atom one step along its velocity vector and make it bounce if it goes outside the given rectangle. Return true if it is bounced."	| p vx vy px py bounced |	p := self position.	vx := velocity x.		vy := velocity y.	px := p x + vx.		py := p y + vy.	bounced := false.	px > aRect right ifTrue: [		px := aRect right - (px - aRect right).		vx := velocity x negated.		bounced := true].	py > aRect bottom ifTrue: [		py :=  aRect bottom - (py - aRect bottom).		vy := velocity y negated.		bounced := true].	px < aRect left ifTrue: [		px := aRect left - (px - aRect left).		vx := velocity x negated.		bounced := true].	py < aRect top ifTrue: [		py :=  aRect top - (py - aRect top).		vy := velocity y negated.		bounced := true].	self position: px @ py.	bounced ifTrue: [self velocity: vx @ vy].	^ bounced! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultBorderWidth"answer the default border width for the receiver"	^ 0! !!AtomMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 14:13'!defaultColor"answer the default color/fill style for the receiver"	^ Color blue! !!AtomMorph methodsFor: 'drawing'!drawOn: aCanvas	"Note: Set 'drawAsRect' to true to make the atoms draw faster. When testing the speed of other aspects of Morphic, such as its damage handling efficiency for large numbers of atoms, it is useful to make drawing faster."	| drawAsRect |	drawAsRect := false.  "rectangles are faster to draw"	drawAsRect		ifTrue: [aCanvas fillRectangle: self bounds color: color]		ifFalse: [super drawOn: aCanvas].! !!AtomMorph methodsFor: 'accessing'!infected	^ color = Color red! !!AtomMorph methodsFor: 'accessing'!infected: aBoolean	aBoolean		ifTrue: [self color: Color red]		ifFalse: [self color: Color blue].! !!AtomMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 21:19'!initialize	"Make a new atom with a random position and velocity."	super initialize.	self extent: 8 @ 7.	self		randomPositionIn: (0 @ 0 corner: 300 @ 300)		maxVelocity: 10! !!AtomMorph methodsFor: 'initialization' stamp: 'RAA 12/15/2000 07:32'!randomPositionIn: aRectangle maxVelocity: maxVelocity	"Give this atom a random position and velocity."	| origin extent |	origin := aRectangle origin.	extent := (aRectangle extent - self bounds extent) rounded.	self position:		(origin x + extent x atRandom) @		(origin y + extent y atRandom).	velocity :=		(maxVelocity - (2 * maxVelocity) atRandom) @		(maxVelocity - (2 * maxVelocity) atRandom).! !!AtomMorph methodsFor: 'accessing'!velocity	^ velocity! !!AtomMorph methodsFor: 'accessing'!velocity: newVelocity	velocity := newVelocity.! !!Flasher commentStamp: 'StephaneDucasse 8/19/2009 22:56' prior: 34013975!A simple example - a circle that flashes.	Flasher new openInWorld The "onColor" instance variable indicates the color to use when "on",  A darker color is used to represent "off".The #step method, called every 500ms. by default, alternatively makes the flasher show its "on" and its "off" color.!!Flasher methodsFor: 'parts bin' stamp: 'sd 4/21/2002 09:36'!initializeToStandAlone	"Initialize the flasher."	super initializeToStandAlone.	self color: Color red.	self onColor: Color red. 	self borderWidth: 2.	self extent: 25@25! !!Flasher methodsFor: 'operations' stamp: 'sw 5/28/2002 18:44'!onColor	"Answer my onColor"	^ onColor ifNil: [onColor := Color red]! !!Flasher methodsFor: 'operations' stamp: 'sd 4/21/2002 09:55'!onColor: aColor	"Change my on color to be aColor"	onColor := aColor.	self color: aColor! !!Flasher methodsFor: 'stepping and presenter' stamp: 'sw 5/28/2002 18:45'!step	"Perform my standard periodic action"	super step.	self color = self onColor		ifTrue: [self color: (onColor alphaMixed: 0.5 with: Color black)]		ifFalse: [self color: onColor]! !!Flasher methodsFor: 'stepping and presenter' stamp: 'sw 4/17/2002 12:05'!stepTime	"Answer the desired time between steps, in milliseconds."	^ 500! !!MovingEyeMorph commentStamp: '<historical>' prior: 34014333!A MovingEyeMorph is a morph representing an eye whose iris is following the mouse cursor.	MovingEyeMorph new openInWorld!!MovingEyeMorph class methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:17'!initialize	"MovingEyeMorph initialize"	IrisSize := (0.42@0.50).! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:18'!defaultColor	"answer the default color/fill style for the receiver"	^ Color black! !!MovingEyeMorph methodsFor: 'geometry' stamp: 'yo 2/15/2001 15:59'!extent: aPoint	super extent: aPoint.	inner extent: (self extent * ((1.0@1.0)-IrisSize)) asIntegerPoint.	iris extent: (self extent * IrisSize) asIntegerPoint.	inner position: (self center - (inner extent // 2)) asIntegerPoint.! !!MovingEyeMorph methodsFor: 'initialization' stamp: 'StephaneDucasse 2/27/2013 20:18'!initialize	"initialize the state of the receiver"		super initialize.	inner := EllipseMorph new.	inner color: self color.	inner extent: (self extent * (1.0 @ 1.0 - IrisSize)) asIntegerPoint.	inner borderColor: self color.	inner borderWidth: 0.	iris := EllipseMorph new.	iris color: Color white.	iris extent: (self extent * IrisSize) asIntegerPoint.	self addMorphCentered: inner.	inner addMorphCentered: iris.	self extent: 26 @ 33! !!MovingEyeMorph methodsFor: 'accessing' stamp: 'yo 2/15/2001 15:24'!irisPos: cp	| a b theta x y |	theta := (cp - self center) theta.	a := inner width // 2.	b := inner height // 2.	x := a * (theta cos).	y := b * (theta sin).	iris position: ((x@y) asIntegerPoint) + self center - (iris extent // 2).! !!MovingEyeMorph methodsFor: 'stepping and presenter' stamp: 'di 2/18/2001 00:10'!step	| cp |	cp := self globalPointToLocal: World primaryHand position.	(inner containsPoint: cp)		ifTrue: [iris position: (cp - (iris extent // 2))]		ifFalse: [self irisPos: cp].	self changed "cover up gribblies if embedded in Flash"! !!MovingEyeMorph methodsFor: 'testing' stamp: 'StephaneDucasse 2/27/2013 20:18'!stepTime	^ 100! !!WatchMorph commentStamp: '<historical>' prior: 34014508!This class is a representation of a watch.The labels' font is changeble. Labels' font size increase or decrease when resizing me.WatchMorph new openInWorld(WatchMorph fontName: 'ComicPlain' bgColor: Color transparent centerColor: Color transparent) openInWorld		" transparent "(WatchMorph fontName: 'ComicBold' bgColor: Color white centerColor: Color black) openInWorldStructure:	fontName		String -- the labels' font name	cColor			Color -- center color	handsColor		Color	romanNumerals	Boolean	antialias		Boolean!!WatchMorph class methodsFor: 'instance creation' stamp: 'di 5/16/2000 21:43'!fontName: aString bgColor: aColor centerColor: otherColor	^ self new		fontName: aString;		color: aColor;		centerColor: otherColor! !!WatchMorph methodsFor: 'menus' stamp: 'mara 7/17/2010 16:36'!addCustomMenuItems: aMenu hand: aHandMorph	"Add morph-specific items to the given menu which was invoked by the given hand."	super addCustomMenuItems: aMenu hand: aHandMorph.	aMenu addLine.	aMenu addUpdating: #romanNumeralString action: #toggleRoman.	aMenu addUpdating: #antiAliasString action: #toggleAntialias.	aMenu addLine.	aMenu add: 'change font...' translated action: #changeFont.	aMenu balloonTextForLastItem: 'Allows you to change the font used to display the numbers.' translated.	aMenu balloonTextForLastItem: 'Allows you to specify a new color for the hands of the watch.  Note that actual *watch* color can be changed simply by using the halo''s recoloring handle.' translated.	aMenu balloonTextForLastItem: 'Allows you to specify a new color to be used during PM hours for the center portion of the watch; during AM hours, a lighter shade of the same color will be used.' translated.! !!WatchMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 22:25'!antiAliasString	^ (antialias		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'anti-aliasing' translated! !!WatchMorph methodsFor: 'accessing' stamp: 'bf 5/18/2000 11:06'!antialias: aBoolean	antialias := aBoolean! !!WatchMorph methodsFor: 'accessing' stamp: 'sw 7/4/2002 00:19'!centerColor: aColor	"Set the center color as indicated; map nil into transparent"	cColor := aColor ifNil: [Color transparent]! !!WatchMorph methodsFor: 'menus' stamp: 'alain.plantec 2/6/2009 17:47'!changeFont	| choice |	choice := UIManager default chooseFrom: StrikeFont familyNames values: StrikeFont familyNames.	choice ifNotNil: [self fontName: choice]! !!WatchMorph methodsFor: 'labels' stamp: 'di 5/16/2000 21:42'!createLabels	| numeral font h r |	self removeAllMorphs.	font := StrikeFont familyName: fontName size: (h := self height min: self width)//8.	r := 1.0 - (1.4 * font height / h).	1 to: 12 do:		[:hour |		numeral := romanNumerals			ifTrue: [#('I' 'II' 'III' 'IV' 'V' 'VI' 'VII' ' VIII' 'IX' 'X' 'XI' 'XII') at: hour]			ifFalse: [hour asString].		self addMorphBack: ((StringMorph contents: numeral font: font emphasis: 1)			center: (self radius: r hourAngle: hour)) lock].! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!defaultColor"answer the default color/fill style for the receiver"	^ Color green! !!WatchMorph methodsFor: 'drawing' stamp: 'sw 7/4/2002 00:22'!drawOn: aCanvas	"Draw the watch on the given canvas"	| pHour pMin pSec time centerColor |	time := Time now.	pHour := self radius: 0.6 hourAngle: time hours + (time minutes/60.0).	pMin := self radius: 0.72 hourAngle: (time minutes / 5.0).	pSec := self radius: 0.8 hourAngle: (time seconds / 5.0).	centerColor := cColor		ifNil:			[Color transparent]		ifNotNil:			[time hours < 12				ifTrue: [cColor muchLighter]				ifFalse: [cColor]].	antialias ifTrue:		[aCanvas asBalloonCanvas			aaLevel: 4;			drawOval: (bounds insetBy: borderWidth // 2 + 1) color: self fillStyle				borderWidth: borderWidth borderColor: borderColor;			drawOval: (bounds insetBy: self extent*0.35) color: centerColor				borderWidth: 0 borderColor: Color black;			drawPolygon: {self center. pHour}				color: Color transparent borderWidth: 3 borderColor: handsColor;			drawPolygon: {self center. pMin}				color: Color transparent borderWidth: 2 borderColor: handsColor;			drawPolygon: {self center. pSec}				color: Color transparent borderWidth: 1 borderColor: handsColor]		ifFalse:			[super drawOn: aCanvas.			aCanvas				fillOval: (bounds insetBy: self extent*0.35) color: centerColor;				line: self center to: pHour width: 3 color: handsColor;				line: self center to: pMin width: 2 color: handsColor;				line: self center to: pSec width: 1 color: handsColor]! !!WatchMorph methodsFor: 'geometry' stamp: 'di 5/16/2000 21:18'!extent: newExtent	super extent: newExtent.	self createLabels! !!WatchMorph methodsFor: 'accessing' stamp: 'di 5/16/2000 21:45'!fontName: aString	fontName := aString.	self createLabels! !!WatchMorph methodsFor: 'accessing' stamp: 'bf 9/25/2008 15:17'!handsColor: aColor	handsColor := aColor! !!WatchMorph methodsFor: 'initialization' stamp: 'dgd 3/7/2003 15:01'!initialize	"initialize the state of the receiver"	super initialize.	""	self handsColor: Color red.	self centerColor: Color gray.	romanNumerals := false.	antialias := false.	fontName := 'NewYork'.	self extent: 130 @ 130.	self start! !!WatchMorph methodsFor: 'private' stamp: 'di 5/16/2000 22:22'!radius: unitRadius hourAngle: hourAngle	"unitRadius goes from 0.0 at the center to 1.0 on the circumference.	hourAngle runs from 0.0 clockwise around to 12.0 with wrapping."	^ self center + (self extent * (Point r: 0.5 * unitRadius									degrees: hourAngle * 30.0 - 90.0)).! !!WatchMorph methodsFor: 'menus' stamp: 'dgd 8/30/2003 22:24'!romanNumeralString	"Answer a string governing the roman-numerals checkbox"	^ (romanNumerals		ifTrue: ['<on>']		ifFalse: ['<off>'])		, 'roman numerals' translated! !!WatchMorph methodsFor: 'stepping and presenter' stamp: 'bf 9/25/2008 15:17'!step	self changed.! !!WatchMorph methodsFor: 'menus' stamp: 'bf 5/17/2000 18:46'!toggleAntialias	antialias := antialias not! !!WatchMorph methodsFor: 'menus' stamp: 'di 5/16/2000 21:19'!toggleRoman	romanNumerals := romanNumerals not.	self createLabels! !"MorphExamplesAndDemos"!----SNAPSHOT----2016-02-17T11:48:27.00906+01:00 Pharo4.0.image priorSource: 361201!----STARTUP----2016-02-27T14:53:16.735234+01:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-02-28T00:01:12.564234+01:00 Pharo4.0.image priorSource: 539586!!ConfigurationOfPetitParser commentStamp: '<historical>' prior: 0!self loadDevelopment!!ConfigurationOfPetitParser commentStamp: '<historical>' prior: 34094365!self loadDevelopment!----STARTUP----2016-02-29T15:41:08.159745+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 16:06'!catalogContactInfo	^ 'info@moosetechnology.org'! !!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 16:06'!catalogDescription	^ 'PetitParser is a parsing engine. It models grammars and parsers dynamically as objects based on a mechanism inspired from scannnerless parsing, parser combinators, parsing expression grammars and packrat parsers.'! !!ConfigurationOfPetitParser class methodsFor: 'catalog' stamp: 'TudorGirba 1/5/2016 15:23'!catalogKeywords	^ #(parser)	! !!ConfigurationOfPetitParser class methodsFor: 'private' stamp: 'FabrizioPerin 4/27/2010 15:04'!ensureMetacello	Smalltalk at: #MetacelloProject ifAbsent: [		Gofer new				url: 'http://seaside.gemstone.com/ss/metacello';				package: 'ConfigurationOfMetacello';				load.		(Smalltalk at: #ConfigurationOfMetacello) loadLatestVersion ]! !!ConfigurationOfPetitParser class methodsFor: 'metacello tool support' stamp: 'tg 4/18/2010 23:51'!isMetacelloConfig	"Answer true and the Metacello tools will operate on you"		^true! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/4/2015 11:47'!load	"Load the #stable version defined for this platform. The #stable version is the version that is recommended to be used on this platform."	"self load"	<apiDocumentation>	^(self project version: #stable) load! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'TudorGirba 4/21/2013 23:27'!loadDevelopment	(self project version: #development) load! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:57'!loadPetitParser		(self project version: #development) load: 'Parser'! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:57'!loadPetitParserIDE		(self project version: #development) load: 'ParserIDE'! !!ConfigurationOfPetitParser class methodsFor: 'loading' stamp: 'JanKurs 4/1/2015 11:17'!loadStable	(self project version: #stable) load! !!ConfigurationOfPetitParser class methodsFor: 'accessing' stamp: 'tg 4/18/2010 23:51'!project	^self new project! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AlexandreBergel 12/3/2010 09:14'!baseline10: spec 	<version: '1.0-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec author: 'Alexandre Bergel'.		spec description: 'work on Pharo 1.1.1'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitGui' with: [ spec requires: 'Glamour for Petit'].		spec group: 'Core' with: #( 'PetitParser' 'PetitAnalyzer' ).		spec group: 'Tests' with: #( 'PetitTests' 'PetitAnalyzer' ).		spec project: 'Glamour for Petit' with: [				spec					className: 'ConfigurationOfGlamour';					file: 'ConfigurationOfGlamour';					version: '2.0-beta.8';					repository: 'http://www.squeaksource.com/Glamour' ].	]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AlexandreBergel 2/18/2011 13:56'!baseline11: spec	<version: '1.1-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Preparing Moose 4.3.2'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [				spec					className: 'ConfigurationOfGlamour';					versionString: '2.1';					repository: 'http://www.squeaksource.com/Glamour' ].		spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('Glamour for Petit' ). ].		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:15'!baseline12: spec	<version: '1.2-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: '2.1';				repository: 'http://www.squeaksource.com/Glamour' ].				spec project: 'AST-Core' with: [			spec				repository: 'http://www.squeaksource.com/MetacelloRepository';				className: 'ConfigurationOfRefactoringBrowser';				loads: #('AST-Core') ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ) ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ) ];			package: 'PetitGui' with: [				spec requires: #('Glamour for Petit' ) ];			package: 'PetitSmalltalk' with: [				spec requires: #( 'AST-Core' 'PetitParser' 'PetitTests') ].			"todo: declare all other packages & dependencies here"		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:16'!baseline13: spec	<version: '1.3-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing all satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: '2.1';				loads: #(Core Morphic);				repository: 'http://www.squeaksource.com/Glamour' ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('PetitParser' 'Glamour for Petit' ). ].				spec			package: 'PrettyPetit'.				spec			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitSQL' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec 			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'Tests' with: #('PetitTests' 'PetitAnalyzer' ). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'StephanEggermont 3/16/2015 09:04'!baseline151: spec 	<version: '1.5.1-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'petitparser project description that loads the version before the changes regarding integration of the island grammar and context by Jan Kurs'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec group: 'Core' with: #( 'PetitParser' 'PetitAnalyzer' ).		spec group: 'Tests' with: #( 'PetitTests' 'PetitAnalyzer' ) ].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				loads: #('GlamourCore');				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].		spec group: 'Gui' with: #( 'PetitGui' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'DiegoLont 9/2/2013 11:16'!baseline15: spec	<version: '1.5-baseline'>	spec for: #'common' do: [		spec blessing: #'baseline'.		spec description: 'Describing all satellite packages'.		spec repository: 'http://source.lukas-renggli.ch/petit'.		spec project: 'Glamour for Petit' with: [			spec				className: 'ConfigurationOfGlamour';				versionString: #stable;				loads: #(Core Morphic);				repository: 'http://www.squeaksource.com/Glamour' ].				spec 			package: 'PetitParser';			package: 'PetitTests' with: [				spec requires: #('PetitParser' ). ];			package: 'PetitAnalyzer' with: [				spec requires: #('PetitTests' ). ];			package: 'PetitGui' with: [				spec requires: #('PetitParser' 'Glamour for Petit' ). ].				spec			package: 'PrettyPetit'.				spec			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec 			group: 'default' with: #('UI' 'Tests');			group: 'Core' with: #('PetitParser' 'PetitAnalyzer' );			group: 'UI' with: #('Core' 'PetitGui' );			group: 'Tests' with: #('Core' 'PetitTests'). ].! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'JanKurs 11/12/2014 15:54'!baseline16: spec 	<version: '1.6-baseline'>		spec for: #common do: [		spec blessing: #baseline.		spec description: 'Describing all satellite packages. Loads configuration from new repository on SmalltalkHub'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests') ].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].		spec group: 'Gui' with: #( 'PetitGui' ) ]! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'JanKurs 4/1/2015 12:19'!baseline17: spec 	<version: '1.7-baseline'>		spec for: #common do: [		spec blessing: #'development'.		spec description: 'Describing all satellite packages. Loads configuration from new repository on SmalltalkHub'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser' 'PetitIndent' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ];			package: 'PetitYAML' with: [				spec requires: #('PetitParser' 'PetitIndent') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests').		spec group: 'Parser' with: #('PetitParser' 													'PetitTests' 													'PetitAnalyzer' 													'PetitSmalltalk' 													'PetitCSV' 													'PetitJson' 													'PetitMSE'													'PetitManifestMf' 													'PetitRegex'													'PetitXPath'													'PetitXml'													'PetitIndent'													'PetitIslands'													'Factorial-Language'													'PetitYAML').	].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #stable;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].				spec group: 'ParserIDE' with: #( 'PetitGui' ) ] ! !!ConfigurationOfPetitParser methodsFor: 'baselines' stamp: 'AndreiChis 10/5/2015 11:59'!baseline18: spec 	<version: '1.8-baseline'>		spec for: #common do: [		spec blessing: #'development'.		spec description: 'For Pharo 5. Use #development for Glamour'.		spec repository: 'http://www.smalltalkhub.com/mc/Moose/PetitParser/main'.		spec 			package: 'PetitParser';			package: 'PetitTests' with: [ spec requires: 'PetitParser'];			package: 'PetitAnalyzer' with: [ spec requires: 'PetitTests'];			package: 'PetitSmalltalk' with: [				spec requires: #( 'PetitParser' 'PetitTests') ];			package: 'PetitCSV' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitJson' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitMSE' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitManifestMf' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitRegex' with: [				spec requires: #('PetitParser') ];			package: 'PetitXPath' with: [				spec requires: #('PetitParser' 'PetitXml') ];			package: 'PetitXml' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIndent' with: [				spec requires: #('PetitParser' 'PetitTests') ];			package: 'PetitIslands' with: [				spec requires: #('PetitParser' 'PetitIndent' 'PetitTests') ];			package: 'Factorial-Language' with: [				spec requires: #('PetitParser') ];			package: 'PetitYAML' with: [				spec requires: #('PetitParser' 'PetitIndent') ].		spec group: 'Core' with: #( 'PetitParser').		spec group: 'Tests' with: #( 'PetitTests').		spec group: 'Parser' with: #('PetitParser' 													'PetitTests' 													'PetitAnalyzer' 													'PetitSmalltalk' 													'PetitCSV' 													'PetitJson' 													'PetitMSE'													'PetitManifestMf' 													'PetitRegex'													'PetitXPath'													'PetitXml'													'PetitIndent'													'PetitIslands'													'Factorial-Language'													'PetitYAML').	].	spec for: #( 'squeakCommon' )  do: [		spec project: 'Glamour' with: [			spec				className: 'ConfigurationOfGlamour';				file: 'ConfigurationOfGlamour';				version: #development;				repository: 'http://www.smalltalkhub.com/mc/Moose/Glamour/main' ].		spec 			package: 'PetitGui' with: [ spec requires: #('Glamour' 'PetitAnalyzer')].				spec group: 'ParserIDE' with: #( 'PetitGui' ) ] ! !!ConfigurationOfPetitParser methodsFor: 'symbolic versions' stamp: 'AndreiChis 10/5/2015 11:59'!development: spec	<symbolicVersion: #'development'>	spec for: #'common' version: '1.8-baseline'.	spec for: #'pharo1.4.x' version: '1.6-baseline'.	spec for: #'pharo2.x' version: '1.6-baseline'.	spec for: #'pharo3.x' version: '1.6-baseline'.	spec for: #'pharo4.x' version: '1.7-baseline'.		spec for: #'pharo5.x' version: '1.8-baseline'.! !!ConfigurationOfPetitParser methodsFor: 'accessing' stamp: 'tg 4/18/2010 23:50'!project	^ project ifNil: [ | constructor |		"Bootstrap Metacello if it is not already loaded"		self class ensureMetacello.		"Construct Metacello project"		constructor := (Smalltalk at: #MetacelloVersionConstructor) on: self.		project := constructor project.		project]! !!ConfigurationOfPetitParser methodsFor: 'symbolic versions' stamp: 'JanKurs 10/21/2015 10:35'!stable: spec	<symbolicVersion: #'stable'>	spec for: #'common' version: '1.10'.	spec for: #'pharo1.3.x' version: '1.5'.	spec for: #'pharo2.x' version: '1.6-baseline'.	spec for: #'pharo3.x' version: '1.10'.	spec for: #'pharo4.x' version: '1.14'.		spec for: #'pharo5.x' version: '1.14'.! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 12/10/2010 18:51'!version10: spec	<version: '1.0' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'First release'.		spec author: 'AlexandreBergel'.		spec timestamp: '12/6/2010 16:11'.		spec project: 'Glamour for Petit' with: '2.0-beta.8'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.208';			package: 'PetitTests' with: 'PetitTests-TudorGirba.24';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.31';			package: 'PetitGui' with: 'PetitGui-TudorGirba.58'.].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 12/23/2014 14:30'!version110: spec	<version: '1.10' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.10'.		spec author: 'TudorGirba'.		spec timestamp: '12/23/2014 14:30'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.262';			package: 'PetitTests' with: 'PetitTests-JanKurs.67';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-JanKurs.78';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-StephanEggermont.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.18';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.1';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #stable.		spec package: 'PetitGui' with: 'PetitGui-JanKurs.148'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 4/1/2015 14:52'!version111: spec	<version: '1.11' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.11'.		spec author: 'JanKurs'.		spec timestamp: '4/1/2015 11:27'.		spec 			package: 'PetitParser' with: 'PetitParser-JamesFoster.274';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-StephanEggermont.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.22';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.7';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'development'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 5/5/2015 19:07'!version112: spec	<version: '1.12' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.12'.		spec author: 'AndreiChis'.		spec timestamp: '5/5/2015 19:03'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.31';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.28';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 5/27/2015 16:42'!version113: spec	<version: '1.13' imports: #('1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.13'.		spec author: 'AndreiChis'.		spec timestamp: '5/27/2015 16:41'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.31';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.28';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6';			package: 'PetitYAML' with: 'PetitYAML-JanKurs.6'.].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'JanKurs 1/10/2016 17:17'!version114: spec	<version: '1.14' imports: #('1.7-baseline' )>	spec for: #'common' do: [		spec blessing: #'stable'.		spec description: 'version 1.13'.		spec author: 'JanKurs'.		spec timestamp: '20/10/2015 10:41'.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.278';			package: 'PetitTests' with: 'PetitTests-JanKurs.73';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-BernardoContreras.86';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.32';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.32';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.11';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6';			package: 'PetitYAML' with: 'PetitYAML-JanKurs.6'.].	spec for: #'squeakCommon' do: [		spec project: 'Glamour' with: #'stable'.		spec package: 'PetitGui' with: 'PetitGui-StefanReichhart.150'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version11: spec	<version: '1.1' imports: #('1.0-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'New version'.		spec author: 'AlexandreBergel'.		spec timestamp: '2/18/2011 13:30'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version12: spec	<version: '1.2' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'release'.		spec description: 'New version'.		spec author: 'AlexandreBergel'.		spec timestamp: '2/18/2011 13:56'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'.  ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AlexandreBergel 5/16/2011 16:23'!version13: spec	<version: '1.3' imports: #('1.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'AlexandreBergel'.		spec timestamp: '5/16/2011 16:23'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.216';			package: 'PetitTests' with: 'PetitTests-lr.32';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.37';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'DamienPollet 8/11/2011 19:21'!version14: spec	<version: '1.4' imports: #('1.3-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'DamienPollet'.		spec timestamp: '8/11/2011 14:00'.		spec project: 'Glamour for Petit' with: '2.1'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.218';			package: 'PetitTests' with: 'PetitTests-DamienPollet.35';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.39';			package: 'PetitGui' with: 'PetitGui-TudorGirba.65';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-lr.47'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'StephanEggermont 3/16/2015 09:04'!version151: spec	<version: '1.5.1' imports: #('1.5.1-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version for petit parser before changes regarding integration of the parsing context and island grammar by Jan Kurs for backward compatibility'.		spec author: 'usmanbhatti'.		spec timestamp: '26/9/2014 18:27'.		spec project: 'Glamour' with: '3.0.7'.		spec 			package: 'PetitParser' with: 'PetitParser-DiegoLont.233';			package: 'PetitTests' with: 'PetitTests-AndreHora.47';			package: 'PetitXml' with: 'PetitXml-lr.35';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-DiegoLont.46';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-DamienCassou.70';			package: 'PetitRegex' with: 'PetitRegex-lr.27';			package: 'PetitGui' with: 'PetitGui-AndreiChis.140'].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 3/4/2012 20:22'!version15: spec	<version: '1.5' imports: #('1.5-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: ''.		spec author: 'DamienPollet'.		spec timestamp: '8/11/2011 14:00'.		spec project: 'Glamour for Petit' with: '2.2'.		spec 			package: 'PetitParser' with: 'PetitParser-lr.228';			package: 'PetitTests' with: 'PetitTests-lr.43';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-lr.39';			package: 'PetitGui' with: 'PetitGui-TudorGirba.90';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-lr.57'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'AndreiChis 10/29/2014 17:57'!version16: spec	<version: '1.6' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version of petitparser for moose 4.7 release'.		spec author: 'usmanbhatti'.		spec timestamp: '3/1/2013 18:01'.		spec project: 'Glamour' with: '2.4'.		spec 			package: 'PetitParser' with: 'PetitParser-YuriyTymchuk.232';			package: 'PetitTests' with: 'PetitTests-AndreHora.47';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-DiegoLont.46';			package: 'PetitGui' with: 'PetitGui-DiegoLont.125'. ].! !!ConfigurationOfPetitParser methodsFor: 'versions' stamp: 'TudorGirba 12/23/2014 14:29'!version19: spec	<version: '1.9' imports: #('1.6-baseline' )>	spec for: #'common' do: [		spec blessing: #'development'.		spec description: 'releasing a version of petitparser for moose 5 release'.		spec author: 'StephanEggermont'.		spec timestamp: '12/12/2014 11:28'.		spec project: 'Glamour' with: #stable.		spec 			package: 'PetitParser' with: 'PetitParser-JanKurs.261';			package: 'PetitTests' with: 'PetitTests-JanKurs.65';			package: 'PetitAnalyzer' with: 'PetitAnalyzer-JanKurs.48';			package: 'PetitGui' with: 'PetitGui-TudorGirba.147';			package: 'PetitSmalltalk' with: 'PetitSmalltalk-JanKurs.78';			package: 'PetitCSV' with: 'PetitCSV-tg.7';			package: 'PetitJson' with: 'PetitJson-JanKurs.9';			package: 'PetitMSE' with: 'PetitMSE-AndreHora.21';			package: 'PetitManifestMf' with: 'PetitManifestMf-JanKurs.10';			package: 'PetitRegex' with: 'PetitRegex-JanKurs.30';			package: 'PetitXPath' with: 'PetitXPath-EstebanLorenzano.7';			package: 'PetitXml' with: 'PetitXml-JanKurs.36';			package: 'PetitIslands' with: 'PetitIslands-JanKurs.18';			package: 'PetitIndent' with: 'PetitIndent-JanKurs.1';			package: 'Factorial-Language' with: 'Factorial-Language-lr.6'. ].! !"ConfigurationOfPetitParser"!----SNAPSHOT----2016-03-01T00:27:09.912745+01:00 Pharo4.0.image priorSource: 539779!----SNAPSHOT----2016-03-01T00:27:15.210745+01:00 Pharo4.0.image priorSource: 572091!!PPScriptingTest commentStamp: '<historical>' prior: 0!These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html!!PPStream commentStamp: '<historical>' prior: 0!A positional stream implementation used for parsing. It overrides some methods for optimization reasons.!!PPFailure commentStamp: '<historical>' prior: 0!The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	<String>	The error message of this failure.	position	<Integer>	The position of this failure in the input stream.!!PPMemento commentStamp: '<historical>' prior: 0!PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	<Object>	The cached result.	count	<Integer>	The number of recursive cycles followed.	position	<Integer>	The position of the cached result in the input stream.!!PPParser commentStamp: '<historical>' prior: 0!An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	<Dictionary>	Stores additional state in the parser object.!!PPDelegateParser commentStamp: '<historical>' prior: 0!A parser that delegates to another parser.Instance Variables:	parser	<PPParser>	The parser to delegate to.!!PPActionParser commentStamp: '<historical>' prior: 0!A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	<BlockClosure>	The action block to be executed.!!PPWrappingParser commentStamp: '<historical>' prior: 0!A parser that performs an action block upon activation with the stream and a continuation block.!!PPAndParser commentStamp: 'TudorGirba 2/27/2011 22:22' prior: 0!The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].!!PPCompositeParser commentStamp: 'lr 12/4/2009 18:38' prior: 0!A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.!!PPEndOfInputParser commentStamp: 'lr 4/18/2008 13:46' prior: 0!A parser that succeeds only at the end of the input stream.!!PPExpressionParser commentStamp: '<historical>' prior: 0!A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==> [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==> [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	<Dictionary>	The operators defined in the current group.!!PPFlattenParser commentStamp: 'lr 11/22/2009 13:09' prior: 0!A parser that answers a flat copy of the range my delegate parses.!!PPTokenParser commentStamp: 'lr 2/25/2013 23:31' prior: 0!A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	<PPToken class>	The token sub-class to be used.!!PPMemoizedParser commentStamp: '<historical>' prior: 0!A memoized parser, for refraining redundant computations.Instance Variables:	stream	<PositionableStream>	The stream of the associated memento objects.	buffer	<Array of: PPMemento>	The buffer of memento objects.!!PPNotParser commentStamp: '<historical>' prior: 0!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PPOptionalParser commentStamp: 'lr 4/3/2011 14:46' prior: 0!A parser that optionally parsers its delegate, or answers nil.!!PPRepeatingParser commentStamp: 'lr 4/3/2011 14:45' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	<Integer>	The minimum number of repetitions.	max	<Integer>	The maximum number of repetitions.!!PPLimitedRepeatingParser commentStamp: 'lr 4/3/2011 14:37' prior: 0!An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	<PPParser>	The parser to complete the input with.!!PPGreedyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==> [ :each | OrderedCollection new ])).	^ parser ==> [ :rest | rest asArray ]!!PPLazyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 0!A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==> [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==> [ :rest | rest asArray ]!!PPPossessiveRepeatingParser commentStamp: 'lr 4/3/2011 14:35' prior: 0!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).!!PPTrimmingParser commentStamp: 'lr 4/6/2010 19:27' prior: 0!A parser that silently consumes spaces before and after the delegate parser.!!PPEpsilonParser commentStamp: 'lr 5/15/2008 15:09' prior: 0!A parser that consumes nothing and always succeeds.!!PPFailingParser commentStamp: '<historical>' prior: 0!A parser that consumes nothing and always fails.Instance Variables:	message <String>	The failure message.!!PPListParser commentStamp: '<historical>' prior: 0!Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	<SequenceableCollection of: PPParser>	A sequence of other parsers to delegate to.!!PPChoiceParser commentStamp: 'lr 4/18/2008 15:35' prior: 0!A parser that uses the first parser that succeeds.!!PPSequenceParser commentStamp: 'lr 4/18/2008 15:34' prior: 0!A parser that parses a sequence of parsers.!!PPLiteralParser commentStamp: '<historical>' prior: 0!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	<Object>	The literal object to be parsed.	message	<String>	The error message to be generated.!!PPLiteralObjectParser commentStamp: '<historical>' prior: 0!A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.!!PPLiteralSequenceParser commentStamp: 'lr 12/4/2009 18:39' prior: 0!A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.!!PPPluggableParser commentStamp: '<historical>' prior: 0!A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	<BlockClosure>	The pluggable one-argument block.!!PPPredicateParser commentStamp: '<historical>' prior: 0!An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	<BlockClosure>	The block testing for the predicate.	predicateMessage	<String>	The error message of the predicate.	negated	<BlockClosure>	The block testing for the negation of the predicate.	negatedMessage	<String>	The error message of the negated predicate.!!PPPredicateObjectParser commentStamp: '<historical>' prior: 0!A parser that accepts if a given predicate on one element of the input sequence holds.!!PPPredicateSequenceParser commentStamp: '<historical>' prior: 0!A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	<Integer>	The number of elements to consume.!!PPUnresolvedParser commentStamp: 'lr 11/28/2009 18:50' prior: 0!This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.!!PPToken commentStamp: 'lr 2/25/2013 23:34' prior: 0!PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection, its start and stop position and its parse value.Instance Variables:	collection	<SequenceableCollection>	The collection this token comes from.	start	<Integer>	The start position in the collection.	stop	<Integer>	The stop position in the collection.	value <Object>	The parse result.!----STARTUP----2016-03-01T09:18:17.318169+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!SequenceableCollection methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ PPStream on: self! !!Character methodsFor: '*petitparser-core-operators' stamp: 'lr 6/12/2010 09:04'!- aCharacter	"Create a range of characters between the receiver and the argument."		^ PPPredicateObjectParser between: self and: aCharacter! !!Character methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser that accepts the receiving character."		^ PPLiteralObjectParser on: self! !!PPParserResource methodsFor: 'accessing' stamp: 'lr 9/15/2010 12:12'!parserAt: aParserClass	"Answer a cached instance of aParserClass."		^ parsers at: aParserClass name ifAbsentPut: [ aParserClass new ]! !!PPParserResource methodsFor: 'running' stamp: 'lr 3/29/2010 15:20'!setUp	super setUp.	parsers := Dictionary new! !!Stream methodsFor: '*petitparser-core-converting' stamp: 'lr 4/8/2010 14:46'!asPetitStream	^ self contents asPetitStream! !!Symbol methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a predicate parser named after the receiving symbol. Possible symbols are the method selectors on the class-side of PPPredicateObjectParser."	^ PPPredicateObjectParser perform: self! !!String methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser that accepts the receiving string."	^ PPLiteralSequenceParser on: self! !!PPAbstractParserTest class methodsFor: 'testing' stamp: 'lr 1/12/2011 21:23'!isAbstract	^ self name = #PPAbstractParserTest! !!PPAbstractParserTest class methodsFor: 'accessing' stamp: 'lr 6/12/2010 08:22'!packageNamesUnderTest	^ #('PetitParser' 'PetitTests')! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:50'!assert: aParser fail: aCollection	^ self assert: aParser fail: aCollection end: 0! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser fail: aCollection end: anInteger	| stream result |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	result := aParser parse: stream.	self 		assert: result isPetitFailure		description: 'Parser did not fail'.	self		assert: stream position = anInteger		description: 'Parser failed at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection	^ self assert: aParser parse: aCollection to: nil end: aCollection size ! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection end: anInteger	^ self assert: aParser parse: aCollection to: nil end: anInteger! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'DamienPollet 8/11/2011 01:49'!assert: aParser parse: aCollection to: anObject	^ self assert: aParser parse: aCollection to: anObject end: aCollection size ! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'lr 2/26/2013 00:43'!assert: aParser parse: aCollection to: aTargetObject end: anInteger	| stream result |	self 		assert: aParser isPetitParser		description: 'Parser invalid'.	stream := aCollection asPetitStream.	result := aParser parse: stream.	aTargetObject isNil		ifTrue: [ self deny: result isPetitFailure ]		ifFalse: [ self assert: result = aTargetObject ].	self 		assert: stream position = anInteger		description: 'Parser accepted at wrong position'.	^ result! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'lr 2/26/2013 00:43'!assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger	^ self assert: aParser parse: aCollection toToken: aStartInteger stop: aStopInteger end: aCollection size! !!PPAbstractParserTest methodsFor: 'utilities' stamp: 'lr 2/26/2013 00:42'!assert: aParser parse: aParserObject toToken: aStartInteger stop: aStopInteger end: anEndInteger	| token |	token := self assert: aParser parse: aParserObject to: nil end: anEndInteger.	self assert: (token isKindOf: PPToken).	self assert: (token start = aStartInteger).	self assert: (token stop = aStopInteger).	^ token! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!comment	^ ($" asParser , $" asParser negate star , $" asParser) flatten! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!identifier	^ (#letter asParser , #word asParser star) flatten! !!PPComposedTest methodsFor: 'accessing' stamp: 'lr 2/8/2010 16:44'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testComment	self assert: self comment parse: '""' to: '""'.	self assert: self comment parse: '"a"' to: '"a"'.	self assert: self comment parse: '"ab"' to: '"ab"'.	self assert: self comment parse: '"abc"' to: '"abc"'.	self assert: self comment parse: '""a' to: '""' end: 2.	self assert: self comment parse: '"a"a' to: '"a"' end: 3.	self assert: self comment parse: '"ab"a' to: '"ab"' end: 4.	self assert: self comment parse: '"abc"a' to: '"abc"' end: 5.	self assert: self comment fail: '"'.	self assert: self comment fail: '"a'.	self assert: self comment fail: '"aa'.	self assert: self comment fail: 'a"'.	self assert: self comment fail: 'aa"'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 7/6/2009 08:34'!testDoubledString	| parser |	parser := ($' asParser , (($' asParser , $' asParser) / $' asParser negate) star flatten , $' asParser) 		==> [ :nodes | nodes second copyReplaceAll: '''''' with: '''' ].	self assert: parser parse: '''''' to: ''.	self assert: parser parse: '''a''' to: 'a'.	self assert: parser parse: '''ab''' to: 'ab'.	self assert: parser parse: '''a''''b''' to: 'a''b'.	self assert: parser parse: '''a''''''''b''' to: 'a''''b'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 12/5/2010 14:25'!testEvenNumber	"Create a grammar that parses an even number of a's and b's."		| a as b bs s |	a := $a asParser ==> [ :char | as := as + 1 ].	b := $b asParser ==> [ :char | bs := bs + 1 ].	s := (a / b) star >=> [ :stream :cc |		as := bs := 0.		cc value.		(as even and: [ bs even ])			ifFalse: [ PPFailure message: 'Even number of a and b expected' at: 0 ] ].	self assert: s fail: 'a' end: 1.	self assert: s fail: 'b' end: 1.	self assert: s fail: 'ab' end: 2.	self assert: s fail: 'ba' end: 2.	self assert: s fail: 'aaa' end: 3.	self assert: s fail: 'bbb' end: 3.	self assert: s fail: 'aab' end: 3.	self assert: s fail: 'abb' end: 3.		self assert: s parse: ''.	self assert: s parse: 'aa'.	self assert: s parse: 'bb'.	self assert: s parse: 'aaaa'.	self assert: s parse: 'aabb'.	self assert: s parse: 'abab'.	self assert: s parse: 'baba'.	self assert: s parse: 'bbaa'.	self assert: s parse: 'bbbb'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testIdentifier	self assert: self identifier parse: 'a' to: 'a'.	self assert: self identifier parse: 'a1' to: 'a1'.	self assert: self identifier parse: 'a12' to: 'a12'.	self assert: self identifier parse: 'ab' to: 'ab'.	self assert: self identifier parse: 'a1b' to: 'a1b'.	self assert: self identifier parse: 'a_' to: 'a' end: 1.	self assert: self identifier parse: 'a1-' to: 'a1' end: 2.	self assert: self identifier parse: 'a12+' to: 'a12' end: 3.	self assert: self identifier parse: 'ab^' to: 'ab' end: 2.	self assert: self identifier parse: 'a1b*' to: 'a1b' end: 3.	self assert: self identifier fail: ''.	self assert: self identifier fail: '1'.	self assert: self identifier fail: '1a'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:11'!testIfThenElse	"S ::= if C then S else S | if C then S | X"	| start if then else cond expr parser |	start := PPDelegateParser new.	if := 'if' asParser token trim.	then := 'then' asParser token trim.	else := 'else' asParser token trim.	cond := 'C' asParser token trim.	expr := 'X' asParser token trim.	start setParser: (if , cond , then , start , else , start) / (if , cond , then , start) / expr.	parser := start end.	self assert: parser parse: 'X'.	self assert: parser parse: 'if C then X'.	self assert: parser parse: 'if C then X else X'.	self assert: parser parse: 'if C then if C then X'.	self assert: parser parse: 'if C then if C then X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X'.	self assert: parser parse: 'if C then if C then X else X else if C then X else X'.	self assert: parser fail: 'if C'.	self assert: parser fail: 'if C else X'.	self assert: parser fail: 'if C then if C'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:09'!testLeftRecursion	"S ::= S 'x' S / '1'"		| parser |	parser := PPDelegateParser new.	parser setParser: ((parser , $x asParser , parser) / $1 asParser) memoized flatten.	self assert: parser parse: '1' to: '1'.	self assert: parser parse: '1x1' to: '1x1'.	self assert: parser parse: '1x1x1' to: '1x1x1'.	self assert: parser parse: '1x1x1x1' to: '1x1x1x1'.	self assert: parser parse: '1x1x1x1x1' to: '1x1x1x1x1'.	self assert: parser parse: '1x1x1x1x1x1' to: '1x1x1x1x1x1'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 2/25/2013 23:50'!testListOfIntegers	"S ::= S , number | number"		| number list parser |	number := #digit asParser plus flatten trim		==> [ :node | node asInteger ].	list := (number separatedBy: $, asParser token trim)		==> [ :node | node select: [ :each | each isInteger ] ].	parser := list end.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1,2' to: (1 to: 2) asArray.	self assert: parser parse: '1,2,3' to: (1 to: 3) asArray.	self assert: parser parse: '1,2,3,4' to: (1 to: 4) asArray.	self assert: parser parse: '1,2,3,4,5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1, 2' to: (1 to: 2) asArray.	self assert: parser parse: '1, 2, 3' to: (1 to: 3) asArray.	self assert: parser parse: '1, 2, 3, 4' to: (1 to: 4) asArray.	self assert: parser parse: '1, 2, 3, 4, 5' to: (1 to: 5) asArray.	self assert: parser parse: '1' to: (1 to: 1) asArray.	self assert: parser parse: '1 ,2' to: (1 to: 2) asArray.	self assert: parser parse: '1 ,2 ,3' to: (1 to: 3) asArray.	self assert: parser parse: '1 ,2 ,3 ,4' to: (1 to: 4) asArray.	self assert: parser parse: '1 ,2 ,3 ,4 ,5' to: (1 to: 5) asArray.		self assert: parser fail: ''.	self assert: parser fail: ','.	self assert: parser fail: '1,'.	self assert: parser fail: '1,,2'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:09'!testNestedComments	"C ::= B I* E"	"I ::= !!E (C | T)"	"B ::= /*"	"E ::= */"	"T ::= ."		| begin end any inside parser |	begin := '/*' asParser.	end := '*/' asParser.	any := #any asParser.		parser := PPDelegateParser new.	inside := end not , (parser / any).	parser setParser: begin , inside star , end.		self assert: parser parse: '/*ab*/cd' end: 6.	self assert: parser parse: '/*a/*b*/c*/'.	self assert: parser fail: '/*a/*b*/c'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/8/2010 16:44'!testNumber	self assert: self number parse: '1' to: '1'.	self assert: self number parse: '12' to: '12'.	self assert: self number parse: '12.3' to: '12.3'.	self assert: self number parse: '12.34' to: '12.34'.	self assert: self number parse: '1..' to: '1' end: 1.	self assert: self number parse: '12-' to: '12' end: 2.	self assert: self number parse: '12.3.' to: '12.3' end: 4.	self assert: self number parse: '12.34.' to: '12.34' end: 5.		self assert: self number parse: '-1' to: '-1'.	self assert: self number parse: '-12' to: '-12'.	self assert: self number parse: '-12.3' to: '-12.3'.	self assert: self number parse: '-12.34' to: '-12.34'.		self assert: self number fail: ''.	self assert: self number fail: '-'.	self assert: self number fail: '.'.	self assert: self number fail: '.1'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testPalindrome	"S0 ::= a S1 a | b S1 b | ...	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: ($a asParser , s1 , $a asParser)		/ ($b asParser , s1 , $b asParser)		/ ($c asParser , s1 , $c asParser).		s1 setParser: s0 / nil asParser.	parser := s0 flatten end.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'bb' to: 'bb'.	self assert: parser parse: 'cc' to: 'cc'.		self assert: parser parse: 'abba' to: 'abba'.	self assert: parser parse: 'baab' to: 'baab'.	self assert: parser parse: 'abccba' to: 'abccba'.	self assert: parser parse: 'abaaba' to: 'abaaba'.	self assert: parser parse: 'cbaabc' to: 'cbaabc'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'abccbb'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testParseAaaBbb	"S0 ::= a S1 b	 S1 ::= S0 | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := PPDelegateParser new.	s0 setParser: $a asParser , s1 , $b asParser.	s1 setParser: s0 / nil asParser.	parser := s0 flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aabb' to: 'aabb'.	self assert: parser parse: 'aaabbb' to: 'aaabbb'.	self assert: parser parse: 'aaaabbbb' to: 'aaaabbbb'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'aabbb' to: 'aabb' end: 4.	self assert: parser parse: 'aaabbbb' to: 'aaabbb' end: 6.	self assert: parser parse: 'aaaabbbbb' to: 'aaaabbbb' end: 8.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.	self assert: parser fail: 'aab'.	self assert: parser fail: 'aaabb'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:10'!testParseAaaaaa	"S ::= a a S | epsilon"		| s0 s1 parser |	s0 := PPDelegateParser new.	s1 := $a asParser , $a asParser , s0.	s0 setParser: s1 / nil asParser.	parser := s0 flatten.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 'aaaa' to: 'aaaa'.	self assert: parser parse: 'aaaaaa' to: 'aaaaaa'.	self assert: parser parse: 'a' to: '' end: 0.	self assert: parser parse: 'aaa' to: 'aa' end: 2.	self assert: parser parse: 'aaaaa' to: 'aaaa' end: 4.	self assert: parser parse: 'aaaaaaa' to: 'aaaaaa' end: 6! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 9/18/2008 09:26'!testParseAbAbAb	"S ::= (A B)+"		| parser |	parser := ($a asParser , $b asParser) plus flatten.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'abab' to: 'abab'.	self assert: parser parse: 'ababab' to: 'ababab'.	self assert: parser parse: 'abababab' to: 'abababab'.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser parse: 'ababa' to: 'abab' end: 4.	self assert: parser parse: 'abababb' to: 'ababab' end: 6.	self assert: parser parse: 'ababababa' to: 'abababab' end: 8.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'bab'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 9/18/2008 09:26'!testParseAbabbb	"S ::= (A | B)+"	| parser |	parser := ($a asParser / $b asParser) plus flatten.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'b' to: 'b'.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'ba' to: 'ba'.	self assert: parser parse: 'aaa' to: 'aaa'.	self assert: parser parse: 'aab' to: 'aab'.	self assert: parser parse: 'aba' to: 'aba'.	self assert: parser parse: 'baa' to: 'baa'.	self assert: parser parse: 'abb' to: 'abb'.	self assert: parser parse: 'bab' to: 'bab'.	self assert: parser parse: 'bba' to: 'bba'.	self assert: parser parse: 'bbb' to: 'bbb'.	self assert: parser parse: 'ac' to: 'a' end: 1.	self assert: parser parse: 'bc' to: 'b' end: 1.	self assert: parser parse: 'abc' to: 'ab' end: 2.	self assert: parser parse: 'bac' to: 'ba' end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPComposedTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:11'!testParseAnBnCn	"PEGs for a non context- free language: 				a^n , b^n , c^n			S <- &P1 P2 	P1 <- AB 'c' 	AB <- 'a' AB 'b' / epsilon	P2 <- 'a'* BC end	BC <- 'b' BC 'c' / epsilon"		| s p1 ab p2 bc |	s := PPDelegateParser new.	p1 := PPDelegateParser new.	ab := PPDelegateParser new.	p2 := PPDelegateParser new.	bc := PPDelegateParser new.		s setParser: (p1 and , p2 end) flatten.	p1 setParser: ab , $c asParser.	ab setParser: ($a asParser , ab , $b asParser) optional.	p2 setParser: $a asParser star , bc.	bc setParser: ($b asParser , bc , $c asParser) optional.		self assert: s parse: 'abc' to: 'abc'.	self assert: s parse: 'aabbcc' to: 'aabbcc'.	self assert: s parse: 'aaabbbccc' to: 'aaabbbccc'.	self assert: s fail: 'bc'.	self assert: s fail: 'ac'.	self assert: s fail: 'ab'.	self assert: s fail: 'abbcc'.	self assert: s fail: 'aabcc'.	self assert: s fail: 'aabbc'! !!PPComposedTest methodsFor: 'testing-examples' stamp: 'lr 2/25/2013 23:51'!testReturn	| number spaces return |	number := #digit asParser plus flatten.	spaces := #space asParser star.	return := (spaces , $^ asParser token , spaces , number)		==> [ :nodes | Array with: #return with: (nodes at: 4) ].	self assert: return parse: '^1' to: #(return '1').	self assert: return parse: '^12' to: #(return '12').	self assert: return parse: '^ 123' to: #(return '123').	self assert: return parse: '^  1234' to: #(return '1234').		self assert: return fail: '1'.	self assert: return fail: '^'! !!PPArithmeticParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:53'!parserClass	^ PPArithmeticParser! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/30/2008 17:21'!testAdd	self assert: '1 + 2' is: 3.	self assert: '2 + 1' is: 3.	self assert: '1 + 2.3' is: 3.3.	self assert: '2.3 + 1' is: 3.3.	self assert: '1 + -2' is: -1.	self assert: '-2 + 1' is: -1! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 10:23'!testAddMany	self assert: '1' is: 1.	self assert: '1 + 2' is: 3.	self assert: '1 + 2 + 3' is: 6.	self assert: '1 + 2 + 3 + 4' is: 10.	self assert: '1 + 2 + 3 + 4 + 5' is: 15! !!PPArithmeticParserTest methodsFor: 'testing-expression' stamp: 'lr 4/21/2008 10:03'!testBrackets	self assert: '(1)' is: 1.	self assert: '(1 + 2)' is: 3.		self assert: '((1))' is: 1.	self assert: '((1 + 2))' is: 3.	self assert: '2 * (3 + 4)' is: 14.	self assert: '(2 + 3) * 4' is: 20.	self assert: '6 / (2 + 4)' is: 1.	self assert: '(2 + 6) / 2' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 09:32'!testDiv	self assert: '12 / 3' is: 4.	self assert: '-16 / -4' is: 4! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:46'!testDivMany	self assert: '100 / 2' is: 50.	self assert: '100 / 2 / 2' is: 25.	self assert: '100 / 2 / 2 / 5' is: 5.	self assert: '100 / 2 / 2 / 5 / 5' is: 1	! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 09:31'!testMul	self assert: '2 * 3' is: 6.	self assert: '2 * -4' is: -8! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/21/2008 10:16'!testMulMany	self assert: '1 * 2' is: 2.	self assert: '1 * 2 * 3' is: 6.	self assert: '1 * 2 * 3 * 4' is: 24.	self assert: '1 * 2 * 3 * 4 * 5' is: 120! !!PPArithmeticParserTest methodsFor: 'testing' stamp: 'lr 4/21/2008 09:32'!testNum	self assert: '0' is: 0.	self assert: '0.0' is: 0.0.	self assert: '1' is: 1.	self assert: '1.2' is: 1.2.	self assert: '34' is: 34.	self assert: '56.78' is: 56.78.	self assert: '-9' is: -9.	self assert: '-9.9' is: -9.9! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:28'!testPow	self assert: '2 ^ 3' is: 8.	self assert: '-2 ^ 3' is: -8.	self assert: '-2 ^ -3' is: -0.125! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 7/3/2008 15:45'!testPowMany	self assert: '4 ^ 3' is: 64.	self assert: '4 ^ 3 ^ 2' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1' is: 262144.	self assert: '4 ^ 3 ^ 2 ^ 1 ^ 0' is: 262144! !!PPArithmeticParserTest methodsFor: 'testing-expression' stamp: 'lr 4/21/2008 10:00'!testPriority	self assert: '2 * 3 + 4' is: 10.	self assert: '2 + 3 * 4' is: 14.	self assert: '6 / 3 + 4' is: 6.	self assert: '2 + 6 / 2' is: 5! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 8/14/2010 13:38'!testSub	self assert: '1 - 2' is: -1.	self assert: '1.2 - 1.2' is: 0.	self assert: '1 - -2' is: 3.	self assert: '-1 - -2' is: 1! !!PPArithmeticParserTest methodsFor: 'testing-operations' stamp: 'lr 4/28/2008 11:56'!testSubMany	self assert: '1' is: 1.	self assert: '1 - 2' is: -1.	self assert: '1 - 2 - 3' is: -4.	self assert: '1 - 2 - 3 - 4' is: -8.	self assert: '1 - 2 - 3 - 4 - 5' is: -13! !!PPExpressionParserTest class methodsFor: 'testing' stamp: 'lr 4/6/2010 19:40'!shouldInheritSelectors	^ true! !!PPExpressionParserTest methodsFor: 'accessing' stamp: 'lr 2/25/2013 23:50'!parserInstance	| expression parens number |	expression := PPExpressionParser new.	parens := $( asParser trim , expression , $) asParser trim		==> [ :value | value second ].	number := (#digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim		==> [ :value | value asNumber ].	expression term: parens / number.	expression		group: [ :g |			g prefix: $- asParser trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser trim do: [ :a :op :b | a * b ].			g left: $/ asParser trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser trim do: [ :a :op :b | a + b ].			g left: $- asParser trim do: [ :a :op :b | a - b ] ].	^ expression end! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:13'!testPostfixAdd	self assert: '0++' is: 1.	self assert: '0++++' is: 2.	self assert: '0++++++' is: 3.	self assert: '0+++1' is: 2.	self assert: '0+++++1' is: 3.	self assert: '0+++++++1' is: 4! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:11'!testPostfixSub	self assert: '1--' is: 0.	self assert: '2----' is: 0.	self assert: '3------' is: 0.	self assert: '2---1' is: 0.	self assert: '3-----1' is: 0.	self assert: '4-------1' is: 0.! !!PPExpressionParserTest methodsFor: 'testing' stamp: 'FirstnameLastname 11/26/2009 22:13'!testPrefixNegate	self assert: '1' is: 1.	self assert: '-1' is: -1.	self assert: '--1' is: 1.	self assert: '---1' is: -1! !!PPCompositeParserTest class methodsFor: 'testing' stamp: 'lr 10/4/2009 17:09'!isAbstract	^ self name = #PPCompositeParserTest! !!PPCompositeParserTest class methodsFor: 'accessing' stamp: 'lr 3/29/2010 15:21'!resources	^ Array with: PPParserResource! !!PPCompositeParserTest methodsFor: 'utilities' stamp: 'lr 11/29/2010 11:20'!assert: aCollection is: anObject	self parse: aCollection.	self		assert: result = anObject		description: 'Got: ' , result printString , '; Expected: ' , anObject printString		resumable: true! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'lr 11/18/2011 19:45'!fail: aString rule: aSymbol 	| production |	production := self parserInstanceFor: aSymbol.	result := production end parse: aString.	self		assert: result isPetitFailure		description: 'Able to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'lr 11/29/2010 11:26'!parse: aString 	^ self parse: aString rule: #start! !!PPCompositeParserTest methodsFor: 'parsing' stamp: 'lr 11/18/2011 19:45'!parse: aString rule: aSymbol	| production |	production := self parserInstanceFor: aSymbol.	result := production end parse: aString.	self		deny: result isPetitFailure		description: 'Unable to parse ' , aString printString.	^ result! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:52'!parserClass	self subclassResponsibility! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'lr 3/29/2010 15:21'!parserInstance	^ PPParserResource current parserAt: self parserClass! !!PPCompositeParserTest methodsFor: 'accessing' stamp: 'lr 11/18/2011 19:44'!parserInstanceFor: aSymbol	^ aSymbol = #start		ifTrue: [ self parserInstance ]		ifFalse: [			self parserInstance				productionAt: aSymbol 				ifAbsent: [ self error: 'Production ' , self parserClass name , '>>' , aSymbol printString , ' not found.' ] ]! !!PPCompositeParserTest methodsFor: 'running' stamp: 'FirstnameLastname 11/26/2009 21:48'!setUp	super setUp.	parser := self parserInstance! !!PPCompositeParserTest methodsFor: 'running' stamp: 'lr 11/29/2010 11:19'!tearDown	super tearDown.	parser := result := nil! !!PPLambdaParserTest methodsFor: 'accessing' stamp: 'FirstnameLastname 11/26/2009 21:53'!parserClass	^ PPLambdaParser! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:38'!testAbstraction	self assert: '\x.y' is: #('x' 'y').	self assert: '\x.\y.z' is: #('x' ('y' 'z'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testAnd	self assert: self parserClass and = #('p' ('q' (('p' 'q') 'p')))! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:38'!testApplication	self assert: '(x x)' is: #('x' 'x').	self assert: '(x y)' is: #('x' 'y').	self assert: '((x y) z)' is: #(('x' 'y') 'z').	self assert: '(x (y z))' is: #('x' ('y' 'z'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testFalse	self assert: self parserClass false = #('x' ('y' 'y'))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testIfThenElse	self assert: self parserClass ifthenelse = #('p' 'p')! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testNot	self assert: self parserClass not = #('p' ('a' ('b' (('p' 'b') 'a'))))! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testOr	self assert: self parserClass or = #('p' ('q' (('p' 'p') 'q')))! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/17/2013 08:58'!testParseOnError	| beenHere |	result := self parserClass		parse: '\x.y'		onError: [ self fail ].	self assert: result = #('x' 'y').	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ beenHere := true ].	self assert: beenHere.	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere.	self assert: (result message findString: '$(') > 0.	self assert: (result message findString: 'expected') > 0.	self assert: (result position = 0).	beenHere := false.	result := self parserClass		parse: '\x.'		onError: [ :msg :pos | 			self assert: (msg findString: '$(') > 0.			self assert: (msg findString: 'expected') > 0.			self assert: (pos = 0).			beenHere := true ].	self assert: result.	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/17/2013 08:56'!testParseStartingAtOnError	| beenHere |	result := self parserClass		parse: 'x'		startingAt: #variable		onError: [ self fail ].	self assert: result = 'x'.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ beenHere := true ].	self assert: beenHere.		beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :fail | beenHere := true. fail ].	self assert: beenHere.	self assert: result message = 'letter expected'.	self assert: result position = 0.	beenHere := false.	result := self parserClass		parse: '\'		startingAt: #variable		onError: [ :msg :pos | 			self assert: msg = 'letter expected'.			self assert: pos = 0.			beenHere := true ].	self assert: beenHere! !!PPLambdaParserTest methodsFor: 'testing-utilities' stamp: 'FirstnameLastname 11/26/2009 21:56'!testProductionAt	self assert: (parser productionAt: #foo) isNil.	self assert: (parser productionAt: #foo ifAbsent: [ true ]).		self assert: (parser productionAt: #start) notNil.	self assert: (parser productionAt: #start ifAbsent: [ true ]) notNil.		self assert: (parser productionAt: #variable) notNil.	self assert: (parser productionAt: #variable ifAbsent: [ true ]) notNil! !!PPLambdaParserTest methodsFor: 'testing-curch' stamp: 'FirstnameLastname 11/26/2009 21:53'!testTrue	self assert: self parserClass true = #('x' ('y' 'x'))! !!PPLambdaParserTest methodsFor: 'testing' stamp: 'lr 4/30/2008 09:33'!testVariable	self assert: 'x' is: 'x'.	self assert: 'xy' is: 'xy'.	self assert: 'x12' is: 'x12'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 5/2/2010 18:18'!testCharacter	| parser |	parser := $a asParser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/29/2011 20:38'!testChoice	| parser |	parser := #(1 2) asChoiceParser.	self assert: parser parse: #(1) to: 1.	self assert: parser parse: #(2) to: 2.	self assert: parser parse: #(1 2) to: 1 end: 1.	self assert: parser parse: #(2 1) to: 2 end: 1.	self assert: parser fail: #().	self assert: parser fail: #(3)! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 5/5/2010 14:03'!testClosure	| parser |	parser := [ :stream | stream upTo: $s ] asParser.	self assert: parser parse: '' to: ''.	self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: 'aa' to: 'aa'.	self assert: parser parse: 's' to: ''.	self assert: parser parse: 'as' to: 'a'.	self assert: parser parse: 'aas' to: 'aa'.	self assert: parser parse: 'sa' to: '' end: 1.	self assert: parser parse: 'saa' to: '' end: 1.		parser := [ :stream | stream upTo: $s. PPFailure message: 'stream' at: stream position ] asParser.	self assert: parser fail: ''.	self assert: parser fail: 's'.	self assert: parser fail: 'as'	! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/20/2009 15:29'!testEpsilon	| parser |	parser := nil asParser.	self assert: parser asParser = parser! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/20/2009 15:30'!testParser	| parser |	parser := $a asParser.	self assert: parser asParser = parser! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 9/17/2008 22:48'!testRange	| parser |	parser := $a - $c.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser fail: 'd'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 11/29/2011 20:40'!testSequence	| parser |	parser := #(1 2) asSequenceParser.	self assert: parser parse: #(1 2) to: #(1 2).	self assert: parser parse: #(1 2 3) to: #(1 2) end: 2.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 1).	self assert: parser fail: #(1 1 2)! !!PPExtensionTest methodsFor: 'testing-stream' stamp: 'lr 9/30/2010 11:12'!testStream	| stream |	stream := 'abc' readStream asPetitStream.	self assert: (stream class = PPStream).	self assert: (stream printString = '·abc').	self assert: (stream peek) = $a.	self assert: (stream uncheckedPeek = $a).	self assert: (stream next) = $a.	self assert: (stream printString = 'a·bc').	self assert: (stream asPetitStream = stream)! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 5/2/2010 18:18'!testString	| parser |	parser := 'ab' asParser.	self assert: parser parse: 'ab' to: 'ab'.	self assert: parser parse: 'aba' to: 'ab' end: 2.	self assert: parser parse: 'abb' to: 'ab' end: 2.	self assert: parser fail: 'a'.	self assert: parser fail: 'ac'! !!PPExtensionTest methodsFor: 'testing-parser' stamp: 'lr 9/17/2008 22:03'!testSymbol	| parser |	parser := #any asParser.	self assert: parser parse: 'a'.	self assert: parser fail: ''! !!PPExtensionTest methodsFor: 'testing-stream' stamp: 'lr 2/7/2010 20:53'!testText	| stream |	stream := 'abc' asText asPetitStream.	self assert: stream class = PPStream! !!PPObjectTest methodsFor: 'parsers' stamp: 'lr 12/9/2010 10:25'!integer	^ PPPredicateObjectParser		on: [ :each | each isInteger ]		message: 'integer expected'! !!PPObjectTest methodsFor: 'parsers' stamp: 'lr 10/30/2010 12:45'!string	^ PPPredicateObjectParser		on: [ :each | each isString ]		message: 'string expected'! !!PPObjectTest methodsFor: 'testing-operators' stamp: 'lr 12/9/2010 10:25'!testChoice	| parser |	parser := self integer / self string.	self assert: parser parse: #(123) to: 123.	self assert: parser parse: #('abc') to: 'abc'! !!PPObjectTest methodsFor: 'testing-fancy' stamp: 'lr 12/9/2010 10:25'!testFibonacci	"This parser accepts fibonacci sequences with arbitrary start pairs."		| parser |	parser := ((self integer , self integer) end ==> [ :pair | pair first + pair last ])		/ (self integer , (self integer , self integer) and >=> [ :stream :continuation |			| result |			result := continuation value.			(result isPetitFailure or: [ result first + result last first ~= result last last ])				ifFalse: [ parser parseOn: stream ]				ifTrue: [ PPFailure message: 'invalid fibonacci sequence' at: stream position ] ]).	self assert: parser parse: #(1 1) to: 2.	self assert: parser parse: #(1 1 2) to: 3.	self assert: parser parse: #(1 1 2 3) to: 5.	self assert: parser parse: #(1 1 2 3 5) to: 8.	self assert: parser parse: #(1 1 2 3 5 8) to: 13.	self assert: parser parse: #(1 1 2 3 5 8 13) to: 21.	self assert: parser fail: #().	self assert: parser fail: #(1).	self assert: parser fail: #(1 2 3 4) end: 2	! !!PPObjectTest methodsFor: 'testing' stamp: 'lr 12/9/2010 10:25'!testInteger	self assert: self integer parse: #(123) to: 123.	self assert: self integer fail: #('abc')! !!PPObjectTest methodsFor: 'testing-operators' stamp: 'lr 12/9/2010 10:25'!testSequence	| parser |	parser := self integer , self string.	self assert: parser parse: #(123 'abc') to: #(123 'abc').	self assert: parser fail: #(123 456).	self assert: parser fail: #('abc' 'def').	self assert: parser fail: #('abc' 123)	! !!PPObjectTest methodsFor: 'testing' stamp: 'lr 10/30/2010 12:47'!testString	self assert: self string parse: #('abc') to: 'abc'.	self assert: self string fail: #(123)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 5/2/2010 12:22'!testAction	| block parser |	block := [ :char | char asUppercase ].	parser := #any asParser ==> block.	self assert: parser block = block.	self assert: parser parse: 'a' to: $A.	self assert: parser parse: 'b' to: $B! !!PPParserTest methodsFor: 'testing' stamp: 'lr 6/24/2011 06:15'!testAnd	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten and.		self assert: parser parse: 'foobar' to: #('foo' 'bar') end: 3.	self assert: parser fail: 'foobaz'.		parser := 'foo' asParser and.	self assert: parser and = parser! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testAnswer	| parser |	parser := $a asParser answer: $b.		self assert: parser parse: 'a' to: $b.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/2/2009 19:56'!testBlock	| parser |	parser := [ :s | s next ] asParser.		self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: '' to: nil! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 2/7/2010 22:15'!testChildren	| p1 p2 p3 |	p1 := #lowercase asParser.	p2 := p1 ==> #asUppercase.	p3 := PPUnresolvedParser new.	p3 def: p2 / p3.	self assert: p1 children isEmpty.	self assert: p2 children size = 1.	self assert: p3 children size = 2! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/15/2008 09:24'!testChoice	| parser |	parser := $a asParser / $b asParser.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'ba' to: $b end: 1.	self assert: parser fail: ''.	self assert: parser fail: 'c'.	self assert: parser fail: 'ca'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/7/2008 08:58'!testDelimitedBy	| parser |	parser := $a asParser delimitedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).	self assert: parser parse: 'ab' to: #($a $b).	self assert: parser parse: 'abab' to: #($a $b $a $b).	self assert: parser parse: 'ababab' to: #($a $b $a $b $a $b).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a $b) end: 2.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $b $a $b) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/25/2012 16:56'!testDelimitedByWithoutSeparators	| parser |	parser := ($a asParser delimitedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).	self assert: parser parse: 'ab' to: #($a).	self assert: parser parse: 'abab' to: #($a $a).	self assert: parser parse: 'ababab' to: #($a $a $a).		self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abc' to: #($a) end: 2.	self assert: parser parse: 'abac' to: #($a $a) end: 3.	self assert: parser parse: 'ababc' to: #($a $a) end: 4.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 1/29/2010 11:39'!testEndOfInput	| parser |	parser := PPEndOfInputParser on: $a asParser.	self assert: parser end = parser.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''.	self assert: parser fail: 'aa'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/17/2008 22:47'!testEndOfInputAfterMatch	| parser |	parser := 'stuff' asParser end.	self assert: parser parse: 'stuff' to: 'stuff'.	self assert: parser fail: 'stufff'.	self assert: parser fail: 'fluff'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 11/20/2009 15:31'!testEpsilon	| parser |	parser := nil asParser.		self assert: parser parse: '' to: nil.		self assert: parser parse: 'a' to: nil end: 0.	self assert: parser parse: 'ab' to: nil end: 0! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/5/2010 14:10'!testFailing	| parser result |	parser := PPFailingParser message: 'Plonk'.	self assert: parser message = 'Plonk'.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.		result := parser parse: 'a'.	self assert: result message = 'Plonk'.	self assert: result printString = 'Plonk at 0'! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 5/5/2010 13:58'!testFailure	| failure |	failure := PPFailure message: 'Error' at: 3.		self assert: failure message = 'Error'.	self assert: failure position = 3.	self assert: failure isPetitFailure.	self deny: 4 isPetitFailure.	self deny: 'foo' isPetitFailure! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 5/2/2010 12:18'!testFlatten	| parser |	parser := $a asParser flatten.		self assert: parser parse: 'a' to: 'a'.	self assert: parser parse: #($a) to: #($a).		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldLeft2	| parser |	parser := #any asParser star 		foldLeft: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #((a b) c).	self assert: parser parse: #(a b c d) to: #(((a b) c) d).	self assert: parser parse: #(a b c d e) to: #((((a b) c) d) e)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldLeft3	| parser |	parser := #any asParser star 		foldLeft: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #((a b c) d e)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldRight2	| parser |	parser := #any asParser star 		foldRight: [ :a :b | Array with: a with: b ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b) to: #(a b).	self assert: parser parse: #(a b c) to: #(a (b c)).	self assert: parser parse: #(a b c d) to: #(a (b (c d))).	self assert: parser parse: #(a b c d e) to: #(a (b (c (d e))))! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testFoldRight3	| parser |	parser := #any asParser star 		foldRight: [ :a :b :c | Array with: a with: b with: c ].	self assert: parser parse: #(a) to: #a.	self assert: parser parse: #(a b c) to: #(a b c).	self assert: parser parse: #(a b c d e) to: #(a b (c d e))! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:38'!testHasProperty	| parser |	parser := PPParser new.	self deny: (parser hasProperty: #foo).	parser propertyAt: #foo put: 123.	self assert: (parser hasProperty: #foo)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 5/31/2010 19:27'!testListConstructor	| p1 p2 p3 |	p1 := PPChoiceParser with: $a asParser.	p2 := PPChoiceParser with: $a asParser with: $b asParser.	p3 := PPChoiceParser withAll: (Array with: $a asParser with: $b asParser with: $c asParser).		self assert: p1 children size = 1.	self assert: p2 children size = 2.	self assert: p3 children size = 3! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/2/2010 18:20'!testLiteralObject	| parser |	parser := PPLiteralObjectParser 		on: $a		message: 'letter "a" expected'.	self assert: parser literal = $a.	self assert: parser message = 'letter "a" expected'.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'	! !!PPParserTest methodsFor: 'testing' stamp: 'lr 6/1/2010 22:30'!testLiteralObjectCaseInsensitive	| parser |	parser := $a asParser caseInsensitive.		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'B'	! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/15/2010 12:00'!testLiteralSequence	| parser |	parser := PPLiteralSequenceParser 		on: 'abc'		message: 'sequence "abc" expected'.	self assert: parser size = 3.	self assert: parser literal = 'abc'.	self assert: parser message = 'sequence "abc" expected'.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 6/1/2010 22:31'!testLiteralSequenceCaseInsensitive	| parser |	parser := 'abc' asParser caseInsensitive.		self assert: parser parse: 'abc' to: 'abc'.	self assert: parser parse: 'ABC' to: 'ABC'.	self assert: parser parse: 'abC' to: 'abC'.	self assert: parser parse: 'AbC' to: 'AbC'.		self assert: parser fail: 'ab'.	self assert: parser fail: 'abd'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap1	| parser |	parser := #any asParser 		map: [ :a | Array with: a ].	self assert: parser parse: #(a) to: #(a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap2	| parser |	parser := (#any asParser , #any asParser) 		map: [ :a :b | Array with: b with: a ].	self assert: parser parse: #(a b) to: #(b a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMap3	| parser |	parser := (#any asParser , #any asParser , #any asParser)		map: [ :a :b :c | Array with: c with: b with: a ].	self assert: parser parse: #(a b c) to: #(c b a)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMapFail1	self		should: [ #any asParser map: [  ] ]		raise: Error.	self		should: [ #any asParser map: [ :a :b | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 6/24/2011 06:16'!testMapFail2	self		should: [ (#any asParser , #any asParser) map: [ :a | ] ]		raise: Error.	self		should: [ (#any asParser , #any asParser) map: [ :a :b :c | ] ]		raise: Error! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 2/8/2010 00:32'!testMatches	| parser |	parser := $a asParser.		self assert: (parser matches: 'a').	self deny: (parser matches: 'b').		self assert: (parser matches: 'a' readStream).	self deny: (parser matches: 'b' readStream)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 2/8/2010 00:32'!testMatchesIn	| parser result |	parser := $a asParser.		result := parser matchesIn: 'abba'.	self assert: result size = 2.	self assert: result first = $a.	self assert: result last = $a.		result := parser matchesIn: 'baaah'.	self assert: result size = 3.	self assert: result first = $a.	self assert: result last = $a! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/3/2010 15:33'!testMatchesInEmpty	"Empty matches should properly advance and match at each position and at the end."	| parser result |	parser := [ :stream | stream position ] asParser.		result := parser matchesIn: '123'.	self assert: result asArray = #(0 1 2 3)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/3/2010 15:31'!testMatchesInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.		result := parser matchesIn: 'a123b'.	self assert: result size = 2.	self assert: result first = #($1 $2).	self assert: result last = #($2 $3)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 8/16/2011 07:27'!testMatchesSkipIn	| parser result |	parser := $a asParser.		result := parser matchesSkipIn: 'abba'.	self assert: result size = 2.	self assert: result first = $a.	self assert: result last = $a.		result := parser matchesSkipIn: 'baaah'.	self assert: result size = 3.	self assert: result first = $a.	self assert: result last = $a! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 8/16/2011 07:28'!testMatchesSkipInOverlapping	"Matches that overlap should be properly reported."	| parser result |	parser := #digit asParser , #digit asParser.		result := parser matchesSkipIn: 'a123b'.	self assert: result size = 1.	self assert: result first = #($1 $2)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 10/30/2011 12:13'!testMatchingRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size = 3.	self assert: result first = '12'.	self assert: result second = '2'.	self assert: result last = '3'! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 10/30/2011 12:12'!testMatchingSkipRangesIn	| input parser result |	input := 'a12b3'.	parser := #digit asParser plus.	result := parser matchingSkipRangesIn: input.	result := result collect: [ :each | input copyFrom: each first to: each last ].	self assert: result size = 2.	self assert: result first = '12'.	self assert: result last = '3'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/2/2010 12:18'!testMax	| parser |	parser := $a asParser max: 2.	self assert: parser min = 0.	self assert: parser max = 2.	self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2.	self assert: parser parse: 'aaaa' to: #($a $a) end: 2.		self assert: (parser printString endsWith: '[0, 2]')! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:02'!testMaxGreedy	| parser |	parser := #word asParser max: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:03'!testMaxLazy	| parser |	parser := #word asParser max: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abc'.		self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser fail: 'abc1'.		self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser fail: 'abc12'.		self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser fail: 'abc123'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/2/2009 20:35'!testMemoized	| count parser twice |	count := 0.	parser := [ :s | count := count + 1. s next ] asParser memoized.	twice := parser and , parser.		count := 0.	self assert: parser parse: 'a' to: $a.	self assert: count = 1.	count := 0.	self assert: twice parse: 'a' to: #($a $a).	self assert: count = 1.		self assert: parser memoized = parser! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/2/2010 12:18'!testMin	| parser |	parser := $a asParser min: 2.	self assert: parser min = 2.	self assert: parser max > parser min.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).		self assert: (parser printString endsWith: '[2, *]')! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:12'!testMinGreedy	| parser |	parser := #word asParser min: 2 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d $1) end: 5.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e $1) end: 6.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.	self assert: parser parse: 'abcd123' to: #($a $b $c $d $1 $2) end: 6.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e $1 $2) end: 7.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2 $3) end: 5.	self assert: parser parse: 'abc1234' to: #($a $b $c $1 $2 $3) end: 6.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d $1 $2 $3) end: 7.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e $1 $2 $3) end: 8! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 21:15'!testMinLazy	| parser |	parser := #word asParser min: 2 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1' to: #($a $b $c $d $e) end: 5.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde12' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde123' to: #($a $b $c $d $e) end: 5.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser parse: 'abcde1234' to: #($a $b $c $d $e) end: 5! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/2/2010 12:19'!testMinMax	| parser |	parser := $a asParser min: 2 max: 4.	self assert: parser min = 2.	self assert: parser max = 4.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).	self assert: parser parse: 'aaaa' to: #($a $a $a $a).	self assert: parser parse: 'aaaaa' to: #($a $a $a $a) end: 4.	self assert: parser parse: 'aaaaaa' to: #($a $a $a $a) end: 4.		self assert: (parser printString endsWith: '[2, 4]')! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 20:54'!testMinMaxGreedy	| parser |	parser := #word asParser min: 2 max: 4 greedy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2 $3) end: 3.	self assert: parser parse: 'a1234' to: #($a $1 $2 $3) end: 4.	self assert: parser parse: 'ab1234' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc1234' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/3/2011 20:57'!testMinMaxLazy	| parser |	parser := #word asParser min: 2 max: 4 lazy: #digit asParser.		self assert: parser fail: ''.	self assert: parser fail: 'abcde'.		self assert: parser fail: '1'.	self assert: parser fail: 'a1'.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1'.		self assert: parser fail: '12'.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd12' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde12'.		self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1) end: 2.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd123' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde123'.		self assert: parser parse: '1234' to: #($1 $2) end: 2.	self assert: parser parse: 'a1234' to: #($a $1) end: 2.	self assert: parser parse: 'ab1234' to: #($a $b) end: 2.	self assert: parser parse: 'abc1234' to: #($a $b $c) end: 3.	self assert: parser parse: 'abcd1234' to: #($a $b $c $d) end: 4.	self assert: parser fail: 'abcde1234'! !!PPParserTest methodsFor: 'testing-accessing' stamp: 'lr 3/30/2009 16:36'!testNamed	| parser |	parser := PPSequenceParser new.	self assert: parser name isNil.		parser := PPChoiceParser named: 'choice'.	self assert: parser name = 'choice'.		parser := $* asParser name: 'star'.	self assert: parser name = 'star'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/7/2010 20:10'!testNegate	| parser |	parser := 'foo' asParser negate.		self assert: parser parse: 'f' to: $f end: 1.	self assert: parser parse: 'fo' to: $f end: 1.	self assert: parser parse: 'fob' to: $f end: 1.	self assert: parser parse: 'ffoo' to: $f end: 1.		self assert: parser fail: ''.	self assert: parser fail: 'foo'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/26/2010 09:54'!testNot	| parser |	parser := 'foo' asParser flatten , 'bar' asParser flatten not.		self assert: parser parse: 'foobaz' to: #('foo' nil) end: 3.	self assert: parser fail: 'foobar'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:32'!testOptional	| parser |	parser := $a asParser optional.		self assert: parser parse: '' to: nil.	self assert: parser parse: 'a' to: $a.		self assert: parser parse: 'aa' to: $a end: 1.	self assert: parser parse: 'ab' to: $a end: 1.	self assert: parser parse: 'b' to: nil end: 0.	self assert: parser parse: 'bb' to: nil end: 0.	self assert: parser parse: 'ba' to: nil end: 0! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/17/2013 08:54'!testParse	| parser result |	parser := $a asParser.		self assert: (parser parse: 'a') = $a.	self assert: (result := parser parse: 'b') isPetitFailure.	self assert: (result message findString: '$a') > 0.	self assert: (result message findString: 'expected') > 0.	self assert: (result position = 0).		self assert: (parser parse: 'a' readStream) = $a.	self assert: (result := parser parse: 'b' readStream) isPetitFailure.	self assert: (result message findString: '$a') > 0.	self assert: (result message findString: 'expected') > 0.	self assert: (result position = 0)! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 2/7/2010 23:00'!testParseOnError0	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/17/2013 08:56'!testParseOnError1	| parser result seen |	parser := $a asParser.	result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.		result := parser parse: 'b' onError: [ :failure | 		self assert: (failure position = 0).		self assert: (failure message findString: '$a') > 0.		self assert: (failure message findString: 'expected') > 0.		seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 3/17/2013 08:53'!testParseOnError2	| parser result seen |	parser := $a asParser.		result := parser parse: 'a' onError: [ self signalFailure: 'Not supposed to report an error' ].	self assert: result = $a.	result := parser parse: 'b' onError: [ :msg :pos | 		self assert: (msg findString: '$a') > 0.		self assert: (msg findString: 'expected') > 0.		self assert: pos = 0.		seen := true ].	self assert: result.	self assert: seen! !!PPParserTest methodsFor: 'testing-utilities' stamp: 'lr 8/6/2010 19:06'!testParser	| parser |	parser := PPParser new.		self assert: parser isPetitParser.	self deny: 4 isPetitParser.	self deny: 'foo' isPetitParser! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 1/8/2010 12:09'!testPermutation	| parser |	parser := #any asParser , #any asParser , #any asParser.	self assert: (parser permutation: #()) parse: '123' to: #().	self assert: (parser permutation: #(1)) parse: '123' to: #($1).	self assert: (parser permutation: #(1 3)) parse: '123' to: #($1 $3).	self assert: (parser permutation: #(3 1)) parse: '123' to: #($3 $1).	self assert: (parser permutation: #(2 2)) parse: '123' to: #($2 $2).	self assert: (parser permutation: #(3 2 1)) parse: '123' to: #($3 $2 $1).		self should: [ parser permutation: #(0) ] raise: Error.	self should: [ parser permutation: #(4) ] raise: Error.	self should: [ parser permutation: #($2) ] raise: Error! !!PPParserTest methodsFor: 'testing' stamp: 'lr 5/2/2010 12:26'!testPluggable	| block parser |	block := [ :stream | stream position ].	parser := block asParser.	self assert: parser block = block! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:01'!testPlus	| parser |	parser := $a asParser plus.		self assert: parser min = 1.	self assert: parser max > parser min.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'ba'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:01'!testPlusGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusGreedy: limit.		self assert: parser min = 1.	self assert: parser max > parser min.		self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5.! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:01'!testPlusLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser plusLazy: limit.		self assert: parser min = 1.	self assert: parser max > parser min.		self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:41'!testPostCopy	| parser copy |	parser := PPParser new.	parser propertyAt: #foo put: true.	copy := parser copy.	copy propertyAt: #foo put: false.	self assert: (parser propertyAt: #foo).	self deny: (copy propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-accessing' stamp: 'lr 3/17/2013 08:53'!testPrint	| parser |	parser := PPParser new.	self assert: (parser printString findString: 'PPParser') > 0.		parser := PPParser named: 'choice'.	self assert: (parser printString findString: 'PPParser(choice') > 0.		parser := PPLiteralObjectParser on: $a.	self assert: (parser printString findString: '$a') > 0.		parser := PPFailingParser message: 'error'.	self assert: (parser printString findString: 'error') > 0.		parser := PPPredicateObjectParser on: [ :c | true ] message: 'error'.	self assert: (parser printString findString: 'error') > 0! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:36'!testPropertyAt	| parser |	parser := PPParser new.	self should: [ parser propertyAt: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo)! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testPropertyAtIfAbsent	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser propertyAt: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testPropertyAtIfAbsentPut	| parser |	parser := PPParser new.	self assert: (parser propertyAt: #foo ifAbsentPut: [ true ]).	self assert: (parser propertyAt: #foo ifAbsentPut: [ false ])! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testRemoveProperty	| parser |	parser := PPParser new.	self should: [ parser removeProperty: #foo ] raise: Error.	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo)! !!PPParserTest methodsFor: 'testing-properties' stamp: 'lr 4/19/2010 10:37'!testRemovePropertyIfAbsent	| parser |	parser := PPParser new.	self assert: (parser removeProperty: #foo ifAbsent: [ true ]).	parser propertyAt: #foo put: true.	self assert: (parser removeProperty: #foo ifAbsent: [ false ])! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:42'!testSeparatedBy	| parser |	parser := $a asParser separatedBy: $b asParser.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $b $a).	self assert: parser parse: 'ababa' to: #($a $b $a $b $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $b $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $b $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 2/25/2012 16:55'!testSeparatedByWithoutSeparators	| parser |	parser := ($a asParser separatedBy: $b asParser)		withoutSeparators.		self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aba' to: #($a $a).	self assert: parser parse: 'ababa' to: #($a $a $a).		self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'abab' to: #($a $a) end: 3.	self assert: parser parse: 'ac' to: #($a) end: 1.	self assert: parser parse: 'abac' to: #($a $a) end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'c'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/29/2008 11:33'!testSequence	| parser |	parser := $a asParser , $b asParser.		self assert: parser parse: 'ab' to: #($a $b).		self assert: parser parse: 'aba' to: #($a $b) end: 2.	self assert: parser parse: 'abb' to: #($a $b) end: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'aa'.	self assert: parser fail: 'ba'.	self assert: parser fail: 'bab'! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 2/7/2010 22:00'!testSideEffectChoice	"Adding another element to a choice should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 / $b asParser.	p3 := p1 / $c asParser.		self assert: p1 parse: 'a'.	self assert: p1 fail: 'b'.	self assert: p1 fail: 'c'.		self assert: p2 parse: 'a'.	self assert: p2 parse: 'b'.	self assert: p2 fail: 'c'.		self assert: p3 parse: 'a'.	self assert: p3 fail: 'b'.	self assert: p3 parse: 'c'! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 5/31/2010 19:25'!testSideEffectListCopy	| old new |	old := $a asParser , $b asParser.	new := old copy.		self deny: old == new.	self deny: old children == new children.	self assert: old children first == new children first.	self assert: old children last == new children last! !!PPParserTest methodsFor: 'testing-fixtures' stamp: 'lr 4/14/2010 11:38'!testSideEffectSequence	"Adding another element to a sequence should create a copy, otherwise we get unwanted side-effects."	| p1 p2 p3 |	p1 := $a asParser.	p2 := p1 , $b asParser.	p3 := p1 , $c asParser.		self assert: p1 parse: 'a'.		self assert: p1 parse: 'ab' end: 1.	self assert: p1 parse: 'ac' end: 1.		self assert: p2 fail: 'a'.		self assert: p2 parse: 'ab'.	self assert: p2 fail: 'ac'.	self assert: p3 fail: 'a'.		self assert: p3 fail: 'ab'.	self assert: p3 parse: 'ac'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:02'!testStar	| parser |	parser := $a asParser star.		self assert: parser min = 0.	self assert: parser max > parser min.		self assert: parser parse: '' to: #().	self assert: parser parse: 'a' to: #($a).	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a $a).		self assert: parser parse: 'b' to: #() end: 0.	self assert: parser parse: 'ab' to: #($a) end: 1.	self assert: parser parse: 'aab' to: #($a $a) end: 2.	self assert: parser parse: 'aaab' to: #($a $a $a) end: 3! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:02'!testStarGreedy	| limit parser |	limit := #digit asParser.	parser := #word asParser starGreedy: limit.		self assert: parser min = 0.	self assert: parser max > parser min.	self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #($1) end: 1.	self assert: parser parse: 'a12' to: #($a $1) end: 2.	self assert: parser parse: 'ab12' to: #($a $b $1) end: 3.	self assert: parser parse: 'abc12' to: #($a $b $c $1) end: 4.	self assert: parser parse: '123' to: #($1 $2) end: 2.	self assert: parser parse: 'a123' to: #($a $1 $2) end: 3.	self assert: parser parse: 'ab123' to: #($a $b $1 $2) end: 4.	self assert: parser parse: 'abc123' to: #($a $b $c $1 $2) end: 5! !!PPParserTest methodsFor: 'testing' stamp: 'lr 8/17/2011 10:02'!testStarLazy	| limit parser |	limit := #digit asParser.	parser := #word asParser starLazy: limit.		self assert: parser min = 0.	self assert: parser max > parser min.	self assert: parser limit = limit.	self assert: parser children size = 2.	self assert: parser children last = limit.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'ab'.	self assert: parser parse: '1' to: #() end: 0.	self assert: parser parse: 'a1' to: #($a) end: 1.	self assert: parser parse: 'ab1' to: #($a $b) end: 2.	self assert: parser parse: 'abc1' to: #($a $b $c) end: 3.	self assert: parser parse: '12' to: #() end: 0.	self assert: parser parse: 'a12' to: #($a) end: 1.	self assert: parser parse: 'ab12' to: #($a $b) end: 2.	self assert: parser parse: 'abc12' to: #($a $b $c) end: 3.	self assert: parser parse: '123' to: #() end: 0.	self assert: parser parse: 'a123' to: #($a) end: 1.	self assert: parser parse: 'ab123' to: #($a $b) end: 2.	self assert: parser parse: 'abc123' to: #($a $b $c) end: 3! !!PPParserTest methodsFor: 'testing' stamp: 'lr 9/15/2010 09:53'!testTimes	| parser |	parser := $a asParser times: 2.		self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser parse: 'aa' to: #($a $a).	self assert: parser parse: 'aaa' to: #($a $a) end: 2! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 4/6/2010 19:47'!testToken	| parser |	parser := $a asParser token.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: 'b'.	self assert: parser fail: ''.		parser := $a asParser token: PPToken.	self assert: parser tokenClass = PPToken.	self assert: parser parse: 'a' toToken: 1 stop: 1.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/11/2011 11:05'!testTrim	| parser |	parser := $a asParser token trim.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/31/2010 12:07'!testTrimBlanks	| parser |	parser := $a asParser token trimBlanks.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: 'b'.! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/11/2011 11:05'!testTrimCustom	| parser |	parser := $a asParser token trim: $b asParser.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1.	self assert: parser parse: 'abb' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'ba' toToken: 2 stop: 2.	self assert: parser parse: 'bba' toToken: 3 stop: 3.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'ab' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'abba' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 7/31/2010 12:07'!testTrimSpaces	| parser |	parser := $a asParser token trimSpaces.		self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: 'a ' toToken: 1 stop: 1.	self assert: parser parse: 'a	' toToken: 1 stop: 1.	self assert: parser parse: 'a  ' toToken: 1 stop: 1.	self assert: parser parse: 'a 	 ' toToken: 1 stop: 1.			self assert: parser parse: 'a' toToken: 1 stop: 1.	self assert: parser parse: ' a' toToken: 2 stop: 2.	self assert: parser parse: '	a' toToken: 2 stop: 2.	self assert: parser parse: '    a' toToken: 5 stop: 5.	self assert: parser parse: '   a' toToken: 5 stop: 5.		self assert: parser parse: 'aa' toToken: 1 stop: 1 end: 1.	self assert: parser parse: 'a	a' toToken: 1 stop: 1 end: 2.	self assert: parser parse: 'a  a' toToken: 1 stop: 1 end: 3.		self assert: parser fail: ''.	self assert: parser fail: 'b'! !!PPParserTest methodsFor: 'testing' stamp: 'lr 11/20/2009 15:31'!testUnresolved	| parser |	parser := PPUnresolvedParser new.		self assert: parser isUnresolved.	self should: [ parser parse: '' ] raise: Error.	self should: [ parser parse: 'a' ] raise: Error.	self should: [ parser parse: 'ab' ] raise: Error.		parser := nil asParser.	self deny: parser isUnresolved! !!PPParserTest methodsFor: 'testing' stamp: 'tg 7/29/2010 22:39'!testWrapped	| parser |	parser := $a asParser wrapped.		self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.		parser := (($a asParser , $b asParser ) wrapped , $c asParser).	self assert: parser parse: 'abc' to: #(#($a $b) $c)! !!PPParserTest methodsFor: 'testing-mapping' stamp: 'lr 5/12/2010 20:40'!testWrapping	| parser result |	parser := #digit asParser plus >=> [ :stream :cc | 		Array 			with: stream position 			with: cc value 			with: stream position ].	self assert: parser parse: '1' to: #(0 ($1) 1).	self assert: parser parse: '12' to: #(0 ($1 $2) 2).	self assert: parser parse: '123' to: #(0 ($1 $2 $3) 3).		result := parser parse: 'a'.	self assert: result first = 0.	self assert: result second isPetitFailure.	self assert: result last = 0! !!PPParserTest methodsFor: 'testing' stamp: 'lr 4/14/2010 16:30'!testXor	| parser |	parser := ($a asParser / $b asParser)			|  ($b asParser / $c asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'.		" truly symmetric "	parser := ($b asParser / $c asParser)			|  ($a asParser / $b asParser).		self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'c' to: $c.		self assert: parser fail: ''.	self assert: parser fail: 'b'.	self assert: parser fail: 'd'! !!PPPredicateTest methodsFor: 'utilities' stamp: 'lr 6/12/2010 08:37'!assertCharacterSets: aParser	"Assert the character set of aParser does not overlap with the character set with the negated parser, and that they both cover the complete character space."	| positives negatives |	positives := self parsedCharacterSet: aParser.	negatives := self parsedCharacterSet: aParser negate.	self charactersDo: [ :char | 		| positive negative |		positive := positives includes: char.		negative := negatives includes: char.		self 			assert: ((positive and: [ negative not ])				or: [ positive not and: [ negative ] ])			description: char printString , ' should be in exactly one set' ]! !!PPPredicateTest methodsFor: 'private' stamp: 'lr 6/12/2010 08:37'!charactersDo: aBlock	1 to: 256 do: [ :index | aBlock value: (Character codePoint: index) ]! !!PPPredicateTest methodsFor: 'utilities' stamp: 'lr 6/12/2010 08:37'!parsedCharacterSet: aParser	| result |	result := WriteStream on: String new.	self charactersDo: [ :char |		(aParser matches: (String with: char))			ifTrue: [ result nextPut: char ] ].	^ result contents! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 11/29/2009 09:32'!testAny	| parser |	parser := #any asParser.	self assertCharacterSets: parser.	self assert: parser parse: ' ' to: $ .	self assert: parser parse: '1' to: $1.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'tg 7/12/2010 11:26'!testAnyExceptAnyOf	| parser |	parser := PPPredicateObjectParser anyExceptAnyOf: #($: $,).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ':'.	self assert: parser fail: ','! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testAnyOf	| parser |	parser := PPPredicateObjectParser anyOf: #($a $z).	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: 'x'! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testBetweenAnd	| parser |	parser := PPPredicateObjectParser between: $b and: $d.	self assertCharacterSets: parser.	self assert: parser fail: 'a'.	self assert: parser parse: 'b' to: $b.	self assert: parser parse: 'c' to: $c.	self assert: parser parse: 'd' to: $d.	self assert: parser fail: 'e'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/5/2010 14:15'!testBlank	| parser |	parser := #blank asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character space) to: Character space.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: (String with: Character cr)! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/2/2010 12:51'!testChar	| parser |	parser := $* asParser.	self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testCr	| parser |	parser := #cr asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testDigit	| parser |	parser := #digit asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '9' to: $9.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-objects' stamp: 'lr 6/12/2010 09:16'!testExpect	| parser |	parser := PPPredicateObjectParser expect: $a.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser fail: 'b'.	self assert: parser fail: ''! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testHex	| parser |	parser := #hex asParser.	self assertCharacterSets: parser.	self assert: parser parse: '0' to: $0.	self assert: parser parse: '5' to: $5.	self assert: parser parse: '9' to: $9.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'D' to: $D.	self assert: parser parse: 'F' to: $F.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'e' to: $e.	self assert: parser parse: 'f' to: $f.	self assert: parser fail: ''.	self assert: parser fail: 'g'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLetter	| parser |	parser := #letter asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLf	| parser |	parser := #lf asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character lf) to: Character lf! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testLowercase	| parser |	parser := #lowercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'z' to: $z.	self assert: parser fail: ''.	self assert: parser fail: 'A'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:36'!testNewline	| parser |	parser := #newline asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character cr) to: Character cr.	self assert: parser parse: (String with: Character lf) to: Character lf.	self assert: parser fail: ' '! !!PPPredicateTest methodsFor: 'testing' stamp: 'lr 6/12/2010 09:17'!testOnMessage	| block parser |	block := [ :char | char = $* ].	parser := PPPredicateObjectParser on: block message: 'starlet'.	self assert: parser block = block.	self assert: parser message = 'starlet'.		self assertCharacterSets: parser.	self assert: parser parse: '*' to: $*.	self assert: parser parse: '**' to: $* end: 1.	self assert: parser fail: ''.	self assert: parser fail: '1'.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 5/5/2010 14:14'!testPunctuation	| parser |	parser := #punctuation asParser.	self assertCharacterSets: parser.	self assert: parser parse: '.' to: $..	self assert: parser parse: ',' to: $,.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '1'! !!PPPredicateTest methodsFor: 'testing-sequence' stamp: 'lr 6/12/2010 09:27'!testSequenceParser	| parser |	parser := PPPredicateSequenceParser 		on: [ :value | value first isUppercase ] 		message: 'uppercase 3 letter words'		size: 3.	self assert: parser size = 3.	self assert: parser parse: 'Abc'.	self assert: parser parse: 'ABc'.	self assert: parser parse: 'ABC'.	self assert: parser fail: 'abc'.	self assert: parser fail: 'aBC'.	self assert: parser fail: 'Ab'.		parser := parser negate.	self assert: parser size = 3.	self assert: parser fail: 'Abc'.	self assert: parser fail: 'ABc'.	self assert: parser fail: 'ABC'.	self assert: parser parse: 'abc'.	self assert: parser parse: 'aBC'.	self assert: parser fail: 'Ab'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testSpace	| parser |	parser := #space asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab.	self assert: parser parse: ' ' to: Character space.	self assert: parser fail: ''.	self assert: parser fail: 'a'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testTab	| parser |	parser := #tab asParser.	self assertCharacterSets: parser.	self assert: parser parse: (String with: Character tab) to: Character tab! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testUppercase	| parser |	parser := #uppercase asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: 'Z' to: $Z.	self assert: parser fail: ''.	self assert: parser fail: 'a'.	self assert: parser fail: '0'! !!PPPredicateTest methodsFor: 'testing-chars' stamp: 'lr 11/29/2009 09:32'!testWord	| parser |	parser := #word asParser.	self assertCharacterSets: parser.	self assert: parser parse: 'a' to: $a.	self assert: parser parse: 'A' to: $A.	self assert: parser parse: '0' to: $0.	self assert: parser fail: ''.	self assert: parser fail: '-'! !!PPScriptingTest commentStamp: '<historical>' prior: 34126752!These are some simple demo-scripts of parser combinators for the compiler construction course.http://www.iam.unibe.ch/~scg/Teaching/CC/index.html!!PPScriptingTest methodsFor: 'examples' stamp: 'lr 6/12/2010 08:30'!expressionInterpreter	"Same as #expressionInterpreter but with semantic actions."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9) ==> [ :token | token codePoint - $0 codePoint ].	add def: ((mul , $+ asParser , add) ==> [ :nodes | (nodes at: 1) + (nodes at: 3) ])		/ mul.	mul def: ((prim , $* asParser , mul) ==> [ :nodes | (nodes at: 1) * (nodes at: 3) ])		/ prim.	prim def: (($( asParser , add , $) asParser) ==> [ :nodes | nodes at: 2 ])		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'examples' stamp: 'lr 6/12/2010 08:30'!expressionParser	"Simple demo of scripting an expression parser."		| mul prim add dec |	add := PPUnresolvedParser new.	mul := PPUnresolvedParser new.	prim := PPUnresolvedParser new.	dec := ($0 - $9).	add def: (mul , $+ asParser , add)		/ mul.	mul def: (prim , $* asParser , mul)		/ prim.	prim def: ($( asParser , add , $) asParser)		/ dec.	^ add end! !!PPScriptingTest methodsFor: 'examples' stamp: 'lr 10/20/2008 13:27'!straightLineParser	| goal stm stmList id char dec exp expList mulExp primExp nonzero num lower upper |	goal := PPUnresolvedParser new.	stmList := PPUnresolvedParser new.	stm := PPUnresolvedParser new.	exp := PPUnresolvedParser new.	expList := PPUnresolvedParser new.	mulExp := PPUnresolvedParser new.	primExp := PPUnresolvedParser new.		lower := $a - $z.	upper := $A - $Z.	char := lower / upper.	nonzero := $1 - $9.	dec := $0 - $9.	id := char, ( char / dec ) star.	num := $0 asParser / ( nonzero, dec star).	goal def: stmList end.	stmList def: stm , ( $; asParser, stm ) star.	stm def: ( id, ':=' asParser, exp )		/ ( 'print' asParser, $( asParser, expList, $) asParser ). 	exp def: mulExp, ( ( $+ asParser / $- asParser ), mulExp ) star.	expList def: exp, ( $, asParser, exp ) star.	mulExp def: primExp, ( ( $* asParser / $/ asParser ), primExp ) star.	primExp def: id		/ num		/ ( $( asParser, stmList, $, asParser, exp, $) asParser ).	^ goal! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:31'!testExpressionInterpreter	self 		assert: self expressionInterpreter		parse: '2*(3+4)'		to: 14! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:31'!testExpressionParser	self		assert: self expressionParser		parse: '2*(3+4)'		to: #($2 $* ($( ($3 $+ $4) $)))! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 9/17/2008 22:44'!testSLassign		self assert: self straightLineParser		parse: 'abc:=1'		to: #(#($a #($b $c) ':=' #(#(#($1 #()) #()) #())) #())! !!PPScriptingTest methodsFor: 'tests' stamp: 'lr 6/12/2010 08:27'!testSLprint	self 		assert: self straightLineParser		parse: 'print(3,4)'		to: #(('print' $( ((($3 ()) ()) () (($, ((($4 ()) ()) ())))) $)) ())! !!PPTokenTest methodsFor: 'accessing' stamp: 'lr 4/3/2009 08:51'!identifier	^ #word asParser plus token! !!PPTokenTest methodsFor: 'utilities' stamp: 'lr 3/29/2010 15:34'!parse: aString using: aParser	^ aParser parse: aString! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 4/3/2009 08:49'!testCollection	| input result |	input := 'foo    '.	result := self 		parse: input		using: self identifier.	self assert: (result collection = input).	self assert: (result collection == input)! !!PPTokenTest methodsFor: 'testing-querying' stamp: 'lr 6/16/2010 08:08'!testColumn	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with:  #(1 2 1 2 3 4 1 2 3 4 1 2 3 4)		do: [ :token :line | self assert: token column = line ]! !!PPTokenTest methodsFor: 'testing-copying' stamp: 'lr 4/21/2009 08:50'!testCopyFromTo	| result other |	result := PPToken on: 'abc'.	other := result copyFrom: 2 to: 2.		self assert: other size = 1.	self assert: other start = 2.	self assert: other stop = 2.	self assert: other collection = result collection! !!PPTokenTest methodsFor: 'testing-comparing' stamp: 'lr 10/23/2009 11:37'!testEquality	| token1 token2 |	token1 := self  parse: 'foo' using: self identifier.	token2 := self  parse: 'foo' using: self identifier.	self deny: token1 == token2.	self assert: token1 = token2.	self assert: token1 hash = token2 hash.! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 2/26/2013 02:50'!testInitialize	PPToken initialize! !!PPTokenTest methodsFor: 'testing-values' stamp: 'lr 2/26/2013 00:38'!testInputValue	| input result |	input := 'foo'.	result := self 		parse: input		using: self identifier.	self assert: result inputValue = input.	self deny: result inputValue == input! !!PPTokenTest methodsFor: 'testing-querying' stamp: 'lr 6/16/2010 08:05'!testLine	| input parser result |	input := '1' , (String with: Character cr) , '12' , (String with: Character cr with: Character lf) , '123' , (String with: Character lf) , '1234'.	parser := #any asParser token star.	result := parser parse: input.	result 		with: #(1 1 2 2 2 2 3 3 3 3 4 4 4 4) 		do: [ :token :line | self assert: token line = line ]! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 4/14/2010 11:44'!testNew	self should: [ PPToken new ] raise: Error.	! !!PPTokenTest methodsFor: 'testing-values' stamp: 'lr 2/26/2013 00:39'!testParsedValue	| input result |	input := 'foo'.	result := self 		parse: input		using: self identifier.	self assert: result parsedValue = #($f $o $o)! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 3/17/2013 08:38'!testPrinting	| result |	result := PPToken on: 'var'.	self assert: (result printString findString: 'PPToken[1,3]') > 0! !!PPTokenTest methodsFor: 'testing' stamp: 'TestRunner 12/4/2009 19:16'!testSize	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result size = 3! !!PPTokenTest methodsFor: 'testing' stamp: 'TestRunner 12/4/2009 19:16'!testStart	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result start = 1! !!PPTokenTest methodsFor: 'testing' stamp: 'TestRunner 12/4/2009 19:16'!testStop	| result |	result := self 		parse: 'foo'		using: self identifier.	self assert: result stop = 3! !!PPTokenTest methodsFor: 'testing' stamp: 'lr 2/26/2013 02:49'!testValue	| result |	result := PPToken on: 'var'.	self should: [ result value ] raise: Notification! !!PPStream commentStamp: '<historical>' prior: 34126949!A positional stream implementation used for parsing. It overrides some methods for optimization reasons.!!PPStream methodsFor: 'converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ self! !!PPStream methodsFor: 'accessing' stamp: 'lr 2/13/2012 20:25'!collection	"Answer the underlying collection."		^ collection! !!PPStream methodsFor: 'accessing' stamp: 'lr 4/29/2008 21:48'!peek	"An improved version of peek, that is slightly faster than the built in version."	^ self atEnd ifFalse: [ collection at: position + 1 ]! !!PPStream methodsFor: 'accessing' stamp: 'lr 8/25/2010 11:36'!position: anInteger	"The receiver does not check for invalid arguments passed to this method, as it is solely used with valid indexes for backtracking."	position := anInteger! !!PPStream methodsFor: 'printing' stamp: 'lr 11/4/2010 19:23'!printOn: aStream	collection isString		ifFalse: [ ^ super printOn: aStream ].	aStream		nextPutAll: (collection copyFrom: 1 to: position);		nextPutAll: '·';		nextPutAll: (collection copyFrom: position + 1 to: readLimit)! !!PPStream methodsFor: 'accessing' stamp: 'lr 10/5/2010 16:29'!uncheckedPeek	"An unchecked version of peek that throws an error if we try to peek over the end of the stream, even faster than #peek."	^ collection at: position + 1! !!BlockClosure methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer a parser implemented in the receiving one-argument block."	^ PPPluggableParser on: self! !!UndefinedObject methodsFor: '*petitparser-converting' stamp: 'lr 11/29/2011 20:49'!asParser	"Answer a parser that succeeds and does not consume anything."		^ PPEpsilonParser new! !!Text methodsFor: '*petitparser-core-converting' stamp: 'lr 2/7/2010 20:53'!asPetitStream	^ string asPetitStream! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asChoiceParser	^ PPChoiceParser withAll: (self collect: [ :each | each asParser ])! !!Collection methodsFor: '*petitparser-core-converting' stamp: 'lr 11/29/2011 20:38'!asSequenceParser	^ PPSequenceParser withAll: (self collect: [ :each | each asParser ])! !!Object methodsFor: '*petitparser-core-converting' stamp: 'lr 12/18/2011 15:58'!asParser	"Answer a parser accepting the receiving object."	^ PPPredicateObjectParser expect: self! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	^ false! !!Object methodsFor: '*petitparser-core-testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ false! !!PPCharSetPredicate class methodsFor: 'instance creation' stamp: 'lr 8/25/2010 11:05'!on: aBlock	^ self basicNew initializeOn: aBlock! !!PPCharSetPredicate methodsFor: 'initialization' stamp: 'lr 8/30/2010 12:19'!initializeOn: aBlock	block := aBlock.	classification := Array new: 255.	1 to: classification size do: [ :index |		classification at: index put: (block			value: (Character value: index)) ]! !!PPCharSetPredicate methodsFor: 'evaluating' stamp: 'lr 8/30/2010 12:19'!value: aCharacter	| index |	index := aCharacter asInteger.	index == 0		ifTrue: [ ^ block value: aCharacter ].	index > 255		ifTrue: [ ^ block value: aCharacter ].	^ classification at: index! !!PPFailure commentStamp: '<historical>' prior: 34127105!The failure object in PetitParser. It is the only class that responds to #isPetitFailure with true. It contains an error message and a position of the occurrence of the failure.Instance Variables:	message	<String>	The error message of this failure.	position	<Integer>	The position of this failure in the input stream.!!PPFailure class methodsFor: 'instance creation' stamp: 'lr 5/5/2010 13:56'!message: aString at: anInteger	^ self basicNew initializeMessage: aString at: anInteger! !!PPFailure methodsFor: 'initialization' stamp: 'lr 5/5/2010 13:55'!initializeMessage: aString at: anInteger	message := aString.	position := anInteger! !!PPFailure methodsFor: 'testing' stamp: 'lr 2/7/2010 20:54'!isPetitFailure	"I am the only class that should implement this method to return true."	^ true! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:56'!message	"Answer a human readable error message of this parse failure."		^ message! !!PPFailure methodsFor: 'accessing' stamp: 'lr 5/5/2010 13:55'!position	"Answer the position in the source string that caused this parse failure."	^ position! !!PPFailure methodsFor: 'printing' stamp: 'lr 5/5/2010 14:01'!printOn: aStream	aStream nextPutAll: self message; nextPutAll: ' at '; print: position! !!PPMemento commentStamp: '<historical>' prior: 34127479!PPMemento is an internal class used by PPMemoizedParser to cache results and detect left-recursive calls.Instance Variables:	result	<Object>	The cached result.	count	<Integer>	The number of recursive cycles followed.	position	<Integer>	The position of the cached result in the input stream.!!PPMemento class methodsFor: 'instance creation' stamp: 'lr 4/22/2008 18:21'!new	^ self basicNew initialize! !!PPMemento methodsFor: 'accessing-readonly' stamp: 'lr 4/22/2008 18:23'!count	^ count! !!PPMemento methodsFor: 'actions' stamp: 'lr 4/22/2008 18:20'!increment	count := count + 1! !!PPMemento methodsFor: 'initialization' stamp: 'lr 4/22/2008 18:21'!initialize	count := 0	! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/22/2008 18:23'!position	^ position! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/26/2008 15:48'!position: anInteger	position := anInteger! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/24/2008 10:15'!result	^ result! !!PPMemento methodsFor: 'accessing' stamp: 'lr 4/22/2008 18:23'!result: anObject	result := anObject! !!PPParser commentStamp: '<historical>' prior: 34127825!An abstract parser for all parsers in PetitParser. Subclasses implement #parseOn: to perform the actual recursive-descent parsing. All parsers support a variety of methods to perform an actual parse, see the methods in the #parsing protocol. Parsers are combined with a series of operators that can be found in the #operations protocol.Instance Variables:	properties	<Dictionary>	Stores additional state in the parser object.!!PPDelegateParser commentStamp: '<historical>' prior: 34128312!A parser that delegates to another parser.Instance Variables:	parser	<PPParser>	The parser to delegate to.!!PPActionParser commentStamp: '<historical>' prior: 34128478!A parser that performs an action block with the successful parse result of the delegate.Instance Variables:	block	<BlockClosure>	The action block to be executed.!!PPActionParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:58'!on: aParser block: aBlock	^ (self on: aParser) setBlock: aBlock! !!PPActionParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the action block of the receiver."	^ block! !!PPActionParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| element |	^ (element := parser parseOn: aStream) isPetitFailure		ifFalse: [ block value: element ]		ifTrue: [ element ]! !!PPActionParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:58'!setBlock: aBlock	block := aBlock! !!PPWrappingParser commentStamp: '<historical>' prior: 34128702!A parser that performs an action block upon activation with the stream and a continuation block.!!PPWrappingParser methodsFor: 'parsing' stamp: 'lr 5/12/2010 20:19'!parseOn: aStream	^ block value: aStream value: [ parser parseOn: aStream ]! !!PPAndParser commentStamp: 'TudorGirba 2/27/2011 22:22' prior: 34128866!The and-predicate, a parser that succeeds whenever its delegate does, but does not consume the input stream [Parr 1994, 1995].!!PPAndParser methodsFor: 'operators' stamp: 'lr 5/1/2010 16:16'!and	^ self! !!PPAndParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element! !!PPCompositeParser commentStamp: 'lr 12/4/2009 18:38' prior: 34129058!A PPCompositeParser is composed parser built from various primitive parsers. Every production in the receiver is specified as a method that returns its parser. Note that every production requires an instance variable of the same name, otherwise the production is not cached and cannot be used in recursive grammars. Productions should refer to each other by reading the respective inst-var. Note: these inst-vars are typically not written, as the assignment happens in the initialize method using reflection.The start production is defined in the method start. It is aliased to the inst-var parser defined in the superclass of PPCompositeParser.!!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:46'!addition	^ (factors separatedBy: ($+ asParser / $- asParser) trim) 		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:28'!factors	^ multiplication / power! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:47'!multiplication	^ (power separatedBy: ($* asParser / $/ asParser) trim)		foldLeft: [ :a :op :b | a perform: op asSymbol with: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:47'!number	^ ($- asParser optional , #digit asParser plus , ($. asParser , #digit asParser plus) optional) flatten trim 		==> [ :value | value asNumber ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:49'!parentheses	^ $( asParser trim , terms , $) asParser trim		==> [ :nodes | nodes second ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 2/25/2013 23:49'!power	^ (primary separatedBy: $^ asParser trim)		foldRight: [ :a :op :b | a raisedTo: b ]! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:28'!primary	^ number / parentheses! !!PPArithmeticParser methodsFor: 'accessing' stamp: 'lr 7/3/2008 17:06'!start	^ terms end! !!PPArithmeticParser methodsFor: 'grammar' stamp: 'lr 9/15/2008 09:29'!terms	^ addition / factors! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 3/16/2013 21:42'!dependencies	"Answer a collection of PPCompositeParser classes that this parser directly dependends on. Override this method in subclasses to declare dependent parsers. The default implementation does not depend on other PPCompositeParser."	^ #()! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 1/29/2010 11:35'!ignoredNames	"Answer a collection of instance-variables that should not be automatically initialized with productions, but that are used internal to the composite parser."	^ PPCompositeParser allInstVarNames! !!PPCompositeParser class methodsFor: 'instance creation' stamp: 'lr 12/7/2009 08:24'!new	"Answer a new parser starting at the default start symbol."	^ self newStartingAt: self startSymbol! !!PPCompositeParser class methodsFor: 'instance creation' stamp: 'lr 3/16/2013 21:21'!newStartingAt: aSymbol	"Answer a new parser starting at aSymbol. The code makes sure to resolve all dependent parsers correctly."	| parsers remaining |	parsers := IdentityDictionary new.	remaining := OrderedCollection with: self.	[ remaining isEmpty ] whileFalse: [		| dependency |		dependency := remaining removeLast.		(parsers includesKey: dependency) ifFalse: [			parsers at: dependency put: dependency basicNew.			remaining addAll: dependency dependencies ] ].	parsers keysAndValuesDo: [ :class :parser |		| dependencies |		dependencies := IdentityDictionary new.		class dependencies 			do: [ :dependency | dependencies at: dependency put: (parsers at: dependency) ].		parser 			initializeStartingAt: (class == self				ifTrue: [ aSymbol ]				ifFalse: [ class startSymbol ]) 			dependencies: dependencies ].	parsers keysAndValuesDo: [ :class :parser |		parser setParser: (parser perform: parser children first name).		parser productionNames keysAndValuesDo: [ :key :value |			(parser instVarAt: key) setParser: (parser perform: value) ] ].	^ parsers at: self! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:57'!parse: anObject	^ self parse: anObject startingAt: self startSymbol! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 21:02'!parse: anObject onError: aBlock	^ self parse: anObject startingAt: self startSymbol onError: aBlock! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:57'!parse: anObject startingAt: aSymbol	^ (self newStartingAt: aSymbol) parse: anObject! !!PPCompositeParser class methodsFor: 'parsing' stamp: 'lr 2/7/2010 21:02'!parse: anObject startingAt: aSymbol onError: aBlock	^ (self newStartingAt: aSymbol) parse: anObject onError: aBlock! !!PPCompositeParser class methodsFor: 'accessing' stamp: 'lr 12/7/2009 08:20'!startSymbol	"Answer the method that represents the default start symbol."	^ #start! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 3/16/2013 21:41'!dependencyAt: aClass	"Answer the dependent parser aClass. Throws an error if this parser class is not declared in the method #dependencies on the class-side of the receiver."		^ dependencies at: aClass ifAbsent: [ self error: 'Undeclared dependency in ' , self class name , ' to ' , aClass name ]! !!PPCompositeParser methodsFor: 'initialization' stamp: 'lr 3/16/2013 17:15'!initializeStartingAt: aSymbol dependencies: aDictionary	self initialize.	parser := PPDelegateParser named: aSymbol.	self productionNames keysAndValuesDo: [ :key :value |		self instVarAt: key put: (PPDelegateParser named: value) ].	dependencies := aDictionary! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 12/4/2009 18:39'!productionAt: aSymbol	"Answer the production named aSymbol."		^ self productionAt: aSymbol ifAbsent: [ nil ]! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 6/4/2010 13:37'!productionAt: aSymbol ifAbsent: aBlock	"Answer the production named aSymbol, if there is no such production answer the result of evaluating aBlock."		(self class ignoredNames includes: aSymbol asString)		ifTrue: [ ^ aBlock value ].	(self class startSymbol = aSymbol)		ifTrue: [ ^ parser ].	^ self instVarAt: (self class allInstVarNames		indexOf: aSymbol asString		ifAbsent: [ ^ aBlock value ])! !!PPCompositeParser methodsFor: 'querying' stamp: 'lr 5/8/2011 15:45'!productionNames	"Answer a dictionary of slot indexes and production names."		| productionNames ignoredNames |	productionNames := Dictionary new.	ignoredNames := self class ignoredNames		collect: [ :each | each asSymbol ].	self class allInstVarNames keysAndValuesDo: [ :key :value |		(ignoredNames includes: value asSymbol)			ifFalse: [ productionNames at: key put: value asSymbol ] ].	^ productionNames! !!PPCompositeParser methodsFor: 'accessing' stamp: 'lr 5/16/2008 17:32'!start	"Answer the production to start this parser with."		self subclassResponsibility! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!and	^ self parse: '\p.\q.((p q) p)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!false	^ self parse: '\x.\y.y'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!ifthenelse	^ self parse: '\p.p'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!not	^ self parse: '\p.\a.\b.((p b) a)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!or	^ self parse: '\p.\q.((p p) q)'! !!PPLambdaParser class methodsFor: 'curch-booleans' stamp: 'lr 4/3/2009 08:28'!true	^ self parse: '\x.\y.x'! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 2/25/2013 23:43'!abstraction	^ $\ asParser trim , variable , $. asParser trim , expression ==> [ :node | Array with: node second with: node fourth ]! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 2/25/2013 23:43'!application	^ $( asParser trim , expression , expression , $) asParser trim ==> [ :node | Array with: node second with: node third ]! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 9/15/2008 09:29'!expression	^ variable / abstraction / application! !!PPLambdaParser methodsFor: 'accessing' stamp: 'lr 5/19/2008 11:35'!start	^ expression end! !!PPLambdaParser methodsFor: 'productions' stamp: 'lr 2/25/2013 23:44'!variable	^ (#letter asParser , #word asParser star) flatten trim! !!PPDelegateParser class methodsFor: 'instance creation' stamp: 'lr 4/20/2008 16:22'!on: aParser	^ self new setParser: aParser! !!PPDelegateParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ Array with: parser! !!PPDelegateParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:47'!parseOn: aStream	^ parser parseOn: aStream! !!PPDelegateParser methodsFor: 'initialization' stamp: 'lr 4/20/2008 16:23'!setParser: aParser	parser := aParser! !!PPEndOfInputParser commentStamp: 'lr 4/18/2008 13:46' prior: 34129774!A parser that succeeds only at the end of the input stream.!!PPEndOfInputParser methodsFor: 'operators' stamp: 'lr 12/7/2009 08:53'!end	^ self! !!PPEndOfInputParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:10'!parseOn: aStream	| position result |	position := aStream position.	result := parser parseOn: aStream.	(result isPetitFailure or: [ aStream atEnd ])		ifTrue: [ ^ result ].	result := PPFailure		message: 'end of input expected'		at: aStream position.	aStream position: position.	^ result! !!PPExpressionParser commentStamp: '<historical>' prior: 34129894!A PPExpressionParser is a parser to conveniently define an expression grammar with prefix, postfix, and left- and right-associative infix operators.The following code initializes a parser for arithmetic expressions. First we instantiate an expression parser, a simple parser for expressions in parenthesis and a simple parser for integer numbers.	expression := PPExpressionParser new.	parens := $( asParser token trim , expression , $) asParser token trim 		==> [ :nodes | nodes second ].	integer := #digit asParser plus token trim		==> [ :token | token value asInteger ].	Then we define on what term the expression grammar is built on:	expression term: parens / integer.	Finally we define the operator-groups in descending precedence. Note, that the action blocks receive both, the terms and the parsed operator in the order they appear in the parsed input. 		expression		group: [ :g |			g prefix: $- asParser token trim do: [ :op :a | a negated ] ];		group: [ :g |			g postfix: '++' asParser token trim do: [ :a :op | a + 1 ].			g postfix: '--' asParser token trim do: [ :a :op | a - 1 ] ];		group: [ :g |			g right: $^ asParser token trim do: [ :a :op :b | a raisedTo: b ] ];		group: [ :g |			g left: $* asParser token trim do: [ :a :op :b | a * b ].			g left: $/ asParser token trim do: [ :a :op :b | a / b ] ];		group: [ :g |			g left: $+ asParser token trim do: [ :a :op :b | a + b ].			g left: $- asParser token trim do: [ :a :op :b | a - b ] ].		After evaluating the above code the 'expression' is an efficient parser that evaluates examples like:	expression parse: '-8++'.	expression parse: '1+2*3'.	expression parse: '1*2+3'.	expression parse: '(1+2)*3'.	expression parse: '8/4/2'.	expression parse: '8/(4/2)'.	expression parse: '2^2^3'.	expression parse: '(2^2)^3'.	Instance Variables:	operators	<Dictionary>	The operators defined in the current group.!!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!build: aParser left: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldLeft: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private' stamp: 'lr 12/4/2009 17:38'!build: aParser postfix: aChoiceParser	^ aParser , aChoiceParser star map: [ :term :ops | ops inject: term into: [ :result :operator | operator first value: result value: operator second ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'lr 12/4/2009 17:39'!build: aParser prefix: aChoiceParser	^ aChoiceParser star , aParser map: [ :ops :term | ops reversed inject: term into: [ :result :operator | operator first value: operator second value: result ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!build: aParser right: aChoiceParser	^ (aParser separatedBy: aChoiceParser) foldRight: [ :a :op :b | op first value: a value: op second value: b ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 21:15'!buildOn: aParser	^ self buildSelectors inject: aParser into: [ :term :selector |		| list |		list := operators at: selector ifAbsent: [ #() ].		list isEmpty			ifTrue: [ term ]			ifFalse: [				self					perform: selector with: term 					with: (list size = 1						ifTrue: [ list first first ==> [ :operator | Array with: list first second with: operator ] ]						ifFalse: [ 							list								inject: PPChoiceParser new								into: [ :choice :each | choice / (each first ==> [ :operator | Array with: each second with: operator ]) ] ]) ] ]! !!PPExpressionParser methodsFor: 'private' stamp: 'FirstnameLastname 11/26/2009 20:48'!buildSelectors	^ #(build:prefix: build:postfix: build:right: build:left:)! !!PPExpressionParser methodsFor: 'specifying' stamp: 'lr 2/7/2010 23:20'!group: aOneArgumentBlock	"Defines a priority group by evaluating aOneArgumentBlock."		operators := Dictionary new.	parser := [ 		aOneArgumentBlock value: self.	 	self buildOn: parser ]			ensure: [ operators := nil ]! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!left: aParser do: aThreeArgumentBlock	"Define an operator aParser that is left-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:left: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'private' stamp: 'lr 2/7/2010 23:23'!operator: aSymbol parser: aParser do: aBlock	parser isNil		ifTrue: [ ^ self error: 'You did not specify a term when creating the receiver.' ].	operators isNil		ifTrue: [ ^ self error: 'Use #group: to define precedence groups in descending order.' ].	(operators at: aSymbol ifAbsentPut: [ OrderedCollection new ])		addLast: (Array with: aParser asParser with: aBlock)! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!postfix: aParser do: aTwoArgumentBlock	"Define a postfix operator aParser. Evaluate aTwoArgumentBlock with the term and the operator."	self operator: #build:postfix: parser: aParser do: aTwoArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!prefix: aParser do: aTwoArgumentBlock	"Define a prefix operator aParser. Evaluate aTwoArgumentBlock with the operator and the term."	self operator: #build:prefix: parser: aParser do: aTwoArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 20:49'!right: aParser do: aThreeArgumentBlock	"Define an operator aParser that is right-associative. Evaluate aThreeArgumentBlock with the first term, the operator, and the second term."		self operator: #build:right: parser: aParser do: aThreeArgumentBlock! !!PPExpressionParser methodsFor: 'specifying' stamp: 'FirstnameLastname 11/26/2009 21:26'!term: aParser	"Defines the initial term aParser of the receiver."		parser isNil		ifTrue: [ parser := aParser ]		ifFalse: [ self error: 'Unable to redefine the term.' ]! !!PPFlattenParser commentStamp: 'lr 11/22/2009 13:09' prior: 34131865!A parser that answers a flat copy of the range my delegate parses.!!PPFlattenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:31'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ aCollection copyFrom: aStartInteger to: aStopInteger! !!PPFlattenParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:30'!parseOn: aStream	| start element |	start := aStream position.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [ ^ element ].	^ self on: aStream collection start: start + 1 stop: aStream position value: element! !!PPTokenParser commentStamp: 'lr 2/25/2013 23:31' prior: 34131993!A parser that answers a token with the value of my delegate parses.Instance Variables:	tokenClass	<PPToken class>	The token sub-class to be used.!!PPTokenParser methodsFor: 'private' stamp: 'lr 4/6/2010 19:18'!defaultTokenClass	^ PPToken! !!PPTokenParser methodsFor: 'initialization' stamp: 'lr 4/6/2010 19:19'!initialize	tokenClass := self defaultTokenClass	! !!PPTokenParser methodsFor: 'private' stamp: 'lr 2/25/2013 23:32'!on: aCollection start: aStartInteger stop: aStopInteger value: anObject	^ self tokenClass on: aCollection start: aStartInteger stop: aStopInteger value: anObject! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:23'!tokenClass	^ tokenClass! !!PPTokenParser methodsFor: 'accessing' stamp: 'lr 4/6/2010 19:24'!tokenClass: aTokenClass	tokenClass := aTokenClass! !!PPMemoizedParser commentStamp: '<historical>' prior: 34132200!A memoized parser, for refraining redundant computations.Instance Variables:	stream	<PositionableStream>	The stream of the associated memento objects.	buffer	<Array of: PPMemento>	The buffer of memento objects.!!PPMemoizedParser methodsFor: 'operators' stamp: 'lr 4/2/2009 19:48'!memoized	"Ther is no point in memoizing more than once."	^ self! !!PPMemoizedParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| memento |	stream == aStream		ifFalse: [ self reset: aStream ].	memento := (buffer at: stream position + 1)		ifNil: [ buffer at: stream position + 1 put: PPMemento new ].	memento position isNil		ifTrue: [			memento result: (stream size - stream position + 2 < memento count				ifTrue: [ PPFailure message: 'overflow' at: stream position ]				ifFalse: [ memento increment. parser parseOn: stream ]).			memento position: stream position ]		ifFalse: [ stream position: memento position ].	^ memento result! !!PPMemoizedParser methodsFor: 'private' stamp: 'lr 4/2/2009 19:22'!reset: aStream	stream := aStream.	buffer := Array new: aStream size + 1! !!PPNotParser commentStamp: '<historical>' prior: 34132469!The not-predicate, a parser that succeeds whenever its delegate does not, but consumes no input [Parr 1994, 1995].!!PPNotParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| element position |	position := aStream position.	element := parser parseOn: aStream.	aStream position: position.	^ element isPetitFailure		ifFalse: [ PPFailure message: '' at: aStream position ]! !!PPOptionalParser commentStamp: 'lr 4/3/2011 14:46' prior: 34132647!A parser that optionally parsers its delegate, or answers nil.!!PPOptionalParser methodsFor: 'parsing' stamp: 'lr 8/14/2011 11:47'!parseOn: aStream	| element |	element := parser parseOn: aStream.	^ element isPetitFailure ifFalse: [ element ]! !!PPRepeatingParser commentStamp: 'lr 4/3/2011 14:45' prior: 34132774!An abstract parser that repeatedly parses between 'min' and 'max' instances of its delegate. The default configuration parses an infinite number of elements, as 'min' is set to 0 and 'max' to infinity (SmallInteger maxVal).Instance Variables:	min	<Integer>	The minimum number of repetitions.	max	<Integer>	The maximum number of repetitions.!!PPLimitedRepeatingParser commentStamp: 'lr 4/3/2011 14:37' prior: 34133190!An abstract parser that repeatedly parses between 'min' and 'max' instances of my delegate and that requires the input to be completed with a specified parser 'limit'. Subclasses provide repeating behavior as typically seen in regular expression implementations (non-blind).Instance Variables:	limit	<PPParser>	The parser to complete the input with.!!PPGreedyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 34133613!A greedy repeating parser, commonly seen in regular expression implementations. It aggressively consumes as much input as possible and then backtracks to meet the 'limit' condition.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])		with: (limit and ==> [ :each | OrderedCollection new ])).	^ parser ==> [ :rest | rest asArray ]!!PPGreedyRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 15:54'!parseOn: aStream	| start element elements positions |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [ 		(element := parser parseOn: aStream) isPetitFailure ifTrue: [ 			aStream position: start.			^ element ].		elements addLast: element ].	positions := OrderedCollection with: aStream position.	[ elements size < max and: [ (element := parser parseOn: aStream) isPetitFailure not ] ] whileTrue: [		elements addLast: element.		positions addLast: aStream position ].	[ positions isEmpty ] whileFalse: [		aStream position: positions last.		element := limit parseOn: aStream.		element isPetitFailure ifFalse: [			aStream position: positions last.			^ elements asArray ].		elements isEmpty ifTrue: [			aStream position: start.			^ element ].		elements removeLast.		positions removeLast ].	aStream position: start.	^ PPFailure message: 'overflow' at: start! !!PPLazyRepeatingParser commentStamp: 'lr 4/3/2011 15:08' prior: 34134214!A lazy repeating parser, commonly seen in regular expression implementations. It limits its consumption to meet the 'limit' condition as early as possible.This class essentially implements the iterative version of the following recursive parser composition:	| parser |	parser := PPChoiceParser new.	parser setParsers: (Array		with: (limit and ==> [ :each | OrderedCollection new ])		with: (self , parser map: [ :each :rest | rest addFirst: each; yourself ])).	^ parser ==> [ :rest | rest asArray ]!!PPLazyRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 10:14'!parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ self matchesLimitOn: aStream ] whileFalse: [		elements size < max ifFalse: [			aStream position: start.			^ PPFailure message: 'overflow' at: start ].		element := parser parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	^ elements asArray! !!PPLimitedRepeatingParser class methodsFor: 'instance creation' stamp: 'lr 4/3/2011 14:58'!on: aParser limit: aLimitParser	^ (self on: aParser) setLimit: aLimitParser! !!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/4/2011 18:46'!children	^ Array with: parser with: limit! !!PPLimitedRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/2/2011 10:00'!limit	"Answer the parser that limits (or ends) this repetition."		^ limit! !!PPLimitedRepeatingParser methodsFor: 'private' stamp: 'lr 4/2/2011 10:10'!matchesLimitOn: aStream	| element position |	position := aStream position.	element := limit parseOn: aStream.	aStream position: position.	^ element isPetitFailure not! !!PPLimitedRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/2/2011 10:00'!setLimit: aParser	limit := aParser! !!PPPossessiveRepeatingParser commentStamp: 'lr 4/3/2011 14:35' prior: 34134795!The default repeating parser with standard PEG semantics (i.e. possessive, blind, eager).!!PPPossessiveRepeatingParser methodsFor: 'parsing' stamp: 'lr 4/2/2011 09:52'!parseOn: aStream	| start element elements |	start := aStream position.	elements := OrderedCollection new.	[ elements size < min ] whileTrue: [		(element := parser parseOn: aStream) isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements addLast: element ].	[ elements size < max ] whileTrue: [	 	(element := parser parseOn: aStream) isPetitFailure			ifTrue: [ ^ elements asArray ].		elements addLast: element ].	^ elements asArray! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:06'!initialize	super initialize.	self setMin: 0; setMax: SmallInteger maxVal! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!max	"Answer the maximum number of repetitions."	^ max! !!PPRepeatingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:08'!min	"Answer the minimum number of repetitions."		^ min! !!PPRepeatingParser methodsFor: 'printing' stamp: 'lr 6/3/2010 14:00'!printOn: aStream	super printOn: aStream.	aStream nextPutAll: ' ['; print: min; nextPutAll: ', '; nextPutAll: (max = SmallInteger maxVal		ifTrue: [ '*' ] ifFalse: [ max printString ]); nextPut: $]! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:00'!setMax: anInteger	max := anInteger! !!PPRepeatingParser methodsFor: 'initialization' stamp: 'lr 4/1/2011 21:01'!setMin: anInteger	min := anInteger! !!PPTrimmingParser commentStamp: 'lr 4/6/2010 19:27' prior: 34134948!A parser that silently consumes spaces before and after the delegate parser.!!PPTrimmingParser class methodsFor: 'instance creation' stamp: 'lr 7/31/2010 12:01'!on: aParser trimmer: aTrimParser	^ self new		setParser: aParser;		setTrimmer: aTrimParser;		yourself! !!PPTrimmingParser methodsFor: 'parsing' stamp: 'lr 8/1/2010 17:11'!parseOn: aStream	| position element |	position := aStream position.	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	element := parser parseOn: aStream.	element isPetitFailure ifTrue: [		aStream position: position.		^ element ].	[ (trimmer parseOn: aStream) isPetitFailure ]		whileFalse.	^ element! !!PPTrimmingParser methodsFor: 'initialization' stamp: 'lr 7/31/2010 12:00'!setTrimmer: aParser	trimmer := aParser! !!PPEpsilonParser commentStamp: 'lr 5/15/2008 15:09' prior: 34135088!A parser that consumes nothing and always succeeds.!!PPEpsilonParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:49'!parseOn: aStream	^ nil! !!PPFailingParser commentStamp: '<historical>' prior: 34135197!A parser that consumes nothing and always fails.Instance Variables:	message <String>	The failure message.!!PPFailingParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 19:16'!message: aString	^ self new setMessage: aString! !!PPFailingParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!message	"Answer the error message of the receiving parser."	^ message! !!PPFailingParser methodsFor: 'parsing' stamp: 'lr 5/5/2010 13:57'!parseOn: aStream	^ PPFailure message: message at: aStream position! !!PPFailingParser methodsFor: 'printing' stamp: 'lr 4/16/2010 21:27'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: message! !!PPFailingParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 19:16'!setMessage: aString	message := aString! !!PPListParser commentStamp: '<historical>' prior: 34135360!Abstract parser that parses a list of things in some way (to be specified by the subclasses).Instance Variables:	parsers	<SequenceableCollection of: PPParser>	A sequence of other parsers to delegate to.!!PPChoiceParser commentStamp: 'lr 4/18/2008 15:35' prior: 34135628!A parser that uses the first parser that succeeds.!!PPChoiceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:16'!/ aRule 	^ self copyWith: aRule! !!PPChoiceParser methodsFor: 'parsing' stamp: 'lr 5/22/2010 11:48'!parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change. When all choices fail, the last failure is answered."	| element |	1 to: parsers size do: [ :index |		element := (parsers at: index)			parseOn: aStream.		element isPetitFailure			ifFalse: [ ^ element ] ].	^ element! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 5/3/2010 20:26'!with: aParser	^ self withAll: (Array with: aParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 9/23/2008 18:32'!with: aFirstParser with: aSecondParser	^ self withAll: (Array with: aFirstParser with: aSecondParser)! !!PPListParser class methodsFor: 'instance creation' stamp: 'lr 4/29/2010 10:12'!withAll: aCollection	^ self basicNew setParsers: aCollection! !!PPListParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:37'!children	^ parsers! !!PPListParser methodsFor: 'copying' stamp: 'lr 9/17/2008 22:36'!copyWith: aParser	^ self species withAll: (parsers copyWith: aParser)! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!initialize	super initialize.	self setParsers: #()! !!PPListParser methodsFor: 'copying' stamp: 'lr 5/22/2010 10:26'!postCopy	super postCopy.	parsers := parsers copy! !!PPListParser methodsFor: 'initialization' stamp: 'lr 4/29/2010 10:12'!setParsers: aCollection	parsers := aCollection asArray! !!PPSequenceParser commentStamp: 'lr 4/18/2008 15:34' prior: 34135743!A parser that parses a sequence of parsers.!!PPSequenceParser methodsFor: 'operators' stamp: 'lr 9/17/2008 00:17'!, aRule	^ self copyWith: aRule! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:27'!map: aBlock	^ aBlock numArgs = self children size		ifTrue: [ self ==> [ :nodes | aBlock valueWithArguments: nodes ] ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPSequenceParser methodsFor: 'parsing' stamp: 'lr 5/6/2010 10:47'!parseOn: aStream	"This is optimized code that avoids unnecessary block activations, do not change."		| start elements element |	start := aStream position.	elements := Array new: parsers size.	1 to: parsers size do: [ :index |		element := (parsers at: index) 			parseOn: aStream.		element isPetitFailure ifTrue: [			aStream position: start.			^ element ].		elements at: index put: element ].	^ elements! !!PPSequenceParser methodsFor: 'operators-mapping' stamp: 'lr 1/8/2010 12:01'!permutation: anArrayOfIntegers	"Answer a permutation of the receivers sequence."		anArrayOfIntegers do: [ :index |		(index isInteger and: [ index between: 1 and: parsers size ])			ifFalse: [ self error: 'Invalid permutation index: ' , index printString ] ].	^ self ==> [ :nodes | anArrayOfIntegers collect: [ :index | nodes at: index ] ]! !!PPLiteralParser commentStamp: '<historical>' prior: 34135844!Abstract literal parser that parses some kind of literal type (to be specified by subclasses).Instance Variables:	literal	<Object>	The literal object to be parsed.	message	<String>	The error message to be generated.!!PPLiteralObjectParser commentStamp: '<historical>' prior: 34136128!A parser that accepts a single literal object, such as a character. This is the same as the predicate parser 'PPPredicateParser expect: literal' but slightly more efficient.!!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateObjectParser on: [ :value | literal sameAs: value ] message: message! !!PPLiteralObjectParser methodsFor: 'operators' stamp: 'lr 4/28/2011 20:02'!negate	^ (PPPredicateObjectParser expect: literal message: message) negate! !!PPLiteralObjectParser methodsFor: 'parsing' stamp: 'lr 10/30/2010 11:48'!parseOn: aStream	^ (aStream atEnd not and: [ literal = aStream uncheckedPeek ])		ifFalse: [ PPFailure message: message at: aStream position ]		ifTrue: [ aStream next ]! !!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:30'!on: anObject	^ self on: anObject message: anObject printString , ' expected'! !!PPLiteralParser class methodsFor: 'instance creation' stamp: 'lr 1/7/2010 15:29'!on: anObject message: aString	^ self new initializeOn: anObject message: aString! !!PPLiteralParser methodsFor: 'operators' stamp: 'lr 6/1/2010 22:24'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		self subclassResponsibility! !!PPLiteralParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 13:25'!initializeOn: anObject message: aString	literal := anObject.	message := aString! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!literal	"Answer the parsed literal."	^ literal! !!PPLiteralParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:26'!message	"Answer the failure message."		^ message! !!PPLiteralParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:38'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: literal! !!PPLiteralSequenceParser commentStamp: 'lr 12/4/2009 18:39' prior: 34136373!A parser accepts a sequence of literal objects, such as a String. This is an optimization to avoid having to compose longer sequences from PPSequenceParser.!!PPLiteralSequenceParser methodsFor: 'operators' stamp: 'lr 8/18/2010 20:16'!caseInsensitive	"Answer a parser that can parse the receiver case-insensitive."		literal asUppercase = literal asLowercase ifTrue: [ ^ self ].	^ PPPredicateSequenceParser on: [ :value | literal sameAs: value ] message: message size: size! !!PPLiteralSequenceParser methodsFor: 'initialization' stamp: 'lr 6/1/2010 22:21'!initializeOn: anObject message: aString	super initializeOn: anObject message: aString.	size := literal size! !!PPLiteralSequenceParser methodsFor: 'parsing' stamp: 'lr 10/30/2010 11:48'!parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	literal = result ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: message at: aStream position! !!PPLiteralSequenceParser methodsFor: 'accessing' stamp: 'lr 9/15/2010 11:16'!size	"Answer the sequence size of the receiver."	^ size! !!PPParser class methodsFor: 'instance creation' stamp: 'lr 10/27/2008 11:17'!named: aString	^ self new name: aString! !!PPParser class methodsFor: 'instance creation' stamp: 'lr 4/18/2008 14:00'!new	^ self basicNew initialize! !!PPParser methodsFor: 'operators' stamp: 'lr 9/23/2008 18:32'!, aParser 	"Answer a new parser that parses the receiver followed by aParser."	^ PPSequenceParser with: self with: aParser! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:46'!/ aParser 	"Answer a new parser that parses the receiver, if the receiver fails try with aParser (ordered-choice)."		^ PPChoiceParser with: self with: aParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/12/2010 20:32'!==> aBlock	"Answer a new parser that performs aBlock as action handler on success."	^ PPActionParser on: self block: aBlock! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/12/2010 10:20'!>=> aBlock	"Answer a new parser that wraps the receiving parser with a two argument block. The first argument is the parsed stream, the second argument a continuation block on the delegate parser."	^ PPWrappingParser on: self block: aBlock! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!and	"Answer a new parser (logical and-predicate) that succeeds whenever the receiver does, but never consumes input."	^ PPAndParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 2/19/2010 07:42'!answer: anObject	"Answer a new parser that always returns anObject from a successful parse."	^ self ==> [ :nodes | anObject ]! !!PPParser methodsFor: 'converting' stamp: 'lr 11/29/2011 20:48'!asParser	"Answer the receiving parser."		^ self! !!PPParser methodsFor: 'accessing' stamp: 'lr 10/21/2009 16:38'!children	"Answer a set of child parsers that could follow the receiver."	^ #()! !!PPParser methodsFor: 'operators' stamp: 'lr 12/3/2010 11:34'!def: aParser	"Redefine the receiver as the argument aParser. This method is useful when defining recursive parsers: instantiate a PPUnresolvedParser and later redefine it with another one."	^ self becomeForward: (aParser name: self name)! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:42'!delimitedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated and possibly ended by aParser."		^ (self separatedBy: aParser) , (aParser optional) ==> [ :node |		node second isNil			ifTrue: [ node first ]			ifFalse: [ node first copyWith: node second ] ]! !!PPParser methodsFor: 'operators' stamp: 'lr 4/30/2010 12:13'!end	"Answer a new parser that succeeds at the end of the input and return the result of the receiver."	^ PPEndOfInputParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/15/2008 16:08'!flatten	"Answer a new parser that flattens the underlying collection."		^ PPFlattenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 15:00'!foldLeft: aBlock	"Answer a new parser that that folds the result of the receiver from left-to-right into aBlock. The argument aBlock must take two or more arguments."		| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: 1 put: nodes first.		2 to: nodes size by: size - 1 do: [ :index |			args				replaceFrom: 2 to: size with: nodes startingAt: index;				at: 1 put: (aBlock valueWithArguments: args) ].		args first ]! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/3/2011 14:59'!foldRight: aBlock	"Answer a new parser that that folds the result of the receiver from right-to-left into aBlock. The argument aBlock must take two or more arguments."	| size args |	size := aBlock numArgs.	args := Array new: size.	^ self ==> [ :nodes |		args at: size put: nodes last.		nodes size - size + 1 to: 1 by: 1 - size do: [ :index |			args				replaceFrom: 1 to: size - 1 with: nodes startingAt: index;				at: size put: (aBlock valueWithArguments: args) ].		args at: size ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!hasProperty: aKey	"Test if the property aKey is present."		^ properties notNil and: [ properties includesKey: aKey ]! !!PPParser methodsFor: 'initialization' stamp: 'lr 4/24/2008 10:33'!initialize! !!PPParser methodsFor: 'testing' stamp: 'lr 8/6/2010 16:44'!isPetitParser	^ true! !!PPParser methodsFor: 'testing' stamp: 'lr 10/27/2008 11:28'!isUnresolved	^ false! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 5/6/2011 20:28'!map: aBlock	"Answer a new parser that works on the receiving sequence an passes in each element as a block argument."		^ aBlock numArgs = 1		ifTrue: [ self ==> aBlock ]		ifFalse: [ self error: aBlock numArgs asString , ' arguments expected.' ]! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/8/2010 00:30'!matches: anObject	"Answer if anObject can be parsed by the receiver."		^ (self parse: anObject) isPetitFailure not! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answered an OrderedCollection of the matched parse-trees."	| result |	result := OrderedCollection new.	self 		matchesIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 3/1/2010 21:51'!matchesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Make sure to always consume exactly one character with each step, to not miss any match."	((self and ==> aBlock , #any asParser) / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of the matched parse-trees. Skip over matches."	| result |	result := OrderedCollection new.	self 		matchesSkipIn: anObject		do: [ :each | result addLast: each ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 8/16/2011 07:26'!matchesSkipIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock for each match with the matched parse-tree as the argument. Skip over matches."	(self ==> aBlock / #any asParser) star parse: anObject! !!PPParser methodsFor: 'parsing' stamp: 'lr 6/4/2011 18:12'!matchingRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:41'!matchingRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Evaluate aBlock with the range of each match (index of first character to: index of last character)."	self token		matchesIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'parsing' stamp: 'DamienCassou 10/29/2011 19:18'!matchingSkipRangesIn: anObject	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Answer an OrderedCollection of ranges of each match (index of first character to: index of last character)."		| result |	result := OrderedCollection new.	self		matchingSkipRangesIn: anObject		do: [ :value | result addLast: value ].	^ result! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/25/2013 23:42'!matchingSkipRangesIn: anObject do: aBlock	"Search anObject repeatedly for the matches of the receiver. Skip over matches. Evaluate aBlock with the range of each match (index of first character to: index of last character)."		self token		matchesSkipIn: anObject		do: [ :token | aBlock value: (token start to: token stop) ]! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!max: anInteger	"Answer a new parser that parses the receiver at most anInteger times."		^ self star setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!max: anInteger greedy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!max: anInteger lazy: aParser	"Answer a new parser that parses the receiver at most anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMax: anInteger! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 16:34'!memoized	"Answer a new memoized parser, for refraining redundant computations. This ensures polynomial time O(n^4) for left-recursive grammars and O(n^3) for non left-recursive grammars in the worst case. Not necessary for most grammars that are carefully written and in O(n) anyway."		^ PPMemoizedParser on: self! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:02'!min: anInteger	"Answer a new parser that parses the receiver at least anInteger times."		^ self star setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: anInteger greedy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: anInteger lazy: aParser	"Answer a new parser that parses the receiver at least anInteger times until it reaches aParser. This is a lazy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: anInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!min: aMinInteger max: aMaxInteger	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times."		^ self star setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:56'!min: aMinInteger max: aMaxInteger greedy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starGreedy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/3/2011 14:57'!min: aMinInteger max: aMaxInteger lazy: aParser	"Answer a new parser that parses the receiver at least aMinInteger and at most aMaxInteger times until it reaches aParser. This is a greedy non-blind implementation. aParser is not consumed."		^ (self starLazy: aParser) setMin: aMinInteger; setMax: aMaxInteger! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:35'!name	"Answer the production name of the receiver."		^ self propertyAt: #name ifAbsent: [ nil ]! !!PPParser methodsFor: 'accessing' stamp: 'lr 4/19/2010 10:38'!name: aString	self propertyAt: #name put: aString! !!PPParser methodsFor: 'operators' stamp: 'lr 2/19/2010 07:36'!negate	"Answer a new parser consumes any input token but the receiver."		^ self not , #any asParser ==> #second! !!PPParser methodsFor: 'operators' stamp: 'lr 5/31/2010 15:12'!not	"Answer a new parser (logical not-predicate) that succeeds whenever the receiver fails, but never consumes input."	^ PPNotParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 9/1/2010 22:03'!optional	"Answer a new parser that parses the receiver, if possible."	^ PPOptionalParser on: self! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:53'!parse: anObject	"Parse anObject with the receiving parser and answer the parse-result or an instance of PPFailure."		^ self parseOn: anObject asPetitStream! !!PPParser methodsFor: 'parsing' stamp: 'lr 10/29/2010 17:05'!parse: anObject onError: aBlock	"Parse anObject with the receiving parser and answer the parse-result or answer the result of evaluating aBlock. Depending on the number of arguments of the block it is simply evaluated, evaluated with the failure object, or evaluated with the error message and position."		| result |	result := self parse: anObject.	result isPetitFailure		ifFalse: [ ^ result ].	aBlock numArgs = 0		ifTrue: [ ^ aBlock value ].	aBlock numArgs = 1		ifTrue: [ ^ aBlock value: result ].	^ aBlock value: result message value: result position! !!PPParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 22:18'!parseOn: aStream	"Parse aStream with the receiving parser and answer the parse-result or an instance of PPFailure. Override this method in subclasses to specify custom parse behavior. Do not call this method from outside, instead use #parse:."		self subclassResponsibility! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:03'!plus	"Answer a new parser that parses the receiver one or more times."	^ self star setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusGreedy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ (self starGreedy: aParser) setMin: 1! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/1/2011 21:04'!plusLazy: aParser	"Answer a new parser that parses the receiver one or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ (self starLazy: aParser) setMin: 1! !!PPParser methodsFor: 'copying' stamp: 'lr 4/19/2010 10:33'!postCopy	super postCopy.	properties := properties copy! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printNameOn: aStream	self name isNil		ifTrue: [ aStream print: self hash ]		ifFalse: [ aStream nextPutAll: self name ]! !!PPParser methodsFor: 'printing' stamp: 'lr 4/16/2010 16:36'!printOn: aStream	super printOn: aStream.	aStream nextPut: $(.	self printNameOn: aStream.	aStream nextPut: $)! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey	"Answer the property value associated with aKey."		^ self propertyAt: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsent: aBlock	"Answer the property value associated with aKey or, if aKey isn't found, answer the result of evaluating aBlock."		^ properties isNil		ifTrue: [ aBlock value ]		ifFalse: [ properties at: aKey ifAbsent: aBlock ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:32'!propertyAt: aKey ifAbsentPut: aBlock	"Answer the property associated with aKey or, if aKey isn't found store the result of evaluating aBlock as new value."		^ self propertyAt: aKey ifAbsent: [ self propertyAt: aKey put: aBlock value ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!propertyAt: aKey put: anObject	"Set the property at aKey to be anObject. If aKey is not found, create a new entry for aKey and set is value to anObject. Answer anObject."	^ (properties ifNil: [ properties := Dictionary new: 1 ])		at: aKey put: anObject! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey	"Remove the property with aKey. Answer the property or raise an error if aKey isn't found."		^ self removeProperty: aKey ifAbsent: [ self error: 'Property not found' ]! !!PPParser methodsFor: 'accessing-properties' stamp: 'lr 4/19/2010 10:33'!removeProperty: aKey ifAbsent: aBlock	"Remove the property with aKey. Answer the value or, if aKey isn't found, answer the result of evaluating aBlock."		| answer |	properties isNil ifTrue: [ ^ aBlock value ].	answer := properties removeKey: aKey ifAbsent: aBlock.	properties isEmpty ifTrue: [ properties := nil ].	^ answer! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/19/2010 07:56'!separatedBy: aParser	"Answer a new parser that parses the receiver one or more times, separated by aParser."		^ (PPSequenceParser with: self with: (PPSequenceParser with: aParser with: self) star) ==> [ :nodes |		| result |		result := Array new: 2 * nodes second size + 1.		result at: 1 put: nodes first.		nodes second 			keysAndValuesDo: [ :index :pair | result replaceFrom: 2 * index to: 2 * index + 1 with: pair startingAt: 1 ].		result ]! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:02'!star	"Answer a new parser that parses the receiver zero or more times. This is a greedy and blind implementation that tries to consume as much input as possible and it does not consider what comes afterwards."	^ PPPossessiveRepeatingParser on: self! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starGreedy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a greedy non-blind implementation of the star operator. aParser is not consumed."		^ PPGreedyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 4/2/2011 10:01'!starLazy: aParser	"Answer a new parser that parses the receiver zero or more times until it reaches aParser. This is a lazy non-blind implementation of the star operator. aParser is not consumed."		^ PPLazyRepeatingParser on: self limit: aParser! !!PPParser methodsFor: 'operators-repeating' stamp: 'lr 9/15/2010 09:34'!times: anInteger	"Answer a new parser that parses the receiver exactly anInteger times."		^ self min: anInteger max: anInteger! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 6/29/2010 14:25'!token	"Answer a new parser that transforms the input to a token."		^ PPTokenParser on: self! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 4/6/2010 19:26'!token: aTokenClass	"Answer a new parser that transforms the input to a token of class aTokenClass."		^ self token tokenClass: aTokenClass! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/31/2010 12:06'!trim	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trimSpaces! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trim: aParser	"Answer a new parser that consumes and ignores aParser repeatedly before and after the receiving parser."		^ PPTrimmingParser on: self trimmer: aParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimBlanks	"Answer a new parser that consumes blanks before and after the receiving parser."		^ self trim: #blank asParser! !!PPParser methodsFor: 'operators-mapping' stamp: 'lr 7/11/2011 11:03'!trimSpaces	"Answer a new parser that consumes spaces before and after the receiving parser."		^ self trim: #space asParser! !!PPParser methodsFor: 'operators-convenience' stamp: 'lr 2/25/2012 16:54'!withoutSeparators	"Filters out the separators from a parse result produced by one of the productions #delimitedBy: or #separatedBy:."		^ self ==> [ :items |		| result |		result := Array new: items size + 1 // 2.		1 to: result size do: [ :index | result at: index put: (items at: 2 * index - 1) ].		result ]! !!PPParser methodsFor: 'operators' stamp: 'lr 10/23/2008 14:05'!wrapped	"Answer a new parser that is simply wrapped."		^ PPDelegateParser on: self! !!PPParser methodsFor: 'operators' stamp: 'lr 4/14/2010 11:53'!| aParser	"Answer a new parser that either parses the receiver or aParser. Fail if both pass or fail (exclusive choice, unordered choice)."	^ (self not , aParser) / (aParser not , self) ==> #second! !!PPPluggableParser commentStamp: '<historical>' prior: 34136589!A pluggable parser that passes the parser stream into a block. This enables users to perform manual parsing or to embed other parser frameworks into PetitParser.Instance Variables:	block	<BlockClosure>	The pluggable one-argument block.!!PPPluggableParser class methodsFor: 'instance creation' stamp: 'lr 5/2/2010 16:52'!on: aBlock	^ self new initializeOn: aBlock! !!PPPluggableParser methodsFor: 'accessing' stamp: 'lr 4/30/2010 11:10'!block	"Answer the pluggable block."	^ block! !!PPPluggableParser methodsFor: 'initialization' stamp: 'lr 5/2/2010 16:52'!initializeOn: aBlock	block := aBlock! !!PPPluggableParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:54'!parseOn: aStream	| position result |	position := aStream position.	result := block value: aStream.	result isPetitFailure		ifTrue: [ aStream position: position ].	^ result! !!PPPredicateParser commentStamp: '<historical>' prior: 34136888!An abstract parser that accepts if a given predicate holds.Instance Variables:	predicate	<BlockClosure>	The block testing for the predicate.	predicateMessage	<String>	The error message of the predicate.	negated	<BlockClosure>	The block testing for the negation of the predicate.	negatedMessage	<String>	The error message of the negated predicate.!!PPPredicateObjectParser commentStamp: '<historical>' prior: 34137306!A parser that accepts if a given predicate on one element of the input sequence holds.!!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 6/12/2010 09:10'!any	^ self		on: [ :each | true ] message: 'input expected'		negated: [ :each | false ] message: 'no input expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyExceptAnyOf: aCollection	^ self		on: [ :each | (aCollection includes: each) not ] message: 'any except ' , aCollection printString , ' expected'		negated: [ :each | aCollection includes: each ] message: aCollection printString ,  ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 4/1/2011 20:05'!anyOf: aCollection	^ self		on: [ :each | aCollection includes: each ] message: 'any of ' , aCollection printString , ' expected'		negated: [ :each | (aCollection includes: each) not ] message: 'none of ' , aCollection printString ,  'expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 6/12/2010 09:10'!between: min and: max	^ self		on: [ :each | each >= min and: [ each <= max ] ] message: min printString , '..' , max printString , ' expected'		negated: [ :each | each < min or: [ each > max ] ] message: min printString , '..' , max printString , ' not expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!blank	^ self chars: (String with: Character space with: Character tab) message: 'blank expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!char: aCharacter	^ self expect: aCharacter message: (String with: $" with: aCharacter with: $") , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 10:57'!char: aCharacter message: aString	^ self expect: aCharacter message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!chars: aCollection message: aString	^ self on: (PPCharSetPredicate on: [ :char | aCollection includes: char ]) message: aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:02'!cr	^ self char: Character cr message: 'carriage return expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!digit	^ self on: (PPCharSetPredicate on: [ :char | char isDigit ]) message: 'digit expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject	^ self expect: anObject message: anObject printString , ' expected'! !!PPPredicateObjectParser class methodsFor: 'factory-objects' stamp: 'lr 8/25/2010 10:57'!expect: anObject message: aString	^ self 		on: [ :each | each = anObject ] message: aString		negated: [ :each | each ~= anObject ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!hex	^ self 		on: (PPCharSetPredicate on: [ :char | 			(char between: $0 and: $9) 				or: [ (char between: $a and: $f) 				or: [ (char between: $A and: $F) ] ] ])		message: 'hex digit expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:05'!letter	^ self on: (PPCharSetPredicate on: [ :char | char isLetter ]) message: 'letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 6/12/2010 09:10'!lf	^ self char: Character lf! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!lowercase	^ self on: (PPCharSetPredicate on: [ :char | char isLowercase ]) message: 'lowercase letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!newline	^ self chars: (String with: Character cr with: Character lf) message: 'newline expected'! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString! !!PPPredicateObjectParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:10'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!punctuation	^ self chars: '.,"''?!!;:#$%&()*+-/<>=@[]\^_{}|~' message: 'punctuation expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!space	^ self on: (PPCharSetPredicate on: [ :char | char isSeparator ]) message: 'separator expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:04'!tab	^ self char: Character tab message: 'tab expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!uppercase	^ self on: (PPCharSetPredicate on: [ :char | char isUppercase ]) message: 'uppercase letter expected'! !!PPPredicateObjectParser class methodsFor: 'factory-chars' stamp: 'lr 8/25/2010 11:06'!word	^ self on: (PPCharSetPredicate on: [ :char | char isAlphaNumeric ]) message: 'letter or digit expected'! !!PPPredicateObjectParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:12'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString! !!PPPredicateObjectParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:12'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage 		negated: predicate message: predicateMessage! !!PPPredicateObjectParser methodsFor: 'parsing' stamp: 'lr 9/30/2010 11:05'!parseOn: aStream	^ (aStream atEnd not and: [ predicate value: aStream uncheckedPeek ])		ifFalse: [ PPFailure message: predicateMessage at: aStream position ]		ifTrue: [ aStream next ]! !!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!block	"Answer the predicate block of the receiver."		^ predicate! !!PPPredicateParser methodsFor: 'accessing' stamp: 'lr 5/2/2010 13:36'!message	"Answer the failure message."		^ predicateMessage! !!PPPredicateParser methodsFor: 'printing' stamp: 'lr 5/2/2010 13:37'!printNameOn: aStream	super printNameOn: aStream.	aStream nextPutAll: ', '; print: predicateMessage! !!PPPredicateSequenceParser commentStamp: '<historical>' prior: 34137460!A parser that accepts if a given predicate on an arbitrary number of elements of the input sequence holds.Instance Variables:	size	<Integer>	The number of elements to consume.!!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger 	^ self new initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger! !!PPPredicateSequenceParser class methodsFor: 'instance creation' stamp: 'lr 6/12/2010 09:14'!on: aBlock message: aString size: anInteger	^ self on: aBlock message: aString negated: [ :each | (aBlock value: each) not ] message: 'no ' , aString size: anInteger ! !!PPPredicateSequenceParser methodsFor: 'initialization' stamp: 'lr 6/12/2010 09:13'!initializeOn: aBlock message: aString negated: aNegatedBlock message: aNegatedString size: anInteger	predicate := aBlock.	predicateMessage := aString.	negated := aNegatedBlock.	negatedMessage := aNegatedString.	size := anInteger ! !!PPPredicateSequenceParser methodsFor: 'operators' stamp: 'lr 6/12/2010 09:14'!negate	"Answer a parser that is the negation of the receiving predicate parser."		^ self class 		on: negated message: negatedMessage		negated: predicate message: predicateMessage		size: size! !!PPPredicateSequenceParser methodsFor: 'parsing' stamp: 'lr 6/12/2010 09:25'!parseOn: aStream	| position result |	position := aStream position.	result := aStream next: size.	(result size = size and: [ predicate value: result ])		ifTrue: [ ^ result ].	aStream position: position.	^ PPFailure message: predicateMessage at: aStream position! !!PPPredicateSequenceParser methodsFor: 'accessing' stamp: 'lr 6/12/2010 08:58'!size	"Answer the sequence size of the receiver."	^ size! !!PPUnresolvedParser commentStamp: 'lr 11/28/2009 18:50' prior: 34137706!This is a temporary placeholder or forward reference to a parser that has not been defined yet. If everything goes well it will eventually be replaced with the real parser instance.!!PPUnresolvedParser methodsFor: 'testing' stamp: 'lr 10/27/2008 11:29'!isUnresolved	^ true! !!PPUnresolvedParser methodsFor: 'parsing' stamp: 'lr 2/7/2010 20:51'!parseOn: aStream	self error: self printString , ' need to be resolved before execution.'! !!PPToken commentStamp: 'lr 2/25/2013 23:34' prior: 34137943!PPToken represents a parsed part of the input stream. Contrary to a simple String it remembers where it came from, the original collection, its start and stop position and its parse value.Instance Variables:	collection	<SequenceableCollection>	The collection this token comes from.	start	<Integer>	The start position in the collection.	stop	<Integer>	The stop position in the collection.	value <Object>	The parse result.!!PPToken class methodsFor: 'initialization' stamp: 'lr 11/29/2011 20:42'!initialize	"Platform independent newline sequence. LF: Unix, CR+LF: Windows, and CR: Apple."	NewLineParser := (Character lf asParser) / (Character cr asParser , Character lf asParser optional)! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 4/6/2010 20:58'!new	self error: 'Token can only be created using a dedicated constructor.'! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:36'!on: aSequenceableCollection	^ self on: aSequenceableCollection start: 1 stop: aSequenceableCollection size value: nil! !!PPToken class methodsFor: 'instance creation' stamp: 'lr 2/25/2013 23:39'!on: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	^ self basicNew 		initializeOn: aSequenceableCollection		start: aStartInteger stop: aStopInteger		value: anObject! !!PPToken methodsFor: 'comparing' stamp: 'lr 2/26/2013 00:34'!= anObject	^ self class = anObject class and: [ self parsedValue = anObject parsedValue ]! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:34'!collection	"Answer the underlying collection of this token."	^ collection! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:40'!column	"Answer the column number of this token in the underlying collection."		| position |	position := 0.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ start - position ].		position := stream position ] asParser		/ #any asParser) star			parse: collection.	 ^ start - position! !!PPToken methodsFor: 'copying' stamp: 'lr 2/26/2013 00:34'!copyFrom: aStartInteger to: aStopInteger	^ self class on: collection start: start + aStartInteger - 1 stop: stop + aStopInteger - 3 value: value! !!PPToken methodsFor: 'comparing' stamp: 'lr 2/26/2013 00:34'!hash	^ self parsedValue hash! !!PPToken methodsFor: 'initialization' stamp: 'lr 2/25/2013 23:36'!initializeOn: aSequenceableCollection start: aStartInteger stop: aStopInteger value: anObject	collection := aSequenceableCollection.	start := aStartInteger.	stop := aStopInteger.	value := anObject! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!inputValue	"Answer the consumed input of this token."	^ collection copyFrom: start to: stop! !!PPToken methodsFor: 'querying' stamp: 'lr 9/7/2011 20:41'!line	"Answer the line number of this token in the underlying collection."		| line |	line := 1.	(NewLineParser , [ :stream |		start <= stream position			ifTrue: [ ^ line ].		line := line + 1 ] asParser		/ #any asParser) star			parse: collection.	^ line! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:32'!parsedValue	"Answer the parsed value of this token."	^ value! !!PPToken methodsFor: 'printing' stamp: 'lr 2/26/2013 00:37'!printOn: aStream	super printOn: aStream.	aStream nextPut: $[; print: self start; nextPut: $,; print: self stop; nextPut: $].	aStream nextPut: $(; print: self parsedValue; nextPut: $)! !!PPToken methodsFor: 'accessing' stamp: 'lr 2/25/2013 23:56'!size	"Answer the size of this token in the underlying collection."	^ stop - start + 1! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!start	"Answer the start position of this token in the underlying collection."	^ start! !!PPToken methodsFor: 'accessing' stamp: 'lr 6/15/2010 23:33'!stop	"Answer the stop position of this token in the underlying collection."		^ stop! !!PPToken methodsFor: 'accessing-values' stamp: 'lr 2/26/2013 00:34'!value	self notify: 'Token>>#value is no longer supported. Instead use Token>>#inputValue or the more pragmatic #parsedValue.'.	^ self inputValue! !"PetitParser"!"PetitTests"!----SNAPSHOT----2016-03-01T22:57:40.319169+01:00 Pharo4.0.image priorSource: 572177!----STARTUP----2016-03-03T14:32:32.006438+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-03-03T16:28:22.967438+01:00 Pharo4.0.image priorSource: 755705!----STARTUP----2016-03-14T18:44:14.915332+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #StructureAnalyzer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureAnalyzer'!----STARTUP----2016-03-15T07:59:55.786163+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #StructureFinder	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #InputLoader	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Tokanizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Analyzer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #AnalzingMethod	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!AnalzingMethod methodsFor: 'as yet unclassified' stamp: 'CedricWalker 3/15/2016 09:29'!analyze	"comment stating purpose of message" ^self subclassResponsibility ! !(Smalltalk globals at: #AnalzingMethod) rename: #AbstractAnalzingMethod!!AbstractAnalzingMethod commentStamp: '<historical>' prior: 0!Please comment me using the following template inspired by Class Responsibility Collaborator (CRC) design:For the Class part:  State the name of the class with one line description: For example, I'm xxx the root of the hierarchy of visitor objects.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Implementation Points!!AbstractAnalzingMethod commentStamp: 'CedricWalker 3/15/2016 09:32' prior: 34311625!!----SNAPSHOT----2016-03-15T09:32:46.503163+01:00 Pharo4.0.image priorSource: 755900!----STARTUP----2016-03-15T11:46:55.82364+01:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!AbstractTokanizingMethod methodsFor: 'as yet unclassified' stamp: 'CedricWalker 3/15/2016 11:49'!tokanize	"comment stating purpose of message"^ self subclassResponsibility! !----SNAPSHOT----2016-03-15T12:01:34.46064+01:00 Pharo4.0.image priorSource: 757992!----STARTUP----2016-03-16T18:00:01.774384+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:01' prior: 34319174!projectAsStream: t1	| t2 |	t2 := String new writeStream.	t1 asFileReference allChildren		do: [ :t3 | 			t3 isFile				ifTrue: [ t2 nextPutAll: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:02' prior: 34313081!projectAsStream: t1	| t2 |	t2 := String new writeStream.	(t1 asFileReference allChildren)		do: [ :t3 | 			t3 isFile				ifTrue: [ t2 nextPutAll: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:02' prior: 34313367!projectAsStream: t1	| t2 |	t2 := String new writeStream.	(t1 asFileReference allChildren)		do: [ :t3 | 			(t3 isFile)				ifTrue: [ t2 nextPutAll: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:11' prior: 34313655!projectAsStream: t1	| t2 |	t2 := String new writeStream.	(t1 asFileReference allChildren)		do: [ :t3 | 			(t3 isFile)				ifTrue: [ t2 nextPut: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:12' prior: 34313945!projectAsStream: t1	| t2 |	t2 := String new WriteStream.	(t1 asFileReference allChildren)		do: [ :t3 | 			(t3 isFile)				ifTrue: [ t2 nextPut: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:13' prior: 34314232!projectAsStream: projectPath	| t2 |	t2 := String new WriteStream.	(projectPath asFileReference allChildren)		do: [ :t3 | 			(t3 isFile)				ifTrue: [ t2 nextPut: (self loadFromFile: t3) ] ].	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:15' prior: 34314519!projectAsStream: projectPath	| stream |	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPut: (self loadFromFile: reference) ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:15' prior: 34314824!projectAsStream: projectPath	| stream |	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (self loadFromFile: reference) ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:22' prior: 34315167!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference) ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:27' prior: 34316911!loadFromFile: t1	| t2 t3 |	t2 := t1 asFileReference writeStream.	t3 := t2 contents.	t2 close.	^ t2 contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 18:59' prior: 34315916!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents.	reference close.	^ reference contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 19:00' prior: 34316123!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents.	reference close.	^ result! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 19:04' prior: 34316377!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents, ' '.	reference close.	^ result! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 19:20' prior: 34316618!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents , '--> new File ' cr.	reference close.	^ result! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/16/2016 19:20' prior: 34316864!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents , ' --> new File '.	reference close.	^ result! !----SNAPSHOT----2016-03-16T20:23:57.710384+01:00 Pharo4.0.image priorSource: 765043!----SNAPSHOT----2016-03-16T23:31:59.543384+01:00 Pharo4.0.image priorSource: 762863!----STARTUP----2016-03-18T14:30:39.787581+01:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:48' prior: 34317126!loadFromFile: path	| reference result |	reference := path asFileReference writeStream.	result := reference contents.	reference close.	^ result! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:49' prior: 34315513!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference, $cr asString) ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:50' prior: 34317908!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference), $cr asString] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:51' prior: 34318325!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:52' prior: 34318741!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference), $cr asString ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:53' prior: 34319143!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference), Character cr asString ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:54' prior: 34319560!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: '-->file Start', Character cr asString, (inputLoader					loadFromFile: reference), Character cr asString, '--> file end' ] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:54' prior: 34319986!projectAsStream: projectPath	| stream inputLoader|	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: '-->file Start', Character cr asString, (inputLoader					loadFromFile: reference), Character cr asString, '--> file end', Character cr asString] ].	^ stream contents.! !!InputLoader methodsFor: 'loading' stamp: 'CedricWalker 3/18/2016 14:56' prior: 34320468!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := InputLoader  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !----SNAPSHOT----2016-03-18T15:11:11.904581+01:00 Pharo4.0.image priorSource: 762949!----STARTUP----2016-04-07T14:52:11.91753+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #Anonymizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 14:59'!anonymize: aString using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token|	token := aToken.	! !!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 15:08' prior: 34321832!anonymize: aString using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack|	token := aToken.	! !!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 15:15'!anonymizeOuter: aString using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack|	token := aToken.	! !----SNAPSHOT----2016-04-07T16:04:41.16753+02:00 Pharo4.0.image priorSource: 767011!----STARTUP----2016-04-07T17:24:19.626442+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-04-07T17:24:38.555442+02:00 Pharo4.0.image priorSource: 768104!----STARTUP----2016-04-07T17:24:11.717256+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:30' prior: 34322355!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	token := aToken.		aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: streamElement]].		^anonymizedStream.! !Object subclass: #StreamElement	instanceVariableNames: 'position character'	classVariableNames: ''	category: 'StructureFinder'!!StreamElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:31'!position: aInteger	position := aInteger.! !!StreamElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:32'!position	^position.	! !!StreamElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:32'!character: aCharacter	"comment stating purpose of message"	character := aCharacter.! !!StreamElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:33'!character	"comment stating purpose of message"	^character.! !(Smalltalk globals at: #StreamElement) rename: #StackElement!!StackElement methodsFor: 'accessing' stamp: 'CedricWalker 4/7/2016 17:37'!createAndAdd:aCharacter at: anInteger	"comment stating purpose of message"	self new.	self position: anInteger.	self character: aCharacter.! !!StackElement methodsFor: 'accessing' stamp: 'CedricWalker 4/7/2016 17:39'!s! !StackElement removeSelector: #createAndAdd:at:!StackElement removeSelector: #s!!StackElement class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:39'!createAndAdd:aCharacter at: anInteger	"comment stating purpose of message"	self new.	self position: anInteger.	self character: aCharacter.! !!StackElement class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:42' prior: 34324603!createAndAdd:aCharacter at: anInteger	"comment stating purpose of message"	|stackElement|	stackElement := StackElement new.	stackElement position: anInteger.	stackElement character: aCharacter.	^self.! !!StackElement class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:42' prior: 34324857!createAndAdd:aCharacter at: anInteger	"comment stating purpose of message"	|stackElement|	stackElement := StackElement new.	stackElement position: anInteger.	stackElement character: aCharacter.	^stackElement.! !!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/7/2016 17:48' prior: 34323025!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	token := aToken.	structureStack := Stack new.	aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: (StackElement createAndAdd: streamElement at: aStream position)]].		^anonymizedStream.! !----STARTUP----2016-04-09T15:32:23.190015+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:33' prior: 34322355!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	token := aToken.		aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: streamElement]].		^anonymizedStream.! !Object subclass: #StructureFinder	instanceVariableNames: 'inputPath outputPath'	classVariableNames: ''	category: 'StructureFinder'!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:35'!inputPath: aString	"comment stating purpose of message"	inputPath := aString.! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:35'!outputPath: aString	"comment stating purpose of message"	outputPath := aString.! !(Smalltalk globals at: #InputLoader) rename: #FileHandler!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 4/9/2016 15:36' prior: 34320972!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !!StructureFinder methodsFor: 'accessing' stamp: 'CedricWalker 4/9/2016 15:38'!run	"comment stating purpose of message"	| inputLoader path stream input anonymizedStream anonymizer|	inputLoader := FileHandler new.	stream := inputLoader projectAsStream: inputPath.	"stream contents."	anonymizer := Anonymizer new.	anonymizedStream := anonymizer anonymizeOuter: stream using: 'parameter'.	anonymizedStream contents.! !!StructureFinder methodsFor: 'accessing' stamp: 'CedricWalker 4/9/2016 15:39' prior: 34327627!run	"comment stating purpose of message"	| inputLoader  stream  anonymizedStream anonymizer|	inputLoader := FileHandler new.	stream := inputLoader projectAsStream: inputPath.	"stream contents."	anonymizer := Anonymizer new.	anonymizedStream := anonymizer anonymizeOuter: stream using: 'parameter'.	anonymizedStream contents.	inputLoader saveToFiles.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:40'!saveToFile:path! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 4/9/2016 15:41' prior: 34327076!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:48'!saveToFile: aStream to: path		path asFileReference writeStreamDo: [:stream| stream nextPutAll: aStream].	! !FileHandler removeSelector: #saveToFile:!!StructureFinder methodsFor: 'accessing' stamp: 'CedricWalker 4/9/2016 15:49' prior: 34328068!run	"comment stating purpose of message"	| inputLoader  stream  anonymizedStream anonymizer|	inputLoader := FileHandler new.	stream := inputLoader projectAsStream: inputPath.	"stream contents."	anonymizer := Anonymizer new.	anonymizedStream := anonymizer anonymizeOuter: stream using: 'parameter'.	anonymizedStream contents.	inputLoader save! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/9/2016 15:50'!saveFile: aStream to: path		path asFileReference writeStreamDo: [:stream| stream nextPutAll: aStream].	! !FileHandler removeSelector: #saveToFile:to:!!StructureFinder methodsFor: 'accessing' stamp: 'CedricWalker 4/9/2016 15:50' prior: 34329432!run	"comment stating purpose of message"	| inputLoader  stream  anonymizedStream anonymizer|	inputLoader := FileHandler new.	stream := inputLoader projectAsStream: inputPath.	"stream contents."	anonymizer := Anonymizer new.	anonymizedStream := anonymizer anonymizeOuter: stream using: 'parameter'.	anonymizedStream contents.	inputLoader saveFile: anonymizedStream to: outputPath.! !----STARTUP----2016-04-11T15:04:44.32698+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!Anonymizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:15' prior: 34322355!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	token := aToken.		aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: streamElement]].		^anonymizedStream.! !Object subclass: #CharacterPairs	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #CharacterPairs	instanceVariableNames: 'pairs'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Pairs	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Pairs	instanceVariableNames: 'char1 char2'	classVariableNames: ''	category: 'StructureFinder'!!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:24'!char1	"comment stating purpose of message"^char1! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:24'!char2	"comment stating purpose of message"^char2! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:24'!char1: aChar char1 := aChar.! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:25'!char2: aCharchar2 := aChar.! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:25' prior: 34331977!char2: aChar	char2 := aChar.! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:25' prior: 34331730!char2	"comment stating purpose of message"	^char2! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:25' prior: 34331596!char1	"comment stating purpose of message"	^char1! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:25' prior: 34331864!char1: aChar	char1 := aChar.! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:27'!hasCharacterPair: aChar	|aBoolean|	pairs do: [:pair|   ]! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:29' prior: 34332658!hasCharacterPair: aChar	|aBoolean|	aBoolean := Boolean new.	pairs do: [:pair|  ]! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:31' prior: 34332825!hasCharacterPair: aChar	|aBoolean|	aBoolean := false.	pairs do: [:pair|  ]! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:33' prior: 34333017!hasCharacterPair: aChar	|aBoolean|	aBoolean := false.	pairs do: [:pair| (aChar = (pairs char1)) or:  (aChar = (pairs char2))]! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:33' prior: 34333203!hasCharacterPair: aChar	|aBoolean|	aBoolean := false.	pairs do: [:pair| (aChar = (pairs char1)) or:  (aChar = (pairs char2)) ifTrue: [aBoolean := true]]! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:33' prior: 34333440!hasCharacterPair: aChar	|aBoolean|	aBoolean := false.	pairs do: [:pair| (aChar = (pairs char1)) or:  (aChar = (pairs char2)) ifTrue: [aBoolean := true]].! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:34' prior: 34333704!hasCharacterPair: aChar	|aBoolean|	aBoolean := false.	pairs do: [:pair| (aChar = (pairs char1)) or:  (aChar = (pairs char2)) ifTrue: [aBoolean := true]].	^aBoolean.! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:35'!pairs	"comment stating purpose of message" 	! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:36' prior: 34334230!pairs	"comment stating purpose of message" 	(pairs = nil) ifTrue: [pairs initializePairs].! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:36' prior: 34334385!pairs	"comment stating purpose of message" 	(pairs = nil) ifTrue: [self initializePairs].! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:37' prior: 34334586!pairs	"comment stating purpose of message" 	(pairs = nil) ifTrue: [self initializePairs].	^pairs! !!Pairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:43'!setPair: aChar1 and: aChar2	char1 := aChar1.	char2 := aChar2.! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 15:44'!initalizeParis"Maybe Later read from a config file"! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 17:19' prior: 34335125!initalizeParis"Maybe Later read from a config file"	|pair1 pair2 pair3 pair4 pair5|	pair1 := Pairs new.	! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 17:48'!initalizePairs"Maybe Later read from a config file"	|pair1 pair2 pair3 pair4 pair5|	pair1 := Pairs new.	! !CharacterPairs removeSelector: #initalizeParis!!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 17:52' prior: 34335487!initalizePairs"Maybe Later read from a config file"	|pair1 pair2 pair3 pair4 pair5|	pair1 := Pairs new.	pair2 := Pairs new.	pair3 := Pairs new.	pair4 := Pairs new.	pair5 := Pairs new.		pair1 setPair: ${ and: $}.	pair2 setPair: $( and: $).	pair3 setPair: $[ and: $].	pair4 setPair: $' and: $'.	pair5 setPair: $" and: $". 	! !!CharacterPairs methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/11/2016 17:56' prior: 34335753!initalizePairs"Maybe Later read from a config file"	|pair1 pair2 pair3 pair4 pair5|	pair1 := Pairs new.	pair2 := Pairs new.	pair3 := Pairs new.	pair4 := Pairs new.	pair5 := Pairs new.		pair1 setPair: ${ and: $}.	pair2 setPair: $( and: $).	pair3 setPair: $[ and: $].	pair4 setPair: $' and: $'.	pair5 setPair: $" and: $".	! !----STARTUP----2016-04-11T18:36:25.378694+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!Anonymizer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:15' prior: 34322355!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	token := aToken.		aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: streamElement]].		^anonymizedStream.! !Stack subclass: #StructureStack	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!StructureStack commentStamp: 'cedricWalker 4/11/2016 20:17' prior: 0!This subclass of a Stack allows to implement some task specific boolean messages.!Object subclass: #StackElement	instanceVariableNames: 'structureChar Position'	classVariableNames: ''	category: 'StructureFinder'!!StackElement methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:19'!structure: aChar at: aInteger	structureChar := aChar.	! !Object subclass: #StackElement	instanceVariableNames: 'structureChar position'	classVariableNames: ''	category: 'StructureFinder'!!StackElement methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:19' prior: 34337568!structure: aChar at: aInteger	structureChar := aChar.	position := aInteger.	! !Object subclass: #StructureChars	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Pair	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Pair	instanceVariableNames: 'aChar'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Pair	instanceVariableNames: 'char1 char2'	classVariableNames: ''	category: 'StructureFinder'!!Pair methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:26'!pair: aChar1 and: aChar2	char1 := aChar1.	char2 := aChar2.! !Object subclass: #StructureChars	instanceVariableNames: 'element 1'	classVariableNames: ''	category: 'StructureFinder'!Smalltalk globals removeClassNamed: #Pair!(Smalltalk globals at: #StructureChars) rename: #StructureChar!Object subclass: #StructureChar	instanceVariableNames: 'element1, element2'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureChar	instanceVariableNames: 'element1 element2 paired?'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureChar	instanceVariableNames: 'element1 element2 isPaired'	classVariableNames: ''	category: 'StructureFinder'!!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:30'!paired	^(element2 = nil)! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:30'!isPaired	^(element2 = nil)! !Object subclass: #StackElement	instanceVariableNames: 'structureElement position'	classVariableNames: ''	category: 'StructureFinder'!StructureChar removeSelector: #paired!!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:31'!pair: aChar1 and: aChar2	element1 := aChar1.	element2 := aChar2.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:31'!setSingleElement! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:31'!setSingleElement: aChar	element1  := aChar.! !Object subclass: #StructureElements	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureElements	instanceVariableNames: 'structureArray'	classVariableNames: ''	category: 'StructureFinder'!!StructureElements methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:33'!structureChars ||! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:34' prior: 34340340!structureChars (structureArray = nil) ifTrue: [structureArray Array new].! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:37' prior: 34340470!structureChars (structureArray = nil) ifTrue: [structureArray := Array new]; ifTrue: [].! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:41'!d! !StructureElements removeSelector: #structureChars!Object subclass: #StructureElements	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!StructureElements class	instanceVariableNames: 'structureArray'!!StructureElements commentStamp: 'cedricWalker 4/11/2016 20:43' prior: 0!All the structure Elements that need to be stored.Could later be read out of a config file.!!StructureElements class methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:43'!initialize	super initialize.	(structureArray = nil) ifTrue: [ structureArray := Array new]! !!StructureElements class methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:43' prior: 34341349!initialize	super initialize.	(structureArray = nil) ifTrue: [ structureArray := Array new].	! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:44' prior: 34341559!initialize	super initialize.	(structureArray = nil) ifTrue: [ structureArray := Array new] ; ifTrue:[structureArray fill].	! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:46' prior: 34341773!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	 ! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:47' prior: 34342018!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:48' prior: 34342213!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	pair1 ! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:49' prior: 34342584!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: ${ and: $}.	pair3 pair: ${ and: $}.	pair4 pair: ${ and: $}.	pair5 pair: ${ and: $}.	! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:49' prior: 34342963!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).	! !!StructureElements commentStamp: 'cedricWalker 4/11/2016 20:49' prior: 34341157!All the structure Elements that need to be stored.Could later be read out of a config file after a heuristic finds them.!!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:50' prior: 34343462!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).		strElement 		! !StructureChar removeSelector: #setSingleElement!!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:50' prior: 34344165!initialize	|pair1 pair2 pair3 pair4 pair5 strElement|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).		strElement setSingleElement: $.		! !!StructureElements class methodsFor: 'class initialization' stamp: 'cedricWalker 4/11/2016 20:52' prior: 34344731!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !----SNAPSHOT----2016-04-11T20:54:38.763694+02:00 Pharo4.0.image priorSource: 768577!(Smalltalk globals at: #InputLoader) rename: #FileHandler!!FileHandler methodsFor: 'loading' stamp: 'cedricWalker 4/11/2016 20:55' prior: 34320972!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !!Anonymizer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:57' prior: 34336745!anonymizeOuter: aStream using: aToken	"Anonymizes a String and leves only a the Structure, replaces parameters whit a special token"	|token structureStack anonymizedStream|	"dummy initalization"	anonymizedStream := Stream new.		token := aToken.	structureStack := StructureStack new.	aStream do: [ :streamElement| (streamElement isStructureElement) ifTrue: [structureStack push: streamElement]].		^anonymizedStream.! !----SNAPSHOT----2016-04-11T20:57:18.889694+02:00 Pharo4.0.image priorSource: 791336!!StructureElements class methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:58'!structureElements	^structureArray! !!StructureElements class methodsFor: 'as yet unclassified' stamp: 'cedricWalker 4/11/2016 20:58'!structureArray	^structureArray! !StructureElements class removeSelector: #structureElements!----QUIT----2016-04-11T20:59:43.151694+02:00 Pharo4.0.image priorSource: 792573!----STARTUP----2016-04-12T11:29:36.554923+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 4/12/2016 12:14' prior: 34346005!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !----STARTUP----2016-04-15T14:28:10.832432+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!FileHandler methodsFor: 'loading' stamp: 'cedricWAlker 4/15/2016 14:48'!saveFile: stream to:path	"comment stating purpose of message"	path asReference WriteStream! !!FileHandler methodsFor: 'loading' stamp: 'cedricWAlker 4/15/2016 14:52' prior: 34348355!saveFile: stream to:path	"comment stating purpose of message"	path asReference writeStreamDo: [ :writeStream | writeStream nextPutAll:  stream].! !!FileHandler methodsFor: 'loading' stamp: 'cedricWAlker 4/15/2016 14:52' prior: 34348541!saveFile: stream to: path	"comment stating purpose of message"	path asReference writeStreamDo: [ :writeStream | writeStream nextPutAll:  stream].! !Object subclass: #KeyWord	instanceVariableNames: 'keyWord'	classVariableNames: ''	category: 'StructureFinder'!!KeyWord methodsFor: 'as yet unclassified' stamp: 'cedricWAlker 4/15/2016 14:56'!isKeyWord:aString	"comment stating purpose of message"^keyWord = aString! !----SNAPSHOT----2016-04-15T16:04:58.241432+02:00 Pharo4.0.image priorSource: 792989!----QUIT----2016-04-15T16:05:05.204432+02:00 Pharo4.0.image priorSource: 794774!----STARTUP----2016-04-18T15:12:41.443774+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StackElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 15:22' prior: 34337866!structure: aChar at: aInteger	structureElement := aChar.	position := aInteger.	! !----SNAPSHOT----2016-04-18T15:22:06.162774+02:00 Pharo4.0.image priorSource: 794860!----SNAPSHOT----2016-04-18T17:15:56.479774+02:00 Pharo4.0.image priorSource: 795240!Object subclass: #StructureTree	instanceVariableNames: 'rootNode'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #AbstractTreeElement	instanceVariableNames: 'parent'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #OrderElement	instanceVariableNames: 'child'	classVariableNames: ''	category: 'StructureFinder'!!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:16'!buildTreeFrom: aStream	"comment stating purpose of message"	|    statements |	statements! !!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:16' prior: 34350299!buildTreeFrom: aStream	"comment stating purpose of message"! !!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:17' prior: 34350499!buildTreeFrom: aStream	"comment stating purpose of message"^rootNode! !Object subclass: #StructureChar	instanceVariableNames: 'element1 element2 isPaired isClosing'	classVariableNames: ''	category: 'StructureFinder'!!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:18' prior: 34345267!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}. 	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:18'!isClosing^isClosing! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:19'!isClosing: aBooleanisClosing := aBoolean! !!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:19' prior: 34351008!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair3 pair: $' and: $'.	pair4 pair: $[ and: $].	pair5 pair: $( and: $).		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:20' prior: 34351870!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: true.	pair3 pair: $' and: $'.	pair3 isClosing: true.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:25' prior: 34352510!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !Smalltalk globals removeClassNamed: #StructureStack!!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:29'!getUniqueInstance	"comment stating purpose of message"	! !!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:30' prior: 34353246!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	! !StructureElements class removeSelector: #initialize!!StructureElements methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:30'!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.! !StructureElements removeSelector: #d!StructureElements class	instanceVariableNames: 'uniqueInstance'!Object subclass: #StructureElements	instanceVariableNames: 'structureArray '	classVariableNames: ''	category: 'StructureFinder'!StructureElements class	instanceVariableNames: ''!Object subclass: #StructureElements	instanceVariableNames: 'structureArray'	classVariableNames: 'uniqueInstance'	category: 'StructureFinder'!!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:33' prior: 34354022!getUniqueInstance	"comment stating purpose of message"	uniqueInstance ifNil:  [  ]! !StructureElements class removeSelector: #structureArray!!StructureElements methodsFor: 'initialization' stamp: 'CedricWalker 4/18/2016 20:34'!structureArray	"comment stating purpose of message"	^structureArray.! !!StructureElements class methodsFor: 'class initialization' stamp: 'CedricWalker 4/18/2016 20:35' prior: 34356141!getUniqueInstance	"comment stating purpose of message"	uniqueInstance ifNil: [ uniqueInstance := self basicNew initialize].       ^uniqueInstance! !AbstractTreeElement subclass: #OrderElement	instanceVariableNames: 'child'	classVariableNames: ''	category: 'StructureFinder'!----SNAPSHOT----2016-04-18T20:37:38.315774+02:00 Pharo4.0.image priorSource: 795326!AbstractTreeElement  subclass: #TreeStructureElement	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!AbstractTreeElement subclass: #TreeOrderElement	instanceVariableNames: 'child'	classVariableNames: ''	category: 'StructureFinder'!Smalltalk globals removeClassNamed: #OrderElement!AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children'	classVariableNames: ''	category: 'StructureFinder'!!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:40'!initialize	"comment stating purpose of message"	rootNode := TreeStructureElement new.! !!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:41'!rootNode	"comment stating purpose of message"^rootNode.! !!TreeStructureElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:43'!children	"comment stating purpose of message"^children ! !!TreeOrderElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/18/2016 20:44'!child^child! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/18/2016 20:45' prior: 34350668!buildTreeFrom: aStream	"comment stating purpose of message"	|inputStream|		inputStream := aStream.^rootNode! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/18/2016 21:00' prior: 34358077!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream |	inputStream := aStream.	structureArray := StructureElements getUniqueInstance.	aStream do: [:chr| (chr )  ].^rootNode! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/18/2016 21:00' prior: 34358284!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream |	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	aStream do: [:chr| (chr )  ].^rootNode! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/18/2016 21:01' prior: 34358592!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream |	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	aStream do: [:chr| (structureArray contains chr)  ].^rootNode! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/18/2016 21:02' prior: 34358915!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream |	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	aStream do: [:chr| (structureArray contains: chr)  ifTrue: [].								]."need to be implemented: structureArray contains, "^rootNode! !----SNAPSHOT----2016-04-18T21:09:28.567774+02:00 Pharo4.0.image priorSource: 802413!!StructureChar commentStamp: 'CedricWalker 4/19/2016 15:18' prior: 0!Container Element for Strucuture Elements, Parenteses must be recocnisted as Opening and Closing, the first Element being the opening one.!!StructureChar commentStamp: 'CedricWalker 4/19/2016 15:20' prior: 34359750!Container Element for Strucuture Elements, Parenteses must be recocnisted as Opening and Closing, the first Element being the opening one.The isPaired Boolean alows further use of non Paired Characters such as $. and ,.!!StructureChar commentStamp: 'CedricWalker 4/19/2016 15:20' prior: 34359967!Container Element for Strucuture Elements, Parenteses must be recocnisted as Opening and Closing, the first Element being the opening one.The isPaired Boolean alows further use of non Paired Characters such as $. and $,.!----STARTUP----2016-04-19T14:35:48.510393+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:21' prior: 34359261!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream |	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	aStream do: [:chr| (structureArray contains: chr)  ifTrue: [].								]."need to be implemented: structureArray contains, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:22' prior: 34360688!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| (structureArray contains: chr)  ifTrue: [].								]."need to be implemented: structureArray contains, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:24' prior: 34361102!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| (structureArray ifContainsReturn: chr)  ifTrue: [						].		]."need to be implemented: structureArray contains, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:24' prior: 34361528!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| (structureArray ifContainsReturn: chr)  ifTrue: [						].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:26' prior: 34361961!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		||		(structureArray ifContainsReturn: chr)  ifNotNil: [						].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:27' prior: 34362402!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		| |		(structureArray ifContainsReturn: chr)  ifNotNil: [						].		]."need to be implemented: structureArray ifcontainsReturn, "! !AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children '	classVariableNames: ''	category: 'StructureTree'!Object subclass: #ContainerElement	instanceVariableNames: 'structureElement position'	classVariableNames: ''	category: 'StructureFinder'!Smalltalk globals removeClassNamed: #StackElement!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:28' prior: 34362853!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		| containerElement|		containerElement := structureArray ifContainsReturn: chr  ifNotNil: [						].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:29' prior: 34363640!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		| containerElement| "check if pointer not overrides Everything"		containerElement := structureArray ifContainsReturn: chr 		containerElement ifNotNil: [						].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:30' prior: 34364126!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		| containerElement| "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [									].		]."need to be implemented: structureArray ifcontainsReturn, "! !AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children structureElement'	classVariableNames: ''	category: 'StructureTree'!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:31'!addChild: aStructureElement! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:33' prior: 34365379!addChild: aStructureElementchildren ifNil: [ children := LinkedList new].children add: aStructureElement.! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:42' prior: 34364675!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.		aStream do: [:chr| 		| containerElement currentNode| "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:43' prior: 34365712!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream lvlCounter currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:43' prior: 34366338!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:45' prior: 34366989!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempNode|				tempNode := TreeOrderElement new.				TreeOrderElement parent: currentNode.				 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:45' prior: 34367629!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempNode|				tempNode := TreeOrderElement new.				TreeOrderElement parent: currentNode.								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!AbstractTreeElement methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/19/2016 15:45'!parent	"comment stating purpose of message"^parent! !!AbstractTreeElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:46'!parent: aTreeNodeparent := aTreeNode.! !AbstractTreeElement subclass: #TreeOrderElement	instanceVariableNames: 'leftChild rightChild'	classVariableNames: ''	category: 'StructureTree'!!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:49'!leftChild^leftChild! !TreeOrderElement removeSelector: #child!!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:50'!rightChild^rightChild! !!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:50'!rightChild: aTreeNode rightChild:=aTreeNode.! !!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:50'!leftChild: aTreeNode leftChild:=aTreeNode.! !----SNAPSHOT----2016-04-19T15:50:51.217393+02:00 Pharo4.0.image priorSource: 805161!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:52' prior: 34368359!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				TreeOrderElement parent: currentNode.								TreeOrderElement leftChild: (TreeStructureElement  new).				 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children containerElement'	classVariableNames: ''	category: 'StructureTree'!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:54'!conatinerElement	"comment stating purpose of message"^containerElement.! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/19/2016 15:54'!conatinerElement: aContainerElement	"comment stating purpose of message"containerElement := aContainerElement.! !----SNAPSHOT----2016-04-19T15:54:37.434393+02:00 Pharo4.0.image priorSource: 815507!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:56' prior: 34370116!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	"current Node is an StructureNode!!"	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				TreeOrderElement parent: currentNode.				TreeOrderElement leftChild: (TreeStructureElement  new).				 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/19/2016 15:56' prior: 34371598!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	"current Node is an StructureNode!!"	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				TreeOrderElement parent: currentNode.				TreeOrderElement leftChild: (tempStructureNode).				currentNode := tempStructureNode				 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !----STARTUP----2016-04-21T15:24:25.407768+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/21/2016 15:48' prior: 34370116!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				tempOrderNode parent: currentNode.								TreeOrderElement leftChild: (TreeStructureElement  new).								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/21/2016 15:49' prior: 34373554!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				tempOrderNode parent: currentNode.								tempOrderNode leftChild: (TreeStructureElement  new).								 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/21/2016 15:50' prior: 34374432!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.				tempOrderNode parent: currentNode.								tempOrderNode leftChild: (tempStructureNode).									 				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/21/2016 15:51' prior: 34375307!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isOpeningChild: chr) ifTrue: [				|tempOrderNode tempStructureNode|				tempOrderNode := TreeOrderElement new.				tempStructureNode := TreeStructureElement  new.								tempOrderNode parent: currentNode.				tempOrderNode leftChild: (tempStructureNode).									 currentNode := tempStructureNode.				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !----SNAPSHOT----2016-04-21T16:41:10.877768+02:00 Pharo4.0.image priorSource: 816989!----QUIT----2016-04-21T16:41:15.785768+02:00 Pharo4.0.image priorSource: 822555!----STARTUP----2016-04-21T16:46:46.502615+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-04-21T17:10:41.251615+02:00 Pharo4.0.image priorSource: 822641!----STARTUP----2016-04-25T16:10:22.650299+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:13' prior: 34376176!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isPaired) ifTrue: [				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild:chr) and: 				(containerElement isOpeningChild: chr) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.					].				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:13' prior: 34377546!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode|	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ (containerElement isPaired) ifTrue: [				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) and: 				(containerElement isOpeningChild: chr) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.					].				].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 16:18' prior: 34339387!isPaired|boolean|	boolean := false.	(element2 = nil) ifFalse: [ boolean := true].	^boolean! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 16:20'!isOpeningElement: chr	^(chr = element1)! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 16:38' prior: 34379846!isOpeningElement: chr	^(chr = element1) and: isClosing.! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:40' prior: 34378595!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: 												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:40' prior: 34380144!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: true.												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:43' prior: 34381222!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: ((containerElement isPaired) and: (currentNode leftChild)). 												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:46' prior: 34382305!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: ((containerElement isPaired) and: (currentNode structureElement = chr)not). 												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:48' prior: 34383443!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray ifcontainsReturn, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:48' prior: 34384597!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains, "! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:48' prior: 34385750!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).												(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:49' prior: 34386903!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode addLevel:structureLevel.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !AbstractTreeElement subclass: #TreeOrderElement	instanceVariableNames: 'leftChild rightChild structureLevel'	classVariableNames: ''	category: 'StructureTree'!!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 16:50'!structureLevel: aInteger structureLevel := aInteger.! !!TreeOrderElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 16:50'!structureLevel  ^structureLevel! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:50' prior: 34388054!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode stuctureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:51' prior: 34389662!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.									tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:51' prior: 34390858!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|								isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).										 currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 16:52'!containerElement	"comment stating purpose of message"^containerElement.! !TreeStructureElement removeSelector: #conatinerElement!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 16:53'!containerElement: aContainerElement	"comment stating purpose of message"containerElement := aContainerElement.! !TreeStructureElement removeSelector: #conatinerElement:!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 16:53' prior: 34392055!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).					currentNode := tempStructureNode.									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 17:03'!returnIfContains: chr	|container|	structureArray do: [ :containerElement | (containerElement contains:chr) ifTrue: [container := containerElement ]].		^container ! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 17:03'!contains:chr^(element1 = chr) or: (element2 = chr)! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 17:04' prior: 34393520!containerElement: aContainerElement	"comment stating purpose of message"containerElement := aContainerElement.! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/25/2016 17:04' prior: 34395035!returnIfContains: chr	|container|	structureArray do: [ :containerElement | (containerElement contains:chr) ifTrue: [container := 	containerElement ]].^container ! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 17:07' prior: 34393784!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).					currentNode := tempStructureNode.									]; ifFalse:[ (containerElement isPaired ) ifTrue: [  					"close level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 17:09' prior: 34395930!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					"needs distinction if higher level exixts..and are closed"					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					tempOrderNode leftChild: (tempStructureNode).					currentNode := tempStructureNode.									]; ifFalse:[ (containerElement isPaired ) ifTrue: [  					"close level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:07' prior: 34397332!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					"needs distinction if higher level exixts..and are closed"					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					currentNode addChild: 					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (containerElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:09' prior: 34398798!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr) or: (containerElement isPaired) and: ((currentNode structureElement = chr)not).								(isOpeningChild) ifTrue:[					"needs distinction if higher level exixts..and are closed"					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (containerElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:12' prior: 34400358!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| containerElement | "check if pointer not overrides Everything"		containerElement := structureArray returnIfContains: chr.		containerElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (containerElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (containerElement isPaired) and: (currentNode structureElement ).								(isOpeningChild) ifTrue:[					"needs distinction if higher level exixts..and are closed"					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: containerElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (containerElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:12' prior: 34401932!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureElement ).								(isOpeningChild) ifTrue:[					"needs distinction if higher level exixts..and are closed"					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: charElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !Smalltalk globals removeClassNamed: #ContainerElement!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:16' prior: 34403534!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureElement ).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode containerElement: charElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:17' prior: 34395448!containerElement: aStructureChar	"comment stating purpose of message"containerElement := aStructureChar.! !AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children structureChar'	classVariableNames: ''	category: 'StructureTree'!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:19'!structureChar: aStructureChar	"comment stating purpose of message"containerElement := aStructureChar.! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:19' prior: 34405157!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureElement ).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: charElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !TreeStructureElement removeSelector: #containerElement:!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:19'!structureChar	"comment stating purpose of message"^containerElement.! !TreeStructureElement removeSelector: #containerElement!AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children structureChar position'	classVariableNames: ''	category: 'StructureTree'!!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:22'!position: aInteger^position := aInteger.! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:23' prior: 34409149!position: aIntegerposition := aInteger.! !!TreeStructureElement methodsFor: 'accessing' stamp: 'CedricWalker 4/25/2016 20:23'!position^position! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:27' prior: 34407217!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: charElement.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:36' prior: 34409536!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.					];ifFalse: [  "add normal structure sign to current level"].												].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:39' prior: 34411042!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 4/25/2016 20:39' prior: 34412893!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !----SNAPSHOT----2016-04-25T20:42:54.285299+02:00 Pharo4.0.image priorSource: 822832!----STARTUP----2016-04-26T10:14:01.062639+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureTree methodsFor: 'initialization' stamp: 'CedricWalker 4/26/2016 10:15'!hasNext! !!StructureTree methodsFor: 'initialization' stamp: 'CedricWalker 4/26/2016 10:15'!next! !!StructureTree methodsFor: 'as yet unclassified' stamp: 'CedricWalker 4/26/2016 10:17' prior: 34416950!hasNext^((self next) = nil) not.! !----STARTUP----2016-05-15T13:47:18.115356+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #KMeansRunner	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!Object subclass: #AbstractDistance	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!AbstractDistance methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 13:52'!distanceFrom: aVector to:  anotherVector! !!AbstractDistance methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 13:53' prior: 34417625!distanceFrom: aVector to: anotherVector! !!AbstractDistance methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 13:54' prior: 34417775!distanceFrom: aVector to: anotherVector^self subclassResponsibility ! !!AbstractDistance methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 13:54' prior: 34417924!distanceFrom: aVector to: anotherVector^self subclassResponsibility! !Object subclass: #AbstractRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!----SNAPSHOT----2016-05-15T13:55:24.902356+02:00 Pharo4.0.image priorSource: 862240!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:01'!runOn: aStream! !(Smalltalk globals at: #Tokanizer) rename: #Tokenizer!(Smalltalk globals at: #AbstractTokanizingMethod) rename: #AbstractTokenizingMethod!Object subclass: #Statementizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:05' prior: 34418471!runOn: aStream	|TokenList|       (Tokenizer new) tokenize:( (Statementizer new) createStatements:aStream).! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:05' prior: 34418847!runOn: aStream	|tokenList|       (Tokenizer new) tokenize:( (Statementizer new) createStatements:aStream).! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:05' prior: 34419061!runOn: aStream	|tokenList|      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements:aStream).! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:06' prior: 34419275!runOn: aStream	|tokenList|      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).	! !(Smalltalk globals at: #AbstractRepresentator) rename: #AbstractFeatureRepresentator!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:09' prior: 34419501!runOn: aStream	|tokenList concreteFeatureRep|			concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:10' prior: 34419818!runOn: aStream	|tokenList concreteFeatureRep featureList|			concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).		featureList := concreteFeatureRep createFeatures.		! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:12' prior: 34420176!runOn: aStream	|tokenList concreteFeatureRep featureList k |		k := 5.		concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).		featureList := concreteFeatureRep createFeatures.		self kmean: featureList  with: k.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:12' prior: 34420599!runOn: aStream	|tokenList concreteFeatureRep featureList k |		k := 10.		concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).		featureList := concreteFeatureRep createFeatures.		self kmean: featureList  with: k.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:13' prior: 34421066!runOn: aStream	|tokenList concreteFeatureRep featureList k kresults|		k := 10.		concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"				      tokenList := (Tokenizer new) tokenize:( (Statementizer new) createStatements: aStream).		featureList := concreteFeatureRep createFeatures.		kresults:=self kmean: featureList  with: k.	^kresults ! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:16' prior: 34421534!runOn: aStream	|statementList concreteFeatureRep featureList k kresults|		k := 10.		concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"				      statementList := (Statementizer new) createTokenizedStatements: aStream.		featureList := concreteFeatureRep createFeatures.		kresults:=self kmean: featureList  with: k.	^kresults ! !!Statementizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:22'!createTokenizedStatements: aStream! !!Statementizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:28' prior: 34422518!createTokenizedStatements: aStream! !AbstractStatementizer subclass: #Statementizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!AbstractStatementizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:30'!createTokenizedStatements: aStream^self subclassResponsibility ! !AbstractStatementizer subclass: #NewLineStatementizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Smalltalk globals removeClassNamed: #Statementizer!!NewLineStatementizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:31'!createTokenizedStatements: aStream	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 14:32' prior: 34422039!runOn: aStream	"FileHandling"	|statementList concreteFeatureRep featureList k kresults|		k := 10.		concreteFeatureRep := AbstractFeatureRepresentator  new. "change to concrete Used FeautureRepresentator"		      statementList := (NewLineStatementizer new) createTokenizedStatements: aStream.		featureList := concreteFeatureRep createFeatures.		kresults:=self kmean: featureList  with: k.	^kresults ! !----STARTUP----2016-05-15T15:26:29.475034+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-05-15T15:26:37.843034+02:00 Pharo4.0.image priorSource: 863866!----STARTUP----2016-05-15T16:05:46.787906+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #AbstractStatmentmaker	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!AbstractStatementmaker subclass: #NewLineStatmentmaker	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #AbstractStatementmaker	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder '!Smalltalk globals removeClassNamed: #AbstractStatmentmaker!!AbstractStatementmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:24'!createTokanizedStatement: aStream! !!AbstractStatementmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:24' prior: 34424669!createTokanizedStatement: aStream^self subclassResponsibility ! !----SNAPSHOT----2016-05-15T17:24:46.591906+02:00 Pharo4.0.image priorSource: 869502!!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:25'!createTokanizedStatement: aStream	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:26' prior: 34425065!createTokanizedStatement: aStream	|string identifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	identifier := (allbutnewline, #newline asParser star) trim flatten.	collection := identifier matchesSkipIn: string.		collection do: [ :aString| string  := aString].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:27' prior: 34425214!createTokanizedStatement: aStream	|identifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	identifier := (allbutnewline, #newline asParser star) trim flatten.	collection := identifier matchesSkipIn: aStream.		collection do: [ :aString|].	! !Object subclass: #Tokanizer	instanceVariableNames: 'token'	classVariableNames: ''	category: 'StructureFinder'!!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:27'!token:aStringtoken := aString.! !!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:27'!token^token.! !Object subclass: #Statement	instanceVariableNames: 'list'	classVariableNames: ''	category: 'StructureFinder'!!Statement methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:28'!list: aListlist := aList.! !!Statement methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:29'!listlist! !!Statement methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:29' prior: 34426644!list^list! !!Statement methodsFor: 'accessing' stamp: 'CdricWalker 5/15/2016 17:30'!initialize	super initialize.	list := list new.! !!Statement methodsFor: 'accessing' stamp: 'CdricWalker 5/15/2016 17:30' prior: 34426843!initialize	super initialize.	list := LinkedList new.! !!Statement methodsFor: 'accessing' stamp: 'CdricWalker 5/15/2016 17:31'!addToken: aStringlist add: aString! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:31' prior: 34425675!createTokanizedStatement: aStream	|identifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	identifier := (allbutnewline, #newline asParser star) trim flatten.	collection := identifier matchesSkipIn: aStream.		collection do: [ :aString|].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:32' prior: 34427264!createTokanizedStatement: aStream	|statmentIdentifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aString|].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:35' prior: 34427699!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	statmentList := statmentIdentifier matchesSkipIn: aStream.		statmentList do: [ :aString|].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:37' prior: 34428158!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statmentList|	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statmentList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:38' prior: 34428708!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statmentList|	statmentList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statmentList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:38' prior: 34429343!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:38' prior: 34430010!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:40' prior: 34430680!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList 	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:44' prior: 34431350!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	tokenIdentifier := tokenIdentifier flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList 	! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:49' prior: 34432035!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := #word asParser plus/ #punctuation asParser plus.	tokenIdentifier := tokenIdentifier flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList! !!NewLineStatmentmaker methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:50' prior: 34432769!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := (#word asParser plus/ #punctuation asParser plus)flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList! !AbstractRepresentator subclass: #TypeRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!Object subclass: #Features	instanceVariableNames: 'statment representation'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:55'!runOn: aStream! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:56' prior: 34434443!runOn: aStreamNewLineStatmentmaker createTokanizedStatement: aStream.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:56' prior: 34434563!runOn: aStream	NewLineStatmentmaker createTokanizedStatement: aStream.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:57' prior: 34434740!runOn: aStream	NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:57' prior: 34434918!runOn: aStream	|statementList|	statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 17:58' prior: 34435136!runOn: aStream	|statementList representator statementmaker|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.	statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:00' prior: 34435391!runOn: aStream	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		self runKMeans.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:00' prior: 34435761!runOn: aStream	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		self KMean: featureList .			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:00' prior: 34436229!runOn: aStream	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		self KMean: featureList.			! !----SNAPSHOT----2016-05-15T18:02:05.409906+02:00 Pharo4.0.image priorSource: 870452!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:02' prior: 34436707!runOn: aStream	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList.			! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:03'!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:04' prior: 34437743!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"aStatmentList do: [ :aStatment| ]! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 18:05' prior: 34437955!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"	aStatmentList do: [ :aStatement|  		|tempList|			tempList :=aStatement list.				]! !(Smalltalk globals at: #Features) rename: #Feature!Object subclass: #Feature	instanceVariableNames: 'statement representation'	classVariableNames: ''	category: 'Structure-K-means'!----SNAPSHOT----2016-05-15T21:55:22.149906+02:00 Pharo4.0.image priorSource: 882649!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 22:35'!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"	super makeFeaturesFrom: aStatmentList! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 22:36' prior: 34438202!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"^self subclassResponsibility ! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/15/2016 22:36' prior: 34438755!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		aStatmentList do: [ :aStatement|  		|tempList|			tempList :=aStatement list.				]! !----SNAPSHOT----2016-05-15T22:37:07.026906+02:00 Pharo4.0.image priorSource: 884145!----STARTUP----2016-05-16T10:17:10.352815+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:43' prior: 34439244!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId|		typeInt := 0.		typeWord := 1.		typePunc :=2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.	aStatmentList do: [ :aStatement|  		|tempList array |			array := Array new.		(aStatement list) do: [ :aToken | aToken]				]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:43' prior: 34439735!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId|		typeInt := 0.		typeWord := 1.		typePunc :=2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|tempList array |			array := Array new.		(aStatement list) do: [ :aToken | aToken]				]! !!Feature methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:49'!statement: aStatementstatement := aStatement.! !!Feature methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:50'!statement^statement! !!Feature methodsFor: 'accessing' stamp: 'CdricWalker 5/16/2016 10:51'!initializerepresentation := LinkedList new.! !!Feature methodsFor: 'initialization' stamp: 'CdricWalker 5/16/2016 10:52'!addFeatureElement: elementrepresentation add: element.! !!Feature methodsFor: 'initialization' stamp: 'CdricWalker 5/16/2016 10:53'!representation^representation! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:55' prior: 34440279!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt := 0.		typeWord := 1.		typePunc :=2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|tempList array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 										]		]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:57' prior: 34441427!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt := 0.		typeWord := 1.		typePunc :=2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|tempList array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc ].										]		]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:59' prior: 34442087!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt := 0.		typeWord := 1.		typePunc :=2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		| array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc ].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 10:59' prior: 34442971!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 11:12' prior: 34443883!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			((wordId matches: aToken) and: (intId matches: aToken)not)  ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 11:12' prior: 34444795!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			((wordId matches: aToken) and: ((intId matches: aToken)not))  ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 11:13' prior: 34445742!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|feature|		feature := Feature new.		feature statement: aStatement.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			((wordId matches: aToken) and: ((intId matches: aToken)not))  ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 12:50' prior: 34446691!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList|		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 12:51'!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k.			! !KMeansRunner removeSelector: #runOn:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 12:56'!kMean: featureList with: k on: representator	|centroids|	centroids := representator initializeCentroids.	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 12:56' prior: 34448523!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := NewLineStatmentmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:20' prior: 34449042!kMean: featureList with: k on: representator	|centroids|	centroids := representator initializeCentroids.		(1 to: 9999) do:[		|min|		min := 9999999999.														]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:28' prior: 34449770!kMean: featureList with: k on: representator	|centroids |	centroids := representator initializeCentroids.		(1 to: 9999) do:[		|min|		min := 9999999999.														]	! !Object subclass: #Feature	instanceVariableNames: 'statement representation klabel'	classVariableNames: ''	category: 'Structure-K-means'!!Feature methodsFor: 'accessing' stamp: 'CdricWalker 5/16/2016 13:28'!klabel^klabel! !!Feature methodsFor: 'accessing' stamp: 'CdricWalker 5/16/2016 13:28'!klabel: labelklabel := label! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:30' prior: 34450056!kMean: featureList with: k on: representator	|centroids |	centroids := representator init.		(1 to: 9999) do:[		|min|		min := 9999999999.														]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:30' prior: 34450679!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		|min|		min := 9999999999.														]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:32' prior: 34450951!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		|min|		min := 9999999999.		(1 to: centroids size )														]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:33' prior: 34451232!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		|min|		min := 9999999999.		(1 to: centroids size) do:[							]								]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:38' prior: 34451539!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: centroids size) do:[ :c|				|sum|				sum:=  representator distanceFrom: c to: feature.								 ]			]								]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:39' prior: 34451852!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: centroids size) do:[ :c|				|d|				d:=  representator distanceFrom: c to: feature.				(d < min)								 ]			]								]	! !----SNAPSHOT----2016-05-16T13:52:09.875815+02:00 Pharo4.0.image priorSource: 885001!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:55' prior: 34452272!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(centroids) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.											] 					]								 ]			]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:56' prior: 34452788!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(centroids) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.											] 					]				 ]			centroids			]	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:57' prior: 34453306!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to:centroids size) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			centroids do: [ :c| ].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:58' prior: 34453832!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			centroids do: [ :c| ].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:58' prior: 34454380!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c| ].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 13:58' prior: 34454931!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c| 								].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:00' prior: 34455490!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp :=(centroids at: c) 				].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:03' prior: 34456059!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c.				].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:03' prior: 34456663!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c.					centroids at: c put: tmp.				].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:03' prior: 34457293!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:04' prior: 34457954!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/16/2016 14:04' prior: 34458624!kMean: featureList with: k on: representator	|centroids |	centroids := representator init."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !----SNAPSHOT----2016-05-16T14:05:11.311815+02:00 Pharo4.0.image priorSource: 898167!----STARTUP----2016-05-17T09:05:13.871017+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:05' prior: 34459305!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList."not fix"		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:06'!initCentroids: k with: featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:06'!distanceFrom: c to: feature! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:06'!calcMean: featureList from:c! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:07' prior: 34460925!initCentroids: k with: featureList||! !Object subclass: #AbstractRepresentator	instanceVariableNames: ''	classVariableNames: 'longestFeature'	category: 'Structure-K-means'!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:08' prior: 34447612!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:11' prior: 34461601!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:17' prior: 34461315!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [ 		(1 to: longestFeature)	 ]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:17' prior: 34463626!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [ 		(1 to: longestFeature) do:[		 ]	 ]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:20' prior: 34463850!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [ 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:20' prior: 34460203!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:27' prior: 34461054!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:31' prior: 34465171!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:34' prior: 34465406!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"(1 to: c size) do: [ 	(1to: feature representation size) ]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:34' prior: 34465676!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"|d|d:=0.(1 to: c size) do: [ 	(1to: feature representation size)do:[		].	 ].d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CdricWalker 5/17/2016 09:36' prior: 34466007!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		(1to: feature representation size)do:[			].	 ].	d.! !----QUIT----2016-05-17T09:38:36.231017+02:00 Pharo4.0.image priorSource: 905473!----STARTUP----2016-05-17T10:35:15.023173+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:35' prior: 34466361!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		(1to: feature representation size)do:[									].	 ].	d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:43' prior: 34466921!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|							 ].	^d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:50' prior: 34467299!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|			a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		(a-b) squared.	 ].	^d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:51' prior: 34467640!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|			a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		(a-b) squared.	 ].	^d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:51' prior: 34468121!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|			a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:51' prior: 34468602!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|			a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/17/2016 10:52' prior: 34469091!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|		a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !----SNAPSHOT----2016-05-17T11:04:01.043173+02:00 Pharo4.0.image priorSource: 912190!----STARTUP----2016-05-17T15:33:04.140773+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:35' prior: 34461176!calcMean: featureList from:c|count|	featureList do:[:feature|								].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:37' prior: 34470273!calcMean: featureList from:c|count|	featureList do:[:feature|		(feature klabel = c) ifTrue:[			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:37' prior: 34470462!calcMean: featureList from:c|count|	featureList do:[:feature|		count:=0.		(feature klabel = c) ifTrue:[			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:38' prior: 34470680!calcMean: featureList from:c|count|	featureList do:[:feature|		count:=0.		(feature klabel = c) ifTrue:[			count := count + 1.						].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:38' prior: 34470910!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		(feature klabel = c) ifTrue:[			count := count + 1.						].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:42' prior: 34471167!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		(feature klabel = c) ifTrue:[			count := count + 1.						].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:43' prior: 34471428!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.						].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:45' prior: 34471689!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:45' prior: 34471975!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divideThrough: count.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:47'!sumVec: vec1 plus: vec2! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:47'!divideThrough: count! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:47'!divide: sum through: count! !TypeRepresentator removeSelector: #divideThrough:!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:50' prior: 34472902!divide: sum through: count|list|sum do:[:entry| list := entry / count]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:50' prior: 34473092!divide: sum through: count|list|sum do:[:entry| list add: entry / count]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:50' prior: 34473276!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: entry / count]! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:50' prior: 34473462!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: entry / count].^list.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:54' prior: 34472666!sumVec: vec1 plus: vec2"pad shorter vector with zeros"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:54' prior: 34473890!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| |(vec1 size - vec2 size < 0) ifTrue: [  ].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:55' prior: 34474058!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| |((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	  ].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:56' prior: 34474271!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| |((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ 		]	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:56' prior: 34474506!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ 		]	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:57' prior: 34474769!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [ 						].		].	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 15:58' prior: 34475064!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [						]; ifFalse: [						].		].	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 5/17/2016 20:57' prior: 34472314!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !----SNAPSHOT----2016-05-17T20:57:48.245773+02:00 Pharo4.0.image priorSource: 915537!----QUIT----2016-05-17T20:57:49.731773+02:00 Pharo4.0.image priorSource: 921611!----STARTUP----2016-05-20T13:15:59.591808+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:29' prior: 34475411!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [			newVec add: (vec1 at: count + vec2 at: count). 			]; ifFalse: [			newVec add: (vec1 at: count).			].		].	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:36' prior: 34476428!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [			newVec add: (vec1 at: count + vec2 at: count). 			]; ifFalse: [			newVec add: (vec1 at: count).			].		].	]; ifFalse:[		(1 to: vec2 size )do: [ :count|			(count < vec1 size) ifTrue: [			newVec add: (vec1 at: count + vec2 at: count). 			]; ifFalse: [			newVec add: (vec2 at: count).			].		].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:36' prior: 34476871!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count <= vec2 size) ifTrue: [			newVec add: (vec1 at: count + vec2 at: count). 			]; ifFalse: [			newVec add: (vec1 at: count).			].		].	]; ifFalse:[		(1 to: vec2 size )do: [ :count|			(count <= vec1 size) ifTrue: [			newVec add: (vec1 at: count + vec2 at: count). 			]; ifFalse: [			newVec add: (vec2 at: count).			].		].		].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/20/2016 13:55' prior: 34346005!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				"ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ]."			ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/20/2016 13:55' prior: 34478131!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				"ifTrue: [ stream nextPutAll: startTag, (inputLoader					loadFromFile: reference), endTag] ]."			ifTrue: [ stream nextPutAll:(inputLoader					loadFromFile: reference)] ].	^ stream contents.! !(Smalltalk globals at: #NewLineStatmentmaker) rename: #NewLineStatementmaker!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:58' prior: 34449256!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := NewLineStatementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:59' prior: 34479526!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker  createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 13:59' prior: 34480043!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 14:01' prior: 34480554!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self kMean: featureList with: k on: representator.			! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 14:06' prior: 34464084!initCentroids: k with: featureList|list feature rand|list := LinkedList new.(1 to: k) do: [ 		feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 14:06' prior: 34481579!initCentroids: k with: featureList|list feature rand|list := LinkedList new.(1 to: k) do: [	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 14:24' prior: 34481941!initCentroids: k with: featureList|list feature rand|list := LinkedList new.(1 to: k) do: [ :a|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:01' prior: 34482300!initCentroids: k with: featureList|list feature rand|list := LinkedList new.(1 to: k) do: [ :a|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:04'!initialize	super initialize.	longestFeature := 0.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:06' prior: 34464442!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:07' prior: 34483175!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !----STARTUP----2016-05-20T16:22:21.049646+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:25' prior: 34475411!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec|newVec := LinkedList new.((vec1 size - vec2 size) > 0) ifTrue: [	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [				newVec add:(( vec1 at: count) + (vec2 at: count)).			]; ifFalse: [				newVec add:( vec1 at: count).			].		].	].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:28' prior: 34484749!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((vec1 size - vec2 size) < 0) ifTrue: [	|tmp|	tmp:= vec1.	v1 := vec2.	v2 := tmp.	].	"vec1 is bigger"	(1 to: vec1 size )do: [ :count|			(count < vec2 size) ifTrue: [				newVec add:(( vec1 at: count) + (vec2 at: count)).			]; ifFalse: [				newVec add:( vec1 at: count).			].		].! !----SNAPSHOT----2016-05-20T16:29:10.483646+02:00 Pharo4.0.image priorSource: 921697!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:30' prior: 34485197!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((vec1 size - vec2 size) < 0) ifTrue: [	|tmp|	tmp:= vec1.	v1 := vec2.	v2 := tmp.	].	"vec1 is bigger"	(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:30' prior: 34485805!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= vec1.	v1 := vec2.	v2 := tmp.	].	"vec1 is bigger"	(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:31' prior: 34486317!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].	"vec1 is bigger"	(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:31' prior: 34486825!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:32' prior: 34464442!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:32' prior: 34464084!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand nextInt: 2).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:33'!initialize	super initialize.	longestFeature :=0.! !----SNAPSHOT----2016-05-20T16:35:58.673646+02:00 Pharo4.0.image priorSource: 931178!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:36' prior: 34449256!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatmentmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !(Smalltalk globals at: #NewLineStatmentmaker) rename: #NewLineStatementmaker!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:36' prior: 34489146!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self KMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:36' prior: 34489734!runOn: aStream with: k	|statementList representator statementmaker featureList|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:37' prior: 34487812!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !----SNAPSHOT----2016-05-20T16:38:27.875646+02:00 Pharo4.0.image priorSource: 934524!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:38' prior: 34473672!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: (entry / count)].^list.! !----STARTUP----2016-05-20T16:40:12.652736+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:40' prior: 34475778!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:41' prior: 34491906!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].	sum:= self divide: sum through: count.^sum! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:42' prior: 34492280!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].	sum:= self divide: sum through: count.^sum! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:42' prior: 34473672!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: (entry / count)].^list.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 16:44' prior: 34487329!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !----STARTUP----2016-05-20T17:29:56.580368+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:23' prior: 34487329!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !----STARTUP----2016-05-20T20:25:46.733072+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:26' prior: 34490754!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList "with group labels!!"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:26' prior: 34494471!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList! !----SNAPSHOT----2016-05-20T20:26:28.823072+02:00 Pharo4.0.image priorSource: 936951!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:26' prior: 34487329!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec! !----STARTUP----2016-05-20T20:27:13.759227+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:28' prior: 34490244!runOn: aStream with: k	|statementList representator statementmaker featureList result|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:28' prior: 34496598!runOn: aStream with: k	|statementList representator statementmaker featureList result|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:28' prior: 34497124!runOn: aStream with: k	|statementList representator statementmaker featureList result|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.^result			! !----SNAPSHOT----2016-05-20T20:28:59.986227+02:00 Pharo4.0.image priorSource: 941373!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:29' prior: 34487329!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count < v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !----SNAPSHOT----2016-05-20T20:30:14.789227+02:00 Pharo4.0.image priorSource: 943648!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:31' prior: 34473672!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: (entry / count)].^list.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:36' prior: 34498275!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count <= v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !!Feature methodsFor: 'initialization' stamp: 'CedricWalker 5/20/2016 20:39'!representation:listrepresentation := list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:45' prior: 34495201!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList! !----SNAPSHOT----2016-05-20T20:45:30.758227+02:00 Pharo4.0.image priorSource: 944230!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:46' prior: 34499693!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from: centroids at: c. "flag!!"					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:46' prior: 34500500!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: (featureList from: centroids at: c). "flag!!"					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:46' prior: 34501236!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: (featureList from: centroids at: c).					centroids at: c put: tmp.				].			].^featureList! !!Feature methodsFor: 'initialization' stamp: 'CedricWalker 5/20/2016 20:47' prior: 34441027!initializerepresentation := LinkedList new.klabel:=0.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:51' prior: 34501974!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: (featureList from: (centroids at: c)).					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:51' prior: 34502855!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from: (centroids at: c).					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 20:52' prior: 34503586!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from: c.					centroids at: c put: tmp.				].			].^featureList! !----STARTUP----2016-05-20T20:55:41.940542+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-05-20T20:56:19.933542+02:00 Pharo4.0.image priorSource: 945878!----SNAPSHOT----2016-05-20T20:56:21.690542+02:00 Pharo4.0.image priorSource: 950600!----SNAPSHOT----2016-05-20T20:59:32.987542+02:00 Pharo4.0.image priorSource: 950686!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 21:08' prior: 34475778!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		(feature klabel = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: (feature representation).			].		].^ self divide: sum through: count.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 21:13' prior: 34505399!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.		sum := LinkedList new.		((feature klabel) = c) ifTrue:[			count := count + 1.			sum := self sumVec: sum plus: (feature representation).			].		].^ self divide: sum through: count.! !----STARTUP----2016-05-20T21:19:00.339586+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 21:24' prior: 34475778!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.				(feature klabel = c) ifTrue:[			sum := LinkedList new.			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 21:25' prior: 34506261!calcMean: featureList from:c|count sum|	featureList do:[:feature|		count:=0.				(feature klabel = c) ifTrue:[			sum := LinkedList new.			count:=0.			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/20/2016 21:25' prior: 34506639!calcMean: featureList from:c|count sum|	featureList do:[:feature|				(feature klabel = c) ifTrue:[			sum := LinkedList new.			count:=0.			count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !----SNAPSHOT----2016-05-20T21:27:04.815586+02:00 Pharo4.0.image priorSource: 950772!----SNAPSHOT----2016-05-20T21:53:59.234586+02:00 Pharo4.0.image priorSource: 952868!----QUIT----2016-05-20T21:54:01.583586+02:00 Pharo4.0.image priorSource: 952954!----STARTUP----2016-05-21T14:39:17.883196+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 14:56' prior: 34499693!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.				].			].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:01' prior: 34507766!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.					featureList do:[						].						].				].	^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:02' prior: 34508488!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := representator calcMean: featureList from:c. "flag!!"					centroids at: c put: tmp.					featureList do:[						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:04' prior: 34509246!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := LinkedList new.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:04' prior: 34510002!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := LinkedList new.					featureList do:[:feature|							(feature klabel = c) ifTrue:[															].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:05' prior: 34510747!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := LinkedList new.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								tmp := representator sumVec: tmp plus: feature representation . 							].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:05' prior: 34511500!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					tmp := LinkedList new.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								tmp := representator sumVec: tmp plus: (feature representation). 							].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:05' prior: 34512317!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								tmp := representator sumVec: tmp plus: (feature representation). 							].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:05' prior: 34513135!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								tmp := representator sumVec: tmp plus: (feature representation). 							].						].						].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:06' prior: 34513959!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].						].				].^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:06' prior: 34507030!calcMean: featureList from:c|count sum|	featureList do:[:feature|		sum := LinkedList new.			count:=0.		(feature klabel = c) ifTrue:[						count := count + 1.			sum := self sumVec: sum plus: feature representation.			].		].^ self divide: sum through: count.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:11' prior: 34514800!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							centroids at:c put:tmp.							]; ifFalse:[centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:11' prior: 34516047!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:14' prior: 34517032!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:17' prior: 34497650!runOn: aStream with: k	|statementList representator statementmaker featureList |	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self kMean: featureList with: k on: representator.			! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:24' prior: 34462564!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:30' prior: 34488545!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand nextInt: 3) - 1.		 ].	list add: feature.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:31' prior: 34520682!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|centroid rand|	centroid := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			centroid add: (rand nextInt: 3) - 1.		 ].	list add: centroid.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:32' prior: 34521056!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|centroid rand|	centroid := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			centroid add: (rand nextInt: 3) - 1.		 ].	list add: centroid.	  ].^list! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:34' prior: 34518025!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 2) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:36' prior: 34521807!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:36' prior: 34522855!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999999999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:39' prior: 34523904!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|min|			min := 99999999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:45' prior: 34524965!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|min|			min := 99999999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]"; ifFalse:[							centroids remove: (centroids at: c) ]."					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:49' prior: 34526060!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|d min|			min := 99999999999999.							(1 to: (centroids size)) do:[ :c|							d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]"; ifFalse:[							centroids remove: (centroids at: c) ]."					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:50' prior: 34527157!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|d min|			min := 99999999999999.							(1 to: (centroids size)) do:[ :c|							d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]; ifFalse:[							centroids remove: (centroids at: c) ].					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:50' prior: 34528257!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|d min|			min := 99999999999999.							(1 to: (centroids size)) do:[ :c|							d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]"; ifFalse:[							centroids remove: (centroids at: c) ]".					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:52' prior: 34529355!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|				featureList do: [ :feature|			|min|			min := 99999999999999.						(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].						"wrong!! Variable or expression expected ->"			(1 to: centroids size) do: [ :c|					|tmp count|					tmp := LinkedList new.					count := 0.					featureList do:[:feature|							(feature klabel = c) ifTrue:[								count := count +1.								tmp := representator sumVec: tmp plus: (feature representation). 							].						].							(count > 0) ifTrue: [							tmp := representator divide: tmp through: count.							centroids at:c put:tmp.							]"; ifFalse:[							centroids remove: (centroids at: c) ]".					].				].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:56' prior: 34519074!runOn: aStream with: k	|statementList representator statementmaker featureList fileHandler|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.	fileHandler := FileHandler new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:56' prior: 34531556!runOn: aStream with: k	|statementList representator statementmaker featureList fileHandler|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.	fileHandler := FileHandler new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		^self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:56' prior: 34532109!runOn: aStream with: k	|statementList representator statementmaker featureList fileHandler|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.	fileHandler := FileHandler new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		self kMean: featureList with: k on: representator.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 15:56' prior: 34532664!runOn: aStream with: k	|statementList representator statementmaker featureList fileHandler|	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.	fileHandler := FileHandler new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		self kMean: featureList with: k on: representator.					! !----STARTUP----2016-05-21T16:36:48.930346+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:38' prior: 34499693!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					featureList do: [ 										].							].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:40' prior: 34533884!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp|					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[														].					].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:40' prior: 34534550!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[														].					].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:40' prior: 34535297!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[							count := count + 1.							].					].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:41' prior: 34536066!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:42' prior: 34536854!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				centroids at: c put: (representator divide: tmp through: count). 			].		].^featureList! !----SNAPSHOT----2016-05-21T16:42:48.347346+02:00 Pharo4.0.image priorSource: 953040!----SNAPSHOT----2016-05-21T16:42:51.985346+02:00 Pharo4.0.image priorSource: 984106!----STARTUP----2016-05-21T16:43:17.251504+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:43' prior: 34537713!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					featureList do: [ :feature|						tmp := LinkedList new.						(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (representator divide: tmp through: count). ].			].		].^featureList! !----SNAPSHOT----2016-05-21T16:43:58.665504+02:00 Pharo4.0.image priorSource: 984192!TypeRepresentator removeSelector: #calcMean:from:!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:47' prior: 34488545!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next* 2).		 ].	list add: feature.	  ].^list! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:47' prior: 34540025!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * 2).		 ].	list add: feature.	  ].^list! !----SNAPSHOT----2016-05-21T16:47:06.973504+02:00 Pharo4.0.image priorSource: 985346!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:49' prior: 34540392!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand nextInt:3 -1).		 ].	list add: feature.	  ].^list! !----SNAPSHOT----2016-05-21T16:50:20.851504+02:00 Pharo4.0.image priorSource: 986219!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:50' prior: 34462564!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].		longestFeature := maxFeature.^featureList! !----STARTUP----2016-05-21T16:51:32.9757+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:51' prior: 34462564!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature .^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:52' prior: 34542503!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 0.		typeWord := 1.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.^featureList! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:52' prior: 34540846!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand nextInt:3 - 1).		 ].	list add: feature.	  ].^list! !----SNAPSHOT----2016-05-21T16:52:10.2907+02:00 Pharo4.0.image priorSource: 986677!----SNAPSHOT----2016-05-21T16:52:25.4317+02:00 Pharo4.0.image priorSource: 990520!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:52' prior: 34538922!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (representator divide: tmp through: count). ].			].		].^featureList! !----SNAPSHOT----2016-05-21T16:52:59.2137+02:00 Pharo4.0.image priorSource: 990604!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:54' prior: 34544688!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next *2).		 ].	list add: feature.	  ].^list! !----SNAPSHOT----2016-05-21T16:55:11.1547+02:00 Pharo4.0.image priorSource: 991648!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:56' prior: 34545224!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (representator divide: tmp through: count). ].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 16:56' prior: 34546719!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (representator divide: tmp through: count). ].			].		].^featureList! !----SNAPSHOT----2016-05-21T16:56:32.8137+02:00 Pharo4.0.image priorSource: 992099!----STARTUP----2016-05-21T17:00:16.317973+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:00' prior: 34547680!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  representator distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := representator sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (representator divide: tmp through: count). ].			].		].^featureList! !----SNAPSHOT----2016-05-21T17:12:59.671973+02:00 Pharo4.0.image priorSource: 994107!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:13' prior: 34543596!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.^featureList! !----SNAPSHOT----2016-05-21T17:13:31.598973+02:00 Pharo4.0.image priorSource: 995261!Object subclass: #Vector	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:15'!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	|tmp|	tmp:= v1.	v1 := v2.	v2 := tmp.	].		(1 to: v1 size )do: [ :count|			(count <= v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:15'!divide: sum through: count|list|list := LinkedList new.sum do:[:entry| list add: (entry / count)].^list.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:16'!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|		a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:16' prior: 34551829!distanceFrom: c to: feature"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|		a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:17' prior: 34552317!distanceFrom: c to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|		a := c at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:17' prior: 34552790!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:18' prior: 34553254!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:19' prior: 34553727!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d|	(vec1 - vec2 > 0) ifTrue: [  ]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:19' prior: 34554200!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d|	(vec1 - vec2 > 0) ifTrue: [		|tmp|		]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:19' prior: 34554709!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d|	(vec1 - vec2 < 0) ifTrue: [		|tmp|				]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:21' prior: 34555227!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	(vec1 - vec2 < 0) ifTrue: [		|tmp|		tmp := vec1.		v1 := vec2.		v1:= vec1.		]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:21' prior: 34555748!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 - vec2 < 0) ifTrue: [		|tmp|		tmp := vec1.		v2 := vec2.		v1:= vec1.		]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:22' prior: 34556314!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 - vec2 < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: vec1 size) do: [ :cCount|		|a b|		a := vec1 at:cCount.		(cCount>(vec2 representation size)) ifFalse: [  b:= vec2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:23' prior: 34556906!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 - vec2 < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 representation size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:23' prior: 34551154!sumVec: vec1 plus: vec2"pad shorter vector with zeros"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	v1 := vec2.	v2 := vec1.	].		(1 to: v1 size )do: [ :count|			(count <= v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:25' prior: 34548835!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !!Vector class methodsFor: 'Math' stamp: 'CedricWalker 5/21/2016 17:25' prior: 34557475!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 - vec2 < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:27' prior: 34469585!distanceFrom: c to: feature"C's lenght is longestFeature, feature does nt have to meet this criteria, pad rest with zeros, c is a list, feature has a list"		|d|	d:=0.	(1 to: c size) do: [ :cCount|		|a b|		a := c at:cCount.		(cCount>(feature representation size)) ifFalse: [  b:= feature representation at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !TypeRepresentator removeSelector: #distanceFrom:to:!TypeRepresentator removeSelector: #divide:through:!TypeRepresentator removeSelector: #sumVec:plus:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:28' prior: 34558513!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:28' prior: 34560634!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !!Vector class methodsFor: 'Math' stamp: 'CedricWalker 5/21/2016 17:29' prior: 34559439!distanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !----SNAPSHOT----2016-05-21T17:30:17.456973+02:00 Pharo4.0.image priorSource: 996439!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:35' prior: 34497650!runOn: path with: k	|statementList representator statementmaker featureList result aStream fileHandler|	fileHandler := FileHandler new.	aStream := fileHandler projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:result to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:36' prior: 34563157!runOn: path with: k	|statementList representator statementmaker featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"			featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:result to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:36' prior: 34563816!runOn: path with: k	|statementList representator statementmaker featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:result to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:36'!save:result to: path! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:38' prior: 34565038!save:result to: path"result is a feature List, path is a String"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:38' prior: 34565165!save: result to: path"result is a feature List, path is a String"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:39'!save: result on: k to: path"result is a feature List, path is a String"|aStream |result do:[].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:39' prior: 34564436!runOn: path with: k	|statementList representator statementmaker featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:result on:k to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:40' prior: 34565495!save: result on: k to: path"result is a feature List, path is a String"|aStream |(1 to:k) do: [:c| 	 aStream := WriteStream new.		].! !----SNAPSHOT----2016-05-21T17:42:15.082973+02:00 Pharo4.0.image priorSource: 1008535!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:43' prior: 34566323!save: result on: k to: path"result is a feature List, path is a String"|aStream |(1 to:k) do: [:c| 	aStream := WriteStream new.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut: feature statement, Character cr asString.						].		].	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:44' prior: 34566656!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := WriteStream new.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut: feature statement, Character cr asString.			].		].			].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:45' prior: 34567028!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := WriteStream new.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut: feature statement, Character cr asString.			].		].		fileHandler saveFile: aStream to: path, c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:46' prior: 34567443!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := WriteStream new.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut: feature statement, Character cr asString.			].		].		fileHandler saveFile: aStream to: path, '\result\'|,c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:48' prior: 34567918!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut: feature statement, Character cr asString.			].		].		fileHandler saveFile: aStream to: path, '\result\'|,c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:49' prior: 34568405!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut:( (feature statement), Character cr asString).			].		].		fileHandler saveFile: aStream to: path, '\result\'|,c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:50' prior: 34568899!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut:( (feature statement), Character cr asString).			].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:51' prior: 34569397!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPut:( (feature statement list), Character cr asString).			].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:53' prior: 34569894!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list ).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/21/2016 17:55' prior: 34348781!saveFile: stream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll:  stream].! !----SNAPSHOT----2016-05-21T17:55:12.693973+02:00 Pharo4.0.image priorSource: 1012033!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:59' prior: 34570396!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list contains).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 17:59' prior: 34571255!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list contents).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:00' prior: 34571790!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:02' prior: 34572325!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			feature list do:[:string | aStream nextPut:string , ''].			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:03' prior: 34572851!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c| 	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:04' prior: 34573389!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:04' prior: 34573915!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. 	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:04' prior: 34574462!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		(count > 0) ifTrue:[		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. ].	].! !----SNAPSHOT----2016-05-21T18:04:57.757973+02:00 Pharo4.0.image priorSource: 1016632!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:08' prior: 34575032!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		(count > 0) ifTrue:[		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'. ].	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:10' prior: 34575714!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:(feature statement list).			aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:12' prior: 34576363!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:(feature statement list asString).			aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:13' prior: 34576986!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			aStream nextPutAll:((feature statement list) asString).			aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:17' prior: 34577618!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ |string|				 ].			aStream nextPutAll:((feature statement list) asString).			aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:17' prior: 34578252!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ |string|				string := ((feature statement list) asString).				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		(path , '\result') asFileReference createDirectory.		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:19' prior: 34578935!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ |string|				string := ((feature statement list) asString).				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[		(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:20' prior: 34579643!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ |string|				string := ((feature statement list) asString).				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:20' prior: 34580414!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := (token asString).				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:21' prior: 34581186!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ''.				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:22' prior: 34581947!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ''.				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !----SNAPSHOT----2016-05-21T18:24:34.805973+02:00 Pharo4.0.image priorSource: 1021091!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:26' prior: 34582701!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ' '.				aStream nextPut: string.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:31' prior: 34583542!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ' '.				aStream nextPut: ' a'.				 ].						aStream nextPut: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !----SNAPSHOT----2016-05-21T18:31:58.991973+02:00 Pharo4.0.image priorSource: 1028919!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:35' prior: 34584297!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ' '.				aStream nextPutAll: 'string'.				 ].						aStream nextPutAll: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:36' prior: 34585137!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ' '.				aStream nextPutAll: 'string'.				 ].						aStream nextPutAll: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/21/2016 18:38' prior: 34570910!saveFile: stream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: stream].! !----SNAPSHOT----2016-05-21T18:39:15.174973+02:00 Pharo4.0.image priorSource: 1030514!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/21/2016 18:41' prior: 34585900!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token| |string|				string := token, ' '.				aStream nextPutAll: string.				 ].						aStream nextPutAll: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !----SNAPSHOT----2016-05-21T18:43:05.039973+02:00 Pharo4.0.image priorSource: 1032370!----QUIT----2016-05-21T18:43:07.048973+02:00 Pharo4.0.image priorSource: 1033217!----STARTUP----2016-05-24T10:31:33.557669+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/24/2016 10:43' prior: 34586649!saveFile: stream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: 'Hello World'].! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/24/2016 10:43' prior: 34588030!saveFile: aStream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll:aStream].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/24/2016 10:45' prior: 34588293!saveFile: aStream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: aStream asString ].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 5/24/2016 10:45' prior: 34588538!saveFile: aStream to: path	"comment stating purpose of message"	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: aStream contents ].! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/24/2016 10:48' prior: 34588794!saveFile: aStream to: path	"comment stating purpose of message"	|string|	string := aStream contents.	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: string ].! !----SNAPSHOT----2016-05-24T10:49:47.783669+02:00 Pharo4.0.image priorSource: 1033304!----SNAPSHOT----2016-05-24T12:03:41.304669+02:00 Pharo4.0.image priorSource: 1034824!----STARTUP----2016-05-26T15:30:38.803724+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/26/2016 15:31' prior: 34561574!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 5/26/2016 17:10' prior: 34589642!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 99999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !----STARTUP----2016-06-06T14:00:11.196151+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:07'!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList on: interval on: representator.	self save:result on:interval to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:28' prior: 34591649!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		interval do: [ 	result := self kMean: featureList on: interval on: representator.	self save:result on:interval to: path.	].^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:29' prior: 34592223!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	interval do: [ 	result := self kMean: featureList on: interval on: representator.	orderedCollection add: (self save:result on:interval to: path).	].			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:30' prior: 34592836!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	interval do: [ :k|	result := self kMean: featureList with: k on: representator.	orderedCollection add: (self save:result on:interval to: path).	].			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:35' prior: 34593513!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	orderedCollection add: (self save:result on:interval to: path).	].			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:35' prior: 34594188!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	orderedCollection add: (self save:result on:k to: path).	].			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:37' prior: 34594892!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	orderedCollection add: (result).	].			! !AbstractAnalzingMethod subclass: #KMeansCostAnalyzer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:39'!analyzer! !!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:39'!analyze! !KMeansCostAnalyzer removeSelector: #analyzer!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:40' prior: 34595589!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream orderedCollection|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		orderedCollection := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	orderedCollection add: (result).	].	KMeansCostAnalyzer analyze: orderedCollection.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:41' prior: 34596651!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	KMeansCostAnalyzer analyze: results.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:42' prior: 34597372!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results bestResult|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	bestResult := (KMeansCostAnalyzer new) analyze: results.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:42' prior: 34598053!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results bestResult|	aStream := (FileHandler new) projectAsStream: path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	^bestResult := (KMeansCostAnalyzer new) analyze: results.			! !Object subclass: #KMeansRunner	instanceVariableNames: 'projectSpace'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:43' prior: 34598765!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results bestResult|	aStream := (FileHandler new) projectAsStream: path.	projectSpace := path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	^bestResult := (KMeansCostAnalyzer new) analyze: results.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 14:43' prior: 34565700!runOn: path with: k	|statementList representator statementmaker featureList result aStream|	projectSpace  := path.	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:result on:k to: path.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 15:48' prior: 34599605!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results bestResult|	aStream := (FileHandler new) projectAsStream: path.	projectSpace := path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	bestResult := (KMeansCostAnalyzer new) analyze: results.	self save: (bestResult at: 1 )to: path. 	^bestResult at:2.			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 15:55' prior: 34600987!runOn: path on: interval with: statementmaker representedAs:representator	|statementList featureList result aStream results bestResult|	aStream := (FileHandler new) projectAsStream: path.	projectSpace := path.			statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		results := OrderedCollection  new.	((interval at: 1) to:(interval at:2)) do: [ :k|	result := self kMean: featureList with: k on: representator.	results add: (result).	].	bestResult := (KMeansCostAnalyzer new) analyzeForEachResult: results with: interval.	self save: (bestResult at: 1 )to: path. 	^bestResult at:2.			! !!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 15:55'!analyzeForEachResult: results with: interval|bestResult|bestResult := OrderedCollection.! !!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 15:56' prior: 34602595!analyzeForEachResult: results with: interval|bestResult|bestResult := OrderedCollection new.! !!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 15:58' prior: 34602797!analyzeForEachResult: results with: interval|bestResult currentBest|bestResult := OrderedCollection new.currentBest := 999999.results do: [:featureList| 	|c| 	c := self analyze: featureList. 	 (c < currentBest) ifTrue: [		bestResult := featureList.		c := currentBest.		]	.]! !!KMeansCostAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 16:01' prior: 34603004!analyzeForEachResult: results with: interval|bestResult currentBestc currentBestResult|bestResult := OrderedCollection new.currentBestc := 999999.results do: [:featureList| 	|c| 	c := self analyze: featureList. 	 (c < currentBestc) ifTrue: [		bestResult := featureList.		currentBestc := c.		currentBestResult := featureList.		].	].bestResult add: currentBestResult.bestResult add:currentBestc.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 16:15' prior: 34561574!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/6/2016 16:18' prior: 34603913!kMean: featureList with: k on: representator	|centroids |	centroids := representator initCentroids: k with: featureList.		(1 to: 9) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].^featureList! !----STARTUP----2016-06-06T16:41:19.434485+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!(Smalltalk globals at: #AbstractAnalzingMethod) rename: #AbstractAnalyzingMethod!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:21'!analyze: result! !----SNAPSHOT----2016-06-06T17:21:20.637485+02:00 Pharo4.0.image priorSource: 1034911!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:27' prior: 34606000!analyze: result|representation|"Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."((result  at: 1) ) do: [ :rep| 		].! !----SNAPSHOT----2016-06-06T17:28:14.381485+02:00 Pharo4.0.image priorSource: 1051587!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:29' prior: 34606211!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum + Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)		].! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:30' prior: 34606586!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum + Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)		].^sum.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:32' prior: 34606976!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum + Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)	].^sum.! !----SNAPSHOT----2016-06-06T17:32:24.024485+02:00 Pharo4.0.image priorSource: 1051962!----SNAPSHOT----2016-06-06T17:44:53.306485+02:00 Pharo4.0.image priorSource: 1053229!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:50' prior: 34561574!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^featureList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:51' prior: 34565700!runOn: path with: k	|statementList representator statementmaker featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.^result			! !----SNAPSHOT----2016-06-06T17:51:30.107485+02:00 Pharo4.0.image priorSource: 1053316!----SNAPSHOT----2016-06-06T17:51:38.393485+02:00 Pharo4.0.image priorSource: 1055077!----SNAPSHOT----2016-06-06T17:53:04.462485+02:00 Pharo4.0.image priorSource: 1055164!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:54' prior: 34607938!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----SNAPSHOT----2016-06-06T17:55:40.066485+02:00 Pharo4.0.image priorSource: 1055251!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:57' prior: 34607372!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := Vector sumVec: sum plus: (Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 17:58' prior: 34611002!analyze: result| sum |sum := LinkedList new."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := Vector sumVec: sum plus: (Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum.! !----SNAPSHOT----2016-06-06T20:21:46.386485+02:00 Pharo4.0.image priorSource: 1056378!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 20:30' prior: 34611417!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum.! !!UndefinedObject methodsFor: 'nil' stamp: 'CedricWalker 6/6/2016 20:57'!DoIt	| path interval result c bestC bestResult kRunner |	kRunner := KMeansRunner new.	path := 'C:\Users\Cédric\Dropbox\pharo\testFiles'.	interval := #(1 3).	bestC := 9999.	((interval at: 1) to: (interval at: 2))		do: [ :k | 			result := kRunner runOn: path with: k.			c := SqrSumAnalyzer new analyze: result.			c < bestC				ifTrue: [ 					bestC := c.					bestResult := result ] ].	^ kRunner save: (bestResult at:1) on: (bestResult at: 2)to: path , '\best'! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 20:57' prior: 34612296!DoIt	| path interval result c bestC bestResult kRunner |	kRunner := KMeansRunner new.	path := 'C:\Users\Cédric\Dropbox\pharo\testFiles'.	interval := #(1 3).	bestC := 9999.	((interval at: 1) to: (interval at: 2))		do: [ :k | 			result := kRunner runOn: path with: k.			c := SqrSumAnalyzer new analyze: result.			c < bestC				ifTrue: [ 					bestC := c.					bestResult := result ] ].	^ kRunner save: (bestResult at:1) on: (bestResult at: 2)to: path , '\best'! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 20:57' prior: 34612875!DoIt	| path interval result c bestC bestResult kRunner |	kRunner := KMeansRunner new.	path := 'C:\Users\Cédric\Dropbox\pharo\testFiles'.	interval := #(1 3).	bestC := 9999.	((interval at: 1) to: (interval at: 2))		do: [ :k | 			result := kRunner runOn: path with: k.			c := SqrSumAnalyzer new analyze: result.			c < bestC				ifTrue: [ 					bestC := c.					bestResult := result ] ].	^ kRunner save: (bestResult at:1) on: (bestResult at: 2) to: path , '\best'! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 21:07' prior: 34609873!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 9) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 21:11' prior: 34613454!DoIt	| path interval result c bestC bestResult kRunner |	kRunner := KMeansRunner new.	path := 'C:\Users\Cédric\Dropbox\pharo\testFiles'.	interval := #(1 2).	bestC := 9999.	((interval at: 1) to: (interval at: 2))		do: [ :k | 			result := kRunner runOn: path with: k.			c := SqrSumAnalyzer new analyze: result.			c < bestC				ifTrue: [ 					bestC := c.					bestResult := result ] ].	^ kRunner save: (bestResult at: 1) on: (bestResult at: 2) size to: path , '\best'! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 21:42' prior: 34586993!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path , '\result') asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/6/2016 22:01' prior: 34614031!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 99999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----QUIT----2016-06-06T23:46:30.011485+02:00 Pharo4.0.image priorSource: 1057308!----STARTUP----2016-06-12T14:41:29.343046+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:22'!bestKMean: path from: kOne to: kTwo! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:24' prior: 34617637!bestKMean: path from: kOne to: kTwo|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result.		c := c / k. " norm it trough nummber of c so balance the result over the sum. "		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:24' prior: 34617779!bestKMean: path from: kOne to: kTwo|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result with k.		c := c / k. " norm it trough nummber of c so balance the result over the sum. "		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:24' prior: 34618262!bestKMean: path from: kOne to: kTwo|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result with k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:25'!analyze: result with: k| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:25' prior: 34619146!analyze: result with: k| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum/k.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:25' prior: 34618752!bestKMean: path from: kOne to: kTwo|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 15:31'!initializetimestamp := DateAndTime current asString.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 16:09' prior: 34615656!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path , '\result\', timestamp) asFileReference isDirectory) ifFalse:[			(path , '\result') asFileReference createDirectory.].		fileHandler saveFile: aStream to: path, '\result\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'Cedricwalker 6/12/2016 16:10' prior: 34620631!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream newpath|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path ,  '\result\', timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		fileHandler saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !----SNAPSHOT----2016-06-12T16:47:40.657046+02:00 Pharo4.0.image priorSource: 1062926!----QUIT----2016-06-13T12:52:02.778046+02:00 Pharo4.0.image priorSource: 1067663!----STARTUP----2016-06-13T13:00:48.819353+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 13:58' prior: 34346005!projectAsStream: projectPath	| stream inputLoader startTag endTag|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 13:59'!runOn: path with: k to: savepath	|statementList representator statementmaker featureList result aStream|	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: savepath.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:01'!bestKMean: path from: kOne to: kTwo saveOn: savePath|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k to:savePath. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:01' prior: 34616418!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 9) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:14' prior: 34621406!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream newpath|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		fileHandler saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:37' prior: 34625115!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream newpath|fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		fileHandler saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:48'!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream savepath |	aStream := (FileHandler new) projectAsStream: path.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: savepath.^result			! !KMeansRunner removeSelector: #runOn:with:to:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:50' prior: 34626657!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream savepath |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: savepath.^result			! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 14:52'!projectAsStream: path type:type	| stream inputLoader startTag endTag projectPath|	startTag := '-->file Start', Character cr asString.	endTag := Character cr asString, '--> file end', Character cr asString.	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 14:56'!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult|bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self runOn: path with:k type: type. "need centroids here!!"		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !KMeansRunner removeSelector: #bestKMean:from:to:saveOn:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:01' prior: 34628591!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:02' prior: 34629082!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !KMeansRunner removeSelector: #runOn:with:!KMeansRunner removeSelector: #bestKMean:from:to:!KMeansRunner removeSelector: #save:to:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:09' prior: 34627359!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: result on: k to: path.^result			! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:10'!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream newpath timestamp |fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		fileHandler saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:10' prior: 34631513!save: result on: k to: path"result is a feature List, path is a String"|fileHandler aStream newpath timestamp |fileHandler := FileHandler new.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		fileHandler saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:11' prior: 34632290!save: result on: k to: path"result is a feature List, path is a String"| aStream newpath timestamp |(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:11'!save: result on: k to: path with: timestamp"result is a feature List, path is a String"| aStream newpath  |(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !KMeansRunner removeSelector: #save:on:to:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:12' prior: 34630841!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: result on: k to: path with: timestamp.^result			! !FileHandler removeSelector: #save:on:to:with:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:15' prior: 34634571!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: result on: k to: path with: timestamp with: type .^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:15' prior: 34635336!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: result on: k to: path, '\result\' , type ,'\' , timestamp.^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:16' prior: 34636066!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: result on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:16' prior: 34636804!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	self save:(result at: 1)on:k to: path.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:17' prior: 34637544!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:17' prior: 34633067!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath  timestamp |(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, timestamp.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:18' prior: 34638987!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, '\' , k asString.		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 15:18' prior: 34639753!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |newpath := path, '\' , k asString.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].				((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !----QUIT----2016-06-13T15:24:08.341353+02:00 Pharo4.0.image priorSource: 1067750!----STARTUP----2016-06-13T15:24:19.604687+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 15:45' prior: 34620471!initialize|day hour minute second|timestamp := DateAndTime current asString.day := ''.hour:= ''.minute := ''.second := ''.(1 to: 10 )do:[ :a|	day:= day , (timestamp at: a) asString].(11 to: 13 )do:[ :a|	hour:= hour , (timestamp at: a) asString].(15 to: 16 )do:[ :a|	minute:= minute , (timestamp at: a) asString].(18 to: 19 )do:[ :a|	second:= second , (timestamp at: a) asString].timestamp :=  day, hour, minute, second.! !----QUIT----2016-06-13T16:18:20.151687+02:00 Pharo4.0.image priorSource: 1086754!----STARTUP----2016-06-13T16:29:02.634842+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-06-13T16:29:07.774842+02:00 Pharo4.0.image priorSource: 1087487!----STARTUP----2016-06-13T16:33:50.007455+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-06-13T16:37:55.252455+02:00 Pharo4.0.image priorSource: 1087487!----STARTUP----2016-06-13T17:10:25.562473+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/13/2016 17:13' prior: 34640515!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		newpath := path, '\' , k asString.		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:20' prior: 34629894!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler|	fileHandler := FileHandler new.	aStream := fileHandler  projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at:1) on: k to: (path , '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result.			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:30' prior: 34643454!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler|	fileHandler := FileHandler new.	aStream := fileHandler  projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at:1) on: k to: (path , '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result.			]	 ].fileHandler markBest: (bestResult at: 2 size)on: (path , '\result\' , type ,'\' , timestamp).! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:31'!markBest: k on: path! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:36' prior: 34645408!markBest: k on: path"path is path\result\type\timestamp\"|oldpath newpath|oldpath := (path, '\' , k asString) asFileReference.newpath := (path, '\' , k asString, '-best') asFileReference.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:36' prior: 34645534!markBest: k on: path"path is path\result\type\timestamp\"|oldpath newpath|oldpath := (path, '\' , k asString) asFileReference.newpath := (path, '\' , 'best_', k asString) asFileReference.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:37' prior: 34645833!markBest: k on: path"path is path\result\type\timestamp\"|oldpath newpath|oldpath := (path, '\' , k asString) asFileReference.newpath := (path, '\' , 'best_', k asString) asFileReference.oldpath copyAllTo: newpath.newpath delete.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:40' prior: 34644393!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler|	fileHandler := FileHandler new.	aStream := fileHandler  projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at:1) on: k to: (path , '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result.			]	 ].fileHandler markBest: (bestResult at: 2) size on: (path , '\result\' , type ,'\' , timestamp).! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:41' prior: 34646132!markBest: k on: path"path is path\result\type\timestamp\"|oldpath newpath|oldpath := (path, '\' , k asString) asFileReference.newpath := (path, '\' , 'best_', k asString) asFileReference.oldpath copyAllTo: newpath.oldpath delete.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:42' prior: 34647508!markBest: k on: path"path is path\result\type\timestamp\"|oldpath newpath|oldpath := (path, '\' , k asString) asFileReference.newpath := (path, '\' , 'best_', k asString) asFileReference.oldpath copyAllTo: newpath.oldpath deleteAll.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 17:44' prior: 34624075!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/13/2016 20:49' prior: 34648198!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 999) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----STARTUP----2016-06-14T10:23:27.360193+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-06-14T10:25:51.614193+02:00 Pharo4.0.image priorSource: 1087870!!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:34' prior: 34640515!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |newpath := path, '\' , k asString.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',c asString, '.txt'.	].! !----SNAPSHOT----2016-06-14T10:35:18.005193+02:00 Pharo4.0.image priorSource: 1095853!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:36' prior: 34624075!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 99) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !TestCase subclass: #VectorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinderTests'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:56' prior: 34629894!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler |	fileHandler := FileHandler new.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.				c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:57' prior: 34652587!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler |	fileHandler := FileHandler new.	aStream := fileHandler projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:58'!markBestFrom:path with:k! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:59' prior: 34653446!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler |	fileHandler := FileHandler new.	aStream := fileHandler projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].	fileHandler markBestFrom:(path, '\result\' , type ,'\' , timestamp) with: (result at:2) size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 10:59' prior: 34654498!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream fileHandler |	fileHandler := FileHandler new.	aStream := fileHandler projectAsStream: path type: type.	representator := TypeRepresentator new.	statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fileHandler save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].	fileHandler markBestFrom:(path, '\result\' , type ,'\' , timestamp) with: (bestResult at:2) size.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 11:01' prior: 34654367!markBestFrom:path with:k|oldpath newpath|oldpath := path , k asString.newpath := path, 'best_', k asString.newpath asFileReference createDirectory.oldpath copyAllTo: newpath .oldpath deleteAll.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 11:05' prior: 34656567!markBestFrom:path with:k|oldpath newpath|oldpath := (path , k asString) asFileReference.newpath := (path, 'best_', k asString)asFileReference.newpath asFileReference createDirectory.oldpath copyAllTo: newpath .oldpath deleteAll.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 11:08' prior: 34656874!markBestFrom:path with:k|oldpath newpath|oldpath := (path , k asString).newpath := (path, 'best_', k asString).newpath asFileReference createDirectory.newpath := newpath asFileReference.oldpath := oldpath asFileReference.oldpath copyAllTo: newpath .oldpath deleteAll.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 11:10' prior: 34657216!markBestFrom:path with:k"path := path\result\type\timestamp"|oldpath newpath|oldpath := (path , k asString).newpath := (path, 'best_', k asString).newpath asFileReference createDirectory.newpath := newpath asFileReference.oldpath := oldpath asFileReference.oldpath copyAllTo: newpath .oldpath deleteAll.! !!FileHandler methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/14/2016 11:12' prior: 34657599!markBestFrom:path with:k"path := path\result\type\timestamp"|oldpath newpath|oldpath := (path ,'\', k asString).newpath := (path, '\best_', k asString).newpath asFileReference createDirectory.newpath := newpath asFileReference.oldpath := oldpath asFileReference.oldpath copyAllTo: newpath .oldpath deleteAll.! !----STARTUP----2016-06-20T14:09:43.097826+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!(Smalltalk globals at: #AbstractRepresentator) rename: #AbstractTypeRepresentator!Object subclass: #AbstractDistanceRepresentator	instanceVariableNames: ''	classVariableNames: 'longestFeature'	category: 'Structure-K-means'!Object subclass: #AbstractWeightRepresentator	instanceVariableNames: ''	classVariableNames: 'longestFeature'	category: 'Structure-K-means'!Smalltalk globals removeClassNamed: #AbstractDistanceRepresentator!Object subclass: #AbstractRepresentator	instanceVariableNames: ''	classVariableNames: 'longestFeature'	category: 'Structure-K-means'!Smalltalk globals removeClassNamed: #AbstractRepresentator!(Smalltalk globals at: #AbstractTypeRepresentator) rename: #AbstractRepresentator!AbstractRepresentator subclass: #RepresentatorRunner	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!AbstractRepresentator commentStamp: 'CedricWalker 6/20/2016 15:17' prior: 0!RepresentatorsThere are three different Type of Representatiors and a Runner1. TypeRepresentator, sets up the inital Vector, is responsible for defining longesFeature!!2. DistRepresentator, calculates Distances between elements 3. weightRepresentator: gives a defined Weight to the VectorThe Runner consist of one instance of TypeRepresentatior and optionaly one of Dist and one of Weight.The Runner then concatenates these Runners.!!AbstractRepresentator commentStamp: 'CedricWalker 6/20/2016 15:25' prior: 34659392!RepresentatorsThere are three different Type of Representatiors and a Runner1. TypeRepresentator, sets up the inital Vector, is responsible for defining longesFeature!! Takes a StatementList2. DistRepresentator, calculates Distances between element. Takes a FeatureList.3. weightRepresentator: gives a defined Weight to the Vector. Takes a FeatureList.The Runner consist of one instance of TypeRepresentatior and optionaly one of Dist and one of Weight.The Runner then concatenates these Runners.!AbstractRepresentator subclass: #RepresentatorRunner	instanceVariableNames: 'typeRep distRep weightRep'	classVariableNames: ''	category: 'Structure-K-means'!!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:26'!makeFeaturesFrom: aFeatureList "List containing Statement Elements, defined in StrucutureFinder"	! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:29'!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next *2).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator commentStamp: 'CedricWalker 6/20/2016 15:30' prior: 34659922!RepresentatorsThere are three different Type of Representatiors and a Runner1. TypeRepresentator, sets up the inital Vector, is responsible for defining longesFeature!! Takes a StatementList2. DistRepresentator, calculates Distances between element. Takes a FeatureList.3. weightRepresentator: gives a defined Weight to the Vector. Needs to Tell Runner maxValue  Takes a FeatureList. The Runner consist of one instance of TypeRepresentatior and optionaly one of Dist and one of Weight.The Runner then concatenates these Runners.!Object subclass: #AbstractRepresentator	instanceVariableNames: ''	classVariableNames: 'longestFeature maxValue'	category: 'Structure-K-means'!!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:31' prior: 34660885!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * maxValue).		 ].	list add: feature.	  ].^list! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:31'!typeRep^typeRep! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:32'!typeRep:aReptypeRep := aRep.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:32'!distRep:aRepdistRep := aRep.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:32'!weightRep:aRepweightRep := aRep.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:33' prior: 34660687!makeFeaturesFrom: aFeatureList "List containing Statement Elements, defined in StrucutureFinder"	aFeatureList do:[:feature|			].! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 15:37' prior: 34662942!makeFeaturesFrom: aStatementList "List containing Statement Elements, defined in StrucutureFinder"	|list|list := LinkedList new.	list := typeRep makeFeaturesFrom: aStatementList.	((distRep = nil)) ifFalse: [  list := distRep  makeFeaturesFrom: list ].	((weightRep = nil)) ifFalse: [  list := distRep  makeFeaturesFrom: list ].	^list.! !RepresentatorRunner removeSelector: #typeRep!AbstractRepresentator subclass: #DistanceZeroRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!AbstractRepresentator subclass: #WeightInverseRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:01' prior: 34638291!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.			statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:01' prior: 34488903!initialize	super initialize.	longestFeature :=0.	maxValue := 0.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:03' prior: 34663971!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:10' prior: 34629894!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.			statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:10' prior: 34665743!bestKMean: path from: kOne to: kTwo onType: type|result c bestC bestResult statementList representator statementmaker featureList aStream |	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		c := (SqrSumAnalyzer new) analyze: result with: k.		(c < bestC ) ifTrue: [ 			bestC:= c.			bestResult := result. 			]	 ].! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:11'!initCentroids: k with: featureList	super initCentroids: k with: featureList maxedTo: maxValue.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:11' prior: 34667686!initCentroids: k with: featureList	^super initCentroids: k with: featureList maxedTo: maxValue.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:12'!makeFeaturesFrom: aFeatureList "List containing Statement Elements, defined in StrucutureFinder"	! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:13' prior: 34668096!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"	! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:17' prior: 34668315!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"|featureList|featureList := OrderedCollection new.aFeatureList do: [ :feature|	 |int|	int := feature representation.	(feature representation = 0) ifTrue: [ feature  representation: 0 ]; ifFalse: [1/ (feature representation)].	featureList add: (feature representation)		].! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:18' prior: 34668543!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"|featureList|featureList := OrderedCollection new.aFeatureList do: [ :feature|	(feature representation = 0) ifTrue: [ feature  representation: 0 ]; ifFalse: [1/ (feature representation)].	featureList add: (feature)		].maxValue :=1.^featureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:19' prior: 34669049!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"|featureList|featureList := OrderedCollection new.aFeatureList do: [ :feature|	(feature representation = 0) ifTrue: [ feature representation: 0 ]; ifFalse: [1/ (feature representation)].	featureList add: (feature)		].maxValue :=1.^featureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:21' prior: 34669529!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	(feature representation = 0) ifTrue: [ feature representation: 0 ]; ifFalse: [1/ (feature representation)].	].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:21' prior: 34670008!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	(feature representation = 0) ifFalse: [1/ (feature representation)].	].maxValue :=1.^aFeatureList.! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:49'!makeFeaturesFrom: aFeatureList "List containing Statement Elements, defined in StrucutureFinder"	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:49' prior: 34670750!makeFeaturesFrom: aFeatureList 	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:50' prior: 34670968!makeFeaturesFrom: aFeatureList	|typePosition|		aFeatureList do: [  				].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:51' prior: 34671121!makeFeaturesFrom: aFeatureList	|typePosition|	typePosition := OrderedCollection new.	aFeatureList do: [  				].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:51' prior: 34671321!makeFeaturesFrom: aFeatureList	|typePosition|	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|						].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:52' prior: 34671559!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|								].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:53' prior: 34671809!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|								].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:53' prior: 34672073!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|		currentPos := currentPos + 1.						].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 16:54' prior: 34672355!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|		currentPos := currentPos + 1.				(feature representation > typePosition size) ifTrue: [  			typePosition add: currentPos.				].				].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:06' prior: 34672666!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := OrderedCollection new.	aFeatureList do: [  :feature|		currentPos := currentPos + 1.									].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:09' prior: 34673076!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		currentPos := currentPos + 1.									].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:12' prior: 34673392!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		currentPos := currentPos + 1.		(typePosition includesKey: (feature representation)) ifFalse: [			typePosition at: feature representation put: currentPos].				feature  representation: currentPos - (typePosition at: (feature representation)).				].	! !TestCase subclass: #DistanceZeroRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:16'!testMakeFromFeature! !TestCase subclass: #DistanceZeroRepresentatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:21'!setUp! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:22' prior: 34674605!setUptestFeature := LinkedList new.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:23' prior: 34670407!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	feature representation do:[ :element|	(element = 0) ifFalse: [1/ (feature representation)].	].].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:25' prior: 34674893!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	feature representation do:[ :element|	(element = 0) ifFalse: [1/ (element)].	].].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:26' prior: 34675280!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	feature representation do:[ :element|	(element = 0) ifFalse: [ feature  representation: (1/ (element))].	].].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:27' prior: 34675652!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].	].].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:28' prior: 34676052!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].	].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:28' prior: 34676501!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:30' prior: 34673701!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element)) ifFalse: [			typePosition at: element put: currentPos].				feature  representation: currentPos - (typePosition at: (feature representation)).			].	].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:30' prior: 34677463!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].				feature  representation: currentPos - (typePosition at: (feature representation)).			].	].	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:31' prior: 34677991!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].				feature  representation: currentPos - (typePosition at: (element asInteger)).			].	].	! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:32' prior: 34674735!setUp|vector1 vector2 feature1 feature2|testFeature := LinkedList new.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:32' prior: 34679088!setUp|vector1 vector2 feature1 feature2|vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:34' prior: 34679286!setUp|vector1 vector2 feature1 feature2|vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:34' prior: 34679588!setUp|vector1 vector2 feature1 feature2|vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:34' prior: 34680020!setUp|vector1 vector2 feature1 feature2|vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:35' prior: 34680521!setUp|vector1 vector2 feature1 feature2|vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:39' prior: 34681076!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature :=rep makeFeaturesFrom: testFeature.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:39' prior: 34681742!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:40' prior: 34674336!testMakeFromFeature|feature1 |testFeature at: 1! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:40' prior: 34683259!testMakeFromFeature|feature1 |feature1 := testFeature at: 1! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:41' prior: 34683433!testMakeFromFeature|feature1 rep1|rep1 := (testFeature at: 1) representation! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:41' prior: 34683620!testMakeFromFeature| rep1|rep1 := (testFeature at: 1) representation! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:41' prior: 34683824!testMakeFromFeature| rep1|rep1 := (testFeature at: 1) representation.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:42' prior: 34684020!testMakeFromFeature| rep1|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 0.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:43' prior: 34684217!testMakeFromFeature| rep1|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:43' prior: 34684631!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:43' prior: 34685045!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 2.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = 4.self assert: (rep2 at: 6) = 2.self assert: (rep2 at: 7) = 6.self assert: (rep2 at: 8) = 6.! !!DistanceZeroRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:44' prior: 34685509!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:45' prior: 34678540!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature|		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].				feature  representation: currentPos - (typePosition at: (element asInteger)).			].	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:47' prior: 34686931!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature| |list|		list:=OrderedCollection new.		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].				feature  representation: currentPos - (typePosition at: (element asInteger)).			].	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:47' prior: 34687489!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature| |list|		list:=OrderedCollection new.		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:48' prior: 34688085!makeFeaturesFrom: aFeatureList	|typePosition currentPos|	currentPos := 0.	typePosition := Dictionary new.	aFeatureList do: [  :feature| |list|		list:=OrderedCollection new.		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:49' prior: 34688664!makeFeaturesFrom: aFeatureList	|typePosition currentPos|		typePosition := Dictionary new.	aFeatureList do: [  :feature| |list|		list:=OrderedCollection new.		currentPos := 0.		feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:51' prior: 34689274!makeFeaturesFrom: aFeatureList	|typePosition currentPos|		typePosition := Dictionary new.	aFeatureList do: [  :feature| 		|list|		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:52' prior: 34689887!makeFeaturesFrom: aFeatureList	|typePosition currentPos|			aFeatureList do: [  :feature| 		|list|		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 17:52' prior: 34690506!makeFeaturesFrom: aFeatureList	|typePosition currentPos|		aFeatureList do: [  :feature| 		|list|		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].^aFeatureList	! !----SNAPSHOT----2016-06-20T17:53:33.308826+02:00 Pharo4.0.image priorSource: 1096805!----STARTUP----2016-06-20T17:55:27.983871+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!TestCase subclass: #WeightInverseRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!----SNAPSHOT----2016-06-20T18:03:48.552871+02:00 Pharo4.0.image priorSource: 1137199!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 20:56' prior: 34624075!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 50) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 20:58' prior: 34664868!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 20:58' prior: 34692150!kMean: featureList with: k on: representator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 60) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ :c|				|d|				d :=  Vector distanceFrom: (centroids at:c) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: c.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :c|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = c) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: c put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 20:59' prior: 34641482!initialize|day hour minute second|c := OrderedCollection new.timestamp := DateAndTime current asString.day := ''.hour:= ''.minute := ''.second := ''.(1 to: 10 )do:[ :a|	day:= day , (timestamp at: a) asString].(11 to: 13 )do:[ :a|	hour:= hour , (timestamp at: a) asString].(15 to: 16 )do:[ :a|	minute:= minute , (timestamp at: a) asString].(18 to: 19 )do:[ :a|	second:= second , (timestamp at: a) asString].timestamp :=  day, hour, minute, second.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:00' prior: 34693191!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	^result			! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:01'!asString	^ self subclassResponsibility ! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:02'!asString	'"Distance Zero Representator'.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:03'!asString	^'Runner'! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:03'!asString	^'Type Representator'! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:03'!asString	^'Weight Inverse Representator'! !Smalltalk globals removeClassNamed: #AbstractWeightRepresentator!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:05' prior: 34695804!runOn: path with: k type: type	|statementList representator statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:05'!saveConfig: representator to: path! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:06' prior: 34698369!saveConfig: representator to: path|fileName|fileName := 'configuration_used.txt'! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:09' prior: 34698497!saveConfig: representator to: path| string fileName|fileName := 'configuration_used.txt'.string := representator typeRep asString, Character cr asString , representator distRep asString,Character cr asString, representator weightRep asString.self saveFile: string to: path, fileName.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:11'!distRep^distRep! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:12'!typeRep^typeRep.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:12'!weightRep^weightRep.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:14' prior: 34698673!saveConfig: representator to: path| string fileName|fileName := 'configuration_used.txt'.string := (representator typeRep asString), Character cr asString , (representator distRep asString),Character cr asString, (representator weightRep asString).self saveFile: string to: path, fileName.! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:15' prior: 34696820!asString	'Distance Zero Representator'.! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:16' prior: 34699058!distRep^distRep.! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:16' prior: 34699815!asString	^'Distance Zero Representator'.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:18' prior: 34699402!saveConfig: representator to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString), Character cr asString , (representator distRep asString),Character cr asString, (representator weightRep asString).self saveFile: string to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:20' prior: 34700241!saveConfig: representator to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString , (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString). ].self saveFile: string to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:20' prior: 34700629!saveConfig: representator to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString). ].self saveFile: string to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:20' prior: 34701145!saveConfig: representator to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].self saveFile: string to: path, fileName.! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type'	classVariableNames: ''	category: 'Structure-K-means'!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 6/20/2016 21:30' prior: 34701660!saveConfig: representator to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].self saveFile: string to: path, fileName.! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:31'!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].self saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:31' prior: 34702962!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].c.type.filHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:32' prior: 34697425!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:32' prior: 34704029!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	type := aType.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:32' prior: 34704989!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	type := aType.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:33' prior: 34705963!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	type := aType.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	c := 	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:34' prior: 34706935!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	type := aType.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	c := SqrSumAnalyzer new analyze: featureList  with: k.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:34' prior: 34707912!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	aStream := (FileHandler new) projectAsStream: path type: type.	type := aType.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	c := (SqrSumAnalyzer new) analyze: featureList  with: k.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:36' prior: 34666720!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList|	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:38' prior: 34703488!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].c do: [ :aC| string := string, Character cr asString]type.filHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:38' prior: 34710944!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, Character cr asString]type.filHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:38' prior: 34711536!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, Character cr asString].string := string , Character cr asString,typefilHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:38' prior: 34712170!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, c asString, Character cr asString].string := string , Character cr asString,typefilHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:39' prior: 34708938!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	c := (SqrSumAnalyzer new) analyze: featureList  with: k.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:39' prior: 34709966!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList|	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:40' prior: 34714560!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList|	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 21:50' prior: 34713532!runOn: path with: k type: aType	|statementList statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	c := (SqrSumAnalyzer new) analyze: result with: k.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:04' prior: 34694068!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:07' prior: 34716546!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:07' prior: 34718617!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	(FileHandler new) saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:08' prior: 34719643!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: representator to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !FileHandler removeSelector: #saveConfig:to:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:10' prior: 34712845!saveConfig: filHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, c asString, Character cr asString].string := string , Character cr asString,typefileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:11' prior: 34720681!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:12' prior: 34721752!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, c asString, Character cr asString].string := string , Character cr asString,typefileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:13' prior: 34723469!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, c asString, Character cr asString].string := string , Character cr asString,type.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:15' prior: 34724158!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:16' prior: 34724848!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:17' prior: 34725539!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.fileHandler saveFile: string to: path, fileName.! !----SNAPSHOT----2016-06-20T22:23:01.673871+02:00 Pharo4.0.image priorSource: 1137527!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:23' prior: 34715554!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList|	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:24' prior: 34727031!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList|	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: FileHandler new to: (path, '\result\' , type ,'\' , timestamp).! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:25' prior: 34728117!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath|	newpath := path, '\result\' , type ,'\' , timestamp.	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: FileHandler new to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:25' prior: 34729284!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		(FileHandler new) save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: FileHandler new to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:26' prior: 34730444!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	type := aType.	aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:26' prior: 34731643!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:27' prior: 34732817!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: fHandler to: newpath.! !----SNAPSHOT----2016-06-20T22:29:04.998871+02:00 Pharo4.0.image priorSource: 1172408!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:32' prior: 34717568!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 10) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:33' prior: 34735255!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 50) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:34' prior: 34736305!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:34' prior: 34737355!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 1000) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:35' prior: 34738406!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 40) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:35' prior: 34739458!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 30) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:36' prior: 34740508!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 1) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/20/2016 22:36' prior: 34741558!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 20) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----QUIT----2016-06-20T23:01:25.725871+02:00 Pharo4.0.image priorSource: 1180632!----STARTUP----2016-06-21T09:19:13.108449+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-06-21T09:20:32.412449+02:00 Pharo4.0.image priorSource: 1189121!----QUIT----2016-06-21T09:23:59.836449+02:00 Pharo4.0.image priorSource: 1189313!----STARTUP----2016-06-21T13:10:19.868688+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:35' prior: 34691128!makeFeaturesFrom: aFeatureList	|typePosition currentPos  biggestNumber|	biggestNumber := 0.	aFeatureList do: [  :feature| 		|list|				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].		(biggestNumber < currentPos - (typePosition at: (element asInteger))) ifTrue: [ biggestNumber =  (typePosition at: (element asInteger))].			list add: currentPos - (typePosition at: (element asInteger)).			].	feature representation: list.	].	maxValue = biggestNumber. ^aFeatureList	! !!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:35' prior: 34549888!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:37' prior: 34744141!makeFeaturesFrom: aFeatureList	|typePosition currentPos  biggestNumber|	biggestNumber := 0.	aFeatureList do: [  :feature| 		|list|				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|			|n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].		n := currentPos - (typePosition at: (element asInteger)).		(biggestNumber < n) ifTrue: [ biggestNumber =  n].			list add: n.			].	feature representation: list.	].	maxValue = biggestNumber. ^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:42' prior: 34746074!makeFeaturesFrom: aFeatureList	|typePosition currentPos  biggestNumber|	biggestNumber := 0.	aFeatureList do: [  :feature| 		|list|				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|			|n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].		n := currentPos - (typePosition at: (element asInteger)).		(n > biggestNumber) ifTrue: [ biggestNumber =  n].			list add: n.			].	feature representation: list.	].	maxValue = biggestNumber. ^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:43' prior: 34746829!makeFeaturesFrom: aFeatureList	|typePosition currentPos  biggestNumber|	biggestNumber := 0.	aFeatureList do: [  :feature| 		|list|				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|			|n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].		n := currentPos - (typePosition at: (element asInteger)).		(n > biggestNumber) ifTrue: [ biggestNumber :=  n].			list add: n.			].	feature representation: list.	].	maxValue = biggestNumber. ^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:45' prior: 34747584!makeFeaturesFrom: aFeatureList	|typePosition currentPos  biggestNumber|	biggestNumber := 0.	aFeatureList do: [  :feature| 		|list|				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|			|n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].		n := currentPos - (typePosition at: (element asInteger)).		(n > biggestNumber) ifTrue: [ biggestNumber :=  n].			list add: n.			].	feature representation: list.	].	maxValue := biggestNumber. ^aFeatureList	! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:48' prior: 34676982!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue := 1.^aFeatureList.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:50' prior: 34722440!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:50' prior: 34733992!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			c add: aC.			]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:53' prior: 34750598!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 13:53' prior: 34751776!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.			]	 ].self saveConfig: fHandler to: newpath.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:03' prior: 34619550!analyze: result with: k| sum kc|sum := 0.kc := k."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature|	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| (Vector distanceFrom: LinkedList new to: vector =0)  ].^sum/k.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:03' prior: 34754136!analyze: result with: k| sum kc|sum := 0.kc := k."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature|	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| (Vector distanceFrom: LinkedList new to: vector =0)  ifTrue:[kc-1]].^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:04' prior: 34754638!analyze: result with: k| sum kc|sum := 0.kc := k."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature|	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| (Vector distanceFrom: LinkedList new to: vector = 0)  ifTrue:[kc-1]].^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:05' prior: 34755154!analyze: result with: k| sum kc|sum := 0.kc := k."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature|	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector) = 0)  ifTrue:[kc-1]].^sum/kc.! !----STARTUP----2016-06-21T14:13:08.691309+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!TypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:13' prior: 34549888!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		|array feature|		feature := Feature new.		feature statement: aStatement.		array := Array new.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:15' prior: 34691128!makeFeaturesFrom: aFeatureList	|typePosition currentPos|		aFeatureList do: [  :feature| 		|list b|		b:=0.		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b > n) ifTrue: [ b := n ].			].	feature representation: list.	].^aFeatureList	! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:16' prior: 34757418!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b > n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:16' prior: 34733992!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !----SNAPSHOT----2016-06-21T14:16:59.865309+02:00 Pharo4.0.image priorSource: 1189400!!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:18' prior: 34619550!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !----SNAPSHOT----2016-06-21T14:19:00.338309+02:00 Pharo4.0.image priorSource: 1205415!----SNAPSHOT----2016-06-21T14:23:54.102309+02:00 Pharo4.0.image priorSource: 1206023!!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:28' prior: 34758094!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !----SNAPSHOT----2016-06-21T14:29:28.527309+02:00 Pharo4.0.image priorSource: 1206110!!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:31' prior: 34676982!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))*10]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=10.^aFeatureList.! !----SNAPSHOT----2016-06-21T14:45:06.851309+02:00 Pharo4.0.image priorSource: 1206888!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:46' prior: 34722440!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:47' prior: 34758772!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:48' prior: 34760040!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	]."(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]." ^sum/kc.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:48' prior: 34742607!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 50) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:49' prior: 34764298!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:49' prior: 34765871!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	]."(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]." ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 14:50' prior: 34766392!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 15:07' prior: 34766915!analyze: result with: k| sum kc dict|dict := Dictionary new.kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)).	(dict includesKey: feature klabel) ifFalse: [  ].	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 15:08' prior: 34767436!analyze: result with: k| sum kc dict|dict := Dictionary new.kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)).	(dict includesKey: feature klabel) ifFalse: [dict at: feature klabel put: feature klabel ].	].(result at: 2) do: [ :vector| ((Vector distanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 15:09' prior: 34768038!analyze: result with: k| sum kc dict|dict := Dictionary new.kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)).	(dict includesKey: feature klabel) ifFalse: [dict at: feature klabel put: feature klabel ].	]. ^sum/(dict keys size).! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 15:10' prior: 34768682!analyze: result with: k| sum dict|dict := Dictionary new.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector distanceFrom: feature representation  to: ((result at: 2) at: feature klabel)).	(dict includesKey: feature klabel) ifFalse: [dict at: feature klabel put: feature klabel ].	]. ^sum/(dict keys size).! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:37'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:37' prior: 34769783!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 4.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:38'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:39' prior: 34771287!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = (1/2).self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:39' prior: 34761525!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue := 1.^aFeatureList.! !!WeightInverseRepresentatorTest methodsFor: 'tests' stamp: 'CedricWalker 6/21/2016 16:41' prior: 34772001!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = (1/2).self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 0.5.self assert: (rep2 at: 4) = 0.5.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!WeightInverseRepresentatorTest methodsFor: 'tests' stamp: 'CedricWalker 6/21/2016 16:41' prior: 34773196!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = (1/2).self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.5.self assert: (rep2 at: 6) = 0.5.self assert: (rep2 at: 7) = 0.25.self assert: (rep2 at: 8) = 0.25.! !!WeightInverseRepresentatorTest methodsFor: 'tests' stamp: 'CedricWalker 6/21/2016 16:42' prior: 34773912!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = (1/2).self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/4).self assert: (rep2 at: 8) = (1/4).! !!WeightInverseRepresentatorTest methodsFor: 'tests' stamp: 'CedricWalker 6/21/2016 16:43' prior: 34774634!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = (1).self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/4).self assert: (rep2 at: 8) = (1/4).! !!WeightInverseRepresentatorTest methodsFor: 'running' stamp: 'CedricWalker 6/21/2016 16:43' prior: 34770543!setUp|vector1 vector2 feature1 feature2 rep| rep := WeightInverseRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 4.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !TestCase subclass: #TypeRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:45'!setUp! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:46' prior: 34776949!setUp|string rep|rep := TypeRepresentator new.string := '1 123 . , word adfs . asf4 ,, a.a'! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:49' prior: 34777070!setUp|string rep|rep := TypeRepresentator new.string := '1 123 . , word adfs . asf4 ,, a.a'rep makeFeaturesFrom: string.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:49' prior: 34777282!setUp|string rep|rep := TypeRepresentator new.string := '1 123 . , word adfs . asf4 ,, a.a', Character cr asString , ' adf adfs {}af'.rep makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !TestCase subclass: #TypeRepresentatorTest	instanceVariableNames: 'testFeatures'	classVariableNames: ''	category: 'StructureTests'!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:50' prior: 34777523!setUp|string rep|rep := TypeRepresentator new.string := '1 123 . , word adfs . asf4 ,, a.a', Character cr asString , ' adf adfs {}af'.testFeatures := rep makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:52'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 1.self assert: (rep1 at: 2) = (0).self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = (0).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (2).self assert: (rep1 at: 7) = 0.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 0.self assert: (rep1 at: 11) = 2.self assert: (rep1 at: 12) = 0.self assert: (rep1 at: 13) = 2.self assert: (rep1 at: 14) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/4).self assert: (rep2 at: 8) = (1/4).! !TestCase subclass: #TypeRepresentatorTest	instanceVariableNames: 'testFeatures'	classVariableNames: ''	category: 'StructureTests'!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:52' prior: 34778336!testMakeFromFeature| rep1 rep2|rep1 := (testFeatures at: 1) representation.self assert: (rep1 at: 1) = 1.self assert: (rep1 at: 2) = (0).self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = (0).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (2).self assert: (rep1 at: 7) = 0.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 0.self assert: (rep1 at: 11) = 2.self assert: (rep1 at: 12) = 0.self assert: (rep1 at: 13) = 2.self assert: (rep1 at: 14) = 0.rep2 := (testFeatures at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/4).self assert: (rep2 at: 8) = (1/4).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:53' prior: 34779419!testMakeFromFeature| rep1 rep2|rep1 := (testFeatures at: 1) representation.self assert: (rep1 at: 1) = 1.self assert: (rep1 at: 2) = (0).self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = (0).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (2).self assert: (rep1 at: 7) = 0.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 0.self assert: (rep1 at: 11) = 2.self assert: (rep1 at: 12) = 0.self assert: (rep1 at: 13) = 2.self assert: (rep1 at: 14) = 0.rep2 := (testFeatures at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:53' prior: 34780369!testMakeFromFeature| rep1 rep2|rep1 := (testFeatures at: 1) representation.self assert: (rep1 at: 1) = 1.self assert: (rep1 at: 2) = (0).self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = (0).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (2).self assert: (rep1 at: 7) = 0.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 0.self assert: (rep1 at: 11) = 2.self assert: (rep1 at: 12) = 0.self assert: (rep1 at: 13) = 2.self assert: (rep1 at: 14) = 0.rep2 := (testFeatures at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 2.self assert: (rep2 at: 4) = 0.! !----STARTUP----2016-06-21T16:59:00.915824+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:59'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 16:59'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !----SNAPSHOT----2016-06-21T16:59:42.902824+02:00 Pharo4.0.image priorSource: 1207461!!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:00' prior: 34782093!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:01' prior: 34783637!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 1.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = 1/2.self assert: (rep2 at: 7) = 1/3.self assert: (rep2 at: 8) = 1/3.! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:01' prior: 34784350!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 1.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/3).self assert: (rep2 at: 8) = (1/3).! !!WeightInverseRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:01' prior: 34782790!setUp|vector1 vector2 feature1 feature2 rep| rep := WeightInverseRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !----SNAPSHOT----2016-06-21T17:02:48.307824+02:00 Pharo4.0.image priorSource: 1228996!!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:03' prior: 34761525!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !----SNAPSHOT----2016-06-21T17:03:35.424824+02:00 Pharo4.0.image priorSource: 1232025!TestCase subclass: #TypeRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:04'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:05' prior: 34787333!setUp|vector1 vector2 feature1  |testFeature := (TypeRepresentator new) NewLineStatementmaker new.! !----SNAPSHOT----2016-06-21T17:05:29.340824+02:00 Pharo4.0.image priorSource: 1232594!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:06' prior: 34788084!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4'.testFeature := (TypeRepresentator new) NewLineStatementmaker new createTokanizedStatement: string.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:08' prior: 34788387!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4'.testFeature := (TypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:09'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 1.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 0.self assert: (rep1 at: 6) = (1/2).self assert: (rep1 at: 7) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 0.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = (1/2).self assert: (rep2 at: 6) = (1/2).self assert: (rep2 at: 7) = (1/3).self assert: (rep2 at: 8) = (1/3).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:10' prior: 34789016!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 0.self assert: (rep1 at: 10) = 2.self assert: (rep1 at: 11) = 1.self assert: (rep1 at: 12) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = (2).self assert: (rep2 at: 6) = (0).! !----SNAPSHOT----2016-06-21T17:10:38.245824+02:00 Pharo4.0.image priorSource: 1233755!----SNAPSHOT----2016-06-21T17:10:43.496824+02:00 Pharo4.0.image priorSource: 1236008!TestCase subclass: #VectorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:12'!testdistanceFrom: vec1 to: vec2 ! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:13' prior: 34790812!testdistanceFrom: vec1 to: vec2 self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:14' prior: 34790949!testdistanceFrom: vec1 to: vec2 |list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0.self assert: (Vector distanceFrom: list1 to:  LinkedList new) = 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:14' prior: 34791162!testdistanceFrom: vec1 to: vec2 |list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0.self assert: (Vector distanceFrom: list1 to:  LinkedList new) = list1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:15'!testdistanceFrom|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0.self assert: (Vector distanceFrom: list1 to:  LinkedList new) = list1.! !VectorTest removeSelector: #testdistanceFrom:to:!!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:15' prior: 34791948!testdistanceFrom|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0."self assert: (Vector distanceFrom: list1 to:  LinkedList new) = list1."! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:16' prior: 34792386!testdistanceFrom|list1 list12|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list12 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:17' prior: 34792775!testdistanceFrom|list1 list12|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list12 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list1 add: 0.list12 := Vector distanceFrom: list1 to: LinkedList new.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:17' prior: 34793125!testdistanceFrom|list1 list12|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list12 := LinkedList new.list1 add: 0.list1 add: 5.list1 add: 6.list1 add: 0.list1 add: 7.list12 := Vector distanceFrom: list1 to: LinkedList new.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:18' prior: 34793532!testdistanceFrom|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector distanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector distanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:20'!testdivideThrough! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:20' prior: 34794310!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector distanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector distanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:20' prior: 34794432!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector divide: list1 through: 5 ) = 1.self assert: (Vector distanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:21' prior: 34794831!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self assert: (Vector distanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:21' prior: 34795216!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.! !----SNAPSHOT----2016-06-21T17:21:56.362824+02:00 Pharo4.0.image priorSource: 1236095!!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:22' prior: 34795668!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self assert: ((Vector divide: list1 through: 0)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 0)at: 2 ) = 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:25' prior: 34796141!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self assert: ((Vector divide: list1 through: 0)at: 1 ) = 0.self should: (Vector divide: list1 through: 0) raise: ZeroDivide! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:25' prior: 34796648!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self should: (Vector divide: list1 through: 0) raise: ZeroDivide! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:25' prior: 34797160!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self should: (Vector divide: list1 through: 0) raise: ZeroDivide new.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:25' prior: 34797613!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1.self should: (Vector divide: list1 through: 0) raise: ZeroDivide.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34798071!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1."self should: (Vector divide: list1 through: 0) raise: ZeroDivide."! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34798525!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = 1/5."self should: (Vector divide: list1 through: 0) raise: ZeroDivide."! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34798981!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5)."self should: (Vector divide: list1 through: 0) raise: ZeroDivide."! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34799439!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: (Vector divide: list1 through: 0) raise: ZeroDivide.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34799899!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: (Vector divide: list1 through: 0) raise: ZeroDivide new.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:26' prior: 34800357!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: (Vector divide: list1 through: 0) raise: ZeroDivide.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:30' prior: 34800819!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: (Vector divide: list1 through: 0) raise: Error.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:31' prior: 34801277!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: (Vector divide: list1 through: 0) raise: ZeroDivide.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:31' prior: 34801730!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5)."self should: (Vector divide: list1 through: 0) raise: ZeroDivide."! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:32' prior: 34802188!testdivideThrough|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: [Vector divide: list1 through: 0] raise: ZeroDivide.! !----SNAPSHOT----2016-06-21T17:32:34.649824+02:00 Pharo4.0.image priorSource: 1241520!!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:33'!testsumVec! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:34' prior: 34803177!testsumVec|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1)=0 ! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:34' prior: 34803292!testsumVec|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0. ! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:34' prior: 34803614!testsumVec|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0.  ! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:35' prior: 34803939!testsumVec|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 new plus: LinkedList new) at: 2) = 0. ! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:35' prior: 34804335!testsumVec|list1|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:36' prior: 34804878!testsumVec|list1 list2|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list2 add: 2.list2 add: 2.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 0.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:37' prior: 34805416!testsumVec|list1 list2|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list2 add: 2.list2 add: 2.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 0.self assert: ((Vector sumVec: list1 plus: list2) at: 1) = 2.self assert: ((Vector sumVec: list1 plus: list2) at: 2) = 2.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:37' prior: 34806014!testsumVec|list1 list2|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list2 add: 2.list2 add: 1.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 0. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 0.self assert: ((Vector sumVec: list1 plus: list2) at: 1) = 2.self assert: ((Vector sumVec: list1 plus: list2) at: 2) = 2.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/21/2016 17:37' prior: 34806735!testsumVec|list1 list2|self assert: (Vector distanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list2 add: 2.list2 add: 1.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 1. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 1.self assert: ((Vector sumVec: list1 plus: list2) at: 1) = 2.self assert: ((Vector sumVec: list1 plus: list2) at: 2) = 2.! !Smalltalk globals removeClassNamed: #AbstractDistance!TestCase subclass: #SqrSumAnalyzerTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!----SNAPSHOT----2016-06-21T17:39:01.339824+02:00 Pharo4.0.image priorSource: 1248572!----STARTUP----2016-06-21T17:55:04.200837+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-06-21T19:12:57.314837+02:00 Pharo4.0.image priorSource: 1253819!----SNAPSHOT----2016-06-21T20:13:13.642837+02:00 Pharo4.0.image priorSource: 1254015!----QUIT----2016-06-21T20:29:51.621837+02:00 Pharo4.0.image priorSource: 1254102!----STARTUP----2016-06-22T14:13:31.335892+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-06-22T14:31:29.018892+02:00 Pharo4.0.image priorSource: 1254189!(Smalltalk globals at: #TypeRepresentator) rename: #StructureTypeRepresentator!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:32' prior: 34722440!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: StructureTypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:32' prior: 34758772!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: StructureTypeRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:32' prior: 34788699!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4'.testFeature := (StructureTypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:33'!initCentroids: k with: featureList	^super initCentroids: k with: featureList maxedTo: maxValue.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:36'!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"longestFeature. "needs to be defined"maxValue.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:37'!asString	^'Specfic Type Representator'.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:39' prior: 34811850!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict|currentLongest := 0.currentMax := 0.dict := Dictionary new.longestFeature := currentLongest. "needs to be defined"maxValue := currentMax.! !----SNAPSHOT----2016-06-22T14:44:39.807892+02:00 Pharo4.0.image priorSource: 1254381!!StructureElements methodsFor: 'initialization' stamp: 'CedricWalker 6/22/2016 14:45' prior: 34354967!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	structureArray := OrderedCollection new.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.! !!StructureElements methodsFor: 'initialization' stamp: 'CedricWalker 6/22/2016 14:45' prior: 34812729!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	structureArray := OrderedCollection new.			pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .! !!StructureElements methodsFor: 'initialization' stamp: 'CedricWalker 6/22/2016 14:45' prior: 34813734!initialize	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	structureArray := OrderedCollection new.		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:47' prior: 34812261!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict|currentLongest := 0.currentMax := 0.dict := Dictionary new.aStatmentList do:[:statement|	].longestFeature := currentLongest. "needs to be defined"maxValue := currentMax.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:48' prior: 34815759!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict|currentLongest := 0.currentMax := 0.dict := Dictionary new.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			].	].longestFeature := currentLongest. "needs to be defined"maxValue := currentMax.! !!StructureTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:49' prior: 34756302!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		intId := #digit asParser plus.		puncId := #punctuation asParser plus, #any asParser star.		wordId := #word asParser plus.			aStatmentList do: [ :aStatement|  		| feature|		feature := Feature new.		feature statement: aStatement.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:51' prior: 34816188!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict|currentLongest := 0.currentMax := 0.dict := Dictionary new.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			].	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:51' prior: 34817845!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict typeInt typeWord typePunc |currentLongest := 0.currentMax := 0.dict := Dictionary new.	typeInt  := 1.		typeWord := 0.		typePunc := 2.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			].	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:52' prior: 34818403!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict typeInt typeWord typePunc |currentLongest := 0.currentMax := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			].	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:54' prior: 34819037!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict typeInt typeWord typePunc |currentLongest := 0.currentMax := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						].	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:56' prior: 34819667!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature |currentLongest := 0.currentMax := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:58' prior: 34820301!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|currentLongest currentMax dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.currentLongest := 0.currentMax := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := currentLongest. "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:59' prior: 34821338!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 14:59' prior: 34822395!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:03' prior: 34823556!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				feature addFeatureElement: typeInt].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:03' prior: 34824716!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			runner := runner +1.			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: 				feature addFeatureElement: typeInt				].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:04' prior: 34825927!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: 				feature addFeatureElement: typeInt				].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:05' prior: 34827181!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: 1/runner+typeInt.				].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:05' prior: 34828415!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: 1/runner+typeInt.				runner := runner +1.				]; ifTrue:[								].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:06' prior: 34829678!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: 1/runner+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: 1/ (dict at: aToken) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:07' prior: 34830987!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:09' prior: 34832356!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:09' prior: 34833729!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:10' prior: 34835307!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			" { and } should be equal!!"									].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:12' prior: 34836887!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				str returnIfContains: aToken.													feature addFeatureElement: typePunc].														].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:16'!getPaired: aCharaChar = element1 ifTrue: [ ^element1 ].aChar = element2 ifTrue: [ ^element1 ]! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:16' prior: 34840212!getPaired: aCharaChar = element1 ifTrue: [ ^element1 ].aChar = element2 ifTrue: [ ^element1 ].! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:16' prior: 34840415!getPaired: aCharaChar = element1 ifTrue: [ ^element1 ].aChar = element2 ifTrue: [ ^element2 ].! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:16' prior: 34840619!getPaired: aCharaChar = element1 ifTrue: [ ^element2 ].aChar = element2 ifTrue: [ ^element1 ].! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:19' prior: 34838507!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((str returnIfContains: aToken) isPaired) ifTrue: [ ((dict includesKey: aToken) or: (dict includesKey: (str returnIfContains: aToken) getPaired: aToken))										].													feature addFeatureElement: typePunc].														].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:21' prior: 34841039!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((str returnIfContains: aToken) isPaired) ifTrue: [ ((dict includesKey: aToken) or: (dict includesKey: (str returnIfContains: aToken) getPaired: aToken)) ifFalse:[						dict at: aToken put: runner.						feature addFeatureElement: (1/runner)+typePunc.						runner := runner +1.						]; ifTrue: [feature addFeatureElement: (1/ (dict at: aToken)) + typePunc].										].													feature addFeatureElement: typePunc].														].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]	].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:24' prior: 34842910!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((str returnIfContains: aToken) isPaired) ifTrue: [ ((dict includesKey: aToken) or: (dict includesKey: (str returnIfContains: aToken) getPaired: aToken)) ifFalse:[						dict at: aToken put: runner.						feature addFeatureElement: (1/runner)+typePunc.						runner := runner +1.						]; ifTrue: [feature addFeatureElement: (1/ (dict at: aToken)) + typePunc].										]; ifFalse: [						(dict includesKey: aToken) ifFalse:[						dict at: aToken put: runner.						feature addFeatureElement: (1/runner)+typePunc.						runner := runner +1.						]; ifTrue: [feature addFeatureElement: (1/ (dict at: aToken)) + typePunc].						].					].				].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !TestCase subclass: #SpecificTypeRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!TestCase subclass: #SpecificTypeRepresentatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:25'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 0.self assert: (rep1 at: 10) = 2.self assert: (rep1 at: 11) = 1.self assert: (rep1 at: 12) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = (2).self assert: (rep2 at: 6) = (0).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:26'!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4'.testFeature := (StructureTypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:27' prior: 34848331!setUp|string |string := '{ 1 1 1 a a b c }' , Character cr asString, 'a . , 1 2 3'.testFeature := (StructureTypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:29' prior: 34847530!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 1.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 3.self assert: (rep1 at: 6) = (3).self assert: (rep1 at: 7) = 4.self assert: (rep1 at: 8) = 5.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 3.self assert: (rep2 at: 4) = 4.self assert: (rep2 at: 5) = (5).self assert: (rep2 at: 6) = (6).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:29' prior: 34849019!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 1/1.self assert: (rep1 at: 2) = 1/2.self assert: (rep1 at: 3) = 1/2.self assert: (rep1 at: 4) = (1/2).self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/1.self assert: (rep2 at: 2) = 1/2.self assert: (rep2 at: 3) = 1/3.self assert: (rep2 at: 4) = 1/4.self assert: (rep2 at: 5) = (1/5).self assert: (rep2 at: 6) = (1/6).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:30' prior: 34849709!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/1.self assert: (rep2 at: 2) = 1/2.self assert: (rep2 at: 3) = 1/3.self assert: (rep2 at: 4) = 1/4.self assert: (rep2 at: 5) = (1/5).self assert: (rep2 at: 6) = (1/6).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:31' prior: 34850427!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/1.self assert: (rep2 at: 2) = (1/2)+2.self assert: (rep2 at: 3) = (1/3)+2.self assert: (rep2 at: 4) = (1/4)+1.self assert: (rep2 at: 5) = (1/5)+1.self assert: (rep2 at: 6) = (1/6)+1.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 15:36' prior: 34844988!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((str returnIfContains: aToken asCharacter) isPaired) ifTrue: [ ((dict includesKey: aToken) or: (dict includesKey: (str returnIfContains: aToken asCharacter) getPaired: aToken)) ifFalse:[						dict at: aToken put: runner.						feature addFeatureElement: (1/runner)+typePunc.						runner := runner +1.						]; ifTrue: [feature addFeatureElement: (1/ (dict at: aToken)) + typePunc].										]; ifFalse: [						(dict includesKey: aToken) ifFalse:[						dict at: aToken put: runner.						feature addFeatureElement: (1/runner)+typePunc.						runner := runner +1.						]; ifTrue: [feature addFeatureElement: (1/ (dict at: aToken)) + typePunc].						].					].				].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.! !----SNAPSHOT----2016-06-22T15:41:42.257892+02:00 Pharo4.0.image priorSource: 1258106!!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:23' prior: 34851911!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at: 1) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: (str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 ))).					];ifFalse: [].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:24' prior: 34854303!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at: 1) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: (str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 ))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:24' prior: 34856187!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at: 1) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: (str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 ))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:25' prior: 34858315!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((((str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: (str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 ))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:26' prior: 34860443!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((((str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: ((dict includesKey: (str returnIfContains: (aToken at: 1))) getPaired: (aToken at: 1 ))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:28' prior: 34862573!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 0.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((((str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:28' prior: 34864705!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				((((str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1))) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:30' prior: 34866837!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at:1)) and: (str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1)) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:30' prior: 34868969!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at:1)) and: (str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1)) ifTrue: [					 ((dict includesKey: (aToken at: 1)=nil) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:31' prior: 34871142!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at:1) = nil) and: (str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1)) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:31' prior: 34873319!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(((str returnIfContains: (aToken at: 1)) isPaired) and: ( aToken size = 1)) ifTrue: [					 ((dict includesKey: (aToken at: 1)) or: (dict includesKey: ((str returnIfContains: (aToken at: 1)) getPaired: (aToken at: 1 )))).					];ifFalse: [(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typePunc.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 				].					].				].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:56' prior: 34875498!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(str returnIfContains: (aToken at: 1 ) = nil) ifFalse: [  ].						].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !----SNAPSHOT----2016-06-22T17:56:19.660892+02:00 Pharo4.0.image priorSource: 1299667!!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:56' prior: 34877628!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(str returnIfContains: (aToken at: 1 ) = nil) ifFalse: [  (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].						].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:57' prior: 34879423!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [  (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			]; ifFalse:[].									].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:58' prior: 34881373!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					 (dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typeWord.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 					].			]; ifFalse:[							].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:58' prior: 34883338!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.				(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typeWord.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 					].			]; ifFalse:[							].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:58' prior: 34885315!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typeWord.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 					].			]; ifFalse:[							].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:58' prior: 34887291!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[							].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 17:58' prior: 34889272!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[													].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:01' prior: 34891253!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((str returnIfContains: (aToken at: 1 )) isPaired and: (aToken size = 1)) ifTrue: [ 															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:01' prior: 34893242!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				(((str returnIfContains: (aToken at: 1 )) isPaired) and: (aToken size = 1)) ifTrue: [ 															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:02' prior: 34895359!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str|				str := StructureElements  getUniqueInstance.								(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				(((str returnIfContains: (aToken at: 1 )) isPaired) and: (aToken size = 1)) ifTrue: [ 					(dict includes: (aToken at: 1))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:04' prior: 34897478!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenElementChar|				str := StructureElements  getUniqueInstance.				tokenElementChar := str returnIfContains: (aToken at: 1 ).				(str returnIfContains: (aToken at: 1 ) = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				(((str returnIfContains: (aToken at: 1 )) isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (str )))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:04' prior: 34899628!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenElementChar|				str := StructureElements  getUniqueInstance.				tokenElementChar := str returnIfContains: (aToken at: 1 ).				(tokenElementChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				(((str returnIfContains: (aToken at: 1 )) isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (str )))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:05' prior: 34901883!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenElementChar|				str := StructureElements  getUniqueInstance.				tokenElementChar := str returnIfContains: (aToken at: 1 ).				(tokenElementChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenElementChar isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (str )))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:06' prior: 34904118!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenElementChar|				str := StructureElements  getUniqueInstance.				tokenElementChar := str returnIfContains: (aToken at: 1 ).				(tokenElementChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenElementChar isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (tokenElementChar getPaired: (aToken at:1))))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:06' prior: 34906330!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (tokenStructureChar getPaired: (aToken at:1))))										 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !----SNAPSHOT----2016-06-22T18:06:28.106892+02:00 Pharo4.0.image priorSource: 1324787!!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:07' prior: 34908579!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					((dict includes: (aToken at: 1)) or: (dict includes: (tokenStructureChar getPaired: (aToken at:1))))ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:10' prior: 34910925!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					(dict includes: (aToken at: 1)) ifTrue: [ 												].																				 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:12' prior: 34913407!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					(dict includes: (aToken at: 1)) ifFalse: [							dict at: aToken put:runner.							feature addFeatureElement: (1/runner)+typePunc.													].																				 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:13' prior: 34915636!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					(dict includes: (aToken at: 1)) ifFalse: [							dict at: aToken put:runner.							feature addFeatureElement: (1/runner)+typePunc.							runner := runner +1.						].																				 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !----SNAPSHOT----2016-06-22T18:13:04.519892+02:00 Pharo4.0.image priorSource: 1356289!!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:15' prior: 34917956!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifTrue: [ 					(dict includes: aToken) ifFalse: [							dict at: aToken put:runner.							feature addFeatureElement: (1/runner)+typePunc.							runner := runner +1.						].					(dict includes:(tokenStructureChar getPaired: (aToken at: 1)) asString) ifTrue: [ 						dict at: aToken put: runner. 						].															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:16' prior: 34920383!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifFalse: [ 					(dict includes: aToken) ifFalse: [							dict at: aToken put:runner.							feature addFeatureElement: (1/runner)+typePunc.							runner := runner +1.						].					(dict includes:(tokenStructureChar getPaired: (aToken at: 1)) asString) ifFalse: [ 						dict at: aToken put: runner. 						feature addFeatureElement: (1/runner) + typePunc.						].															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/22/2016 18:17' prior: 34922842!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[ 	" { and } should be equal!!"				|str tokenStructureChar|				str := StructureElements  getUniqueInstance.				tokenStructureChar := str returnIfContains: (aToken at: 1 ).				(tokenStructureChar  = nil) ifTrue: [					(dict includesKey: aToken) ifFalse: [					dict at: aToken put: runner.					feature addFeatureElement: (1/runner)+typePunc.					runner := runner +1.					]; ifTrue:[						feature addFeatureElement: (1/ (dict at: aToken)) + typePunc. 					].			]; ifFalse:[				((tokenStructureChar isPaired) and: (aToken size = 1)) ifFalse: [ 					(dict includes: aToken) ifFalse: [							dict at: aToken put:runner.							feature addFeatureElement: (1/runner)+typePunc.							runner := runner +1.						]; ifTrue:[ feature addElement: 1/(dict at: aToken) + typePunc].					(dict includes:(tokenStructureChar getPaired: (aToken at: 1)) asString) ifFalse: [ 						dict at: aToken put: runner. 						feature addFeatureElement: (1/runner) + typePunc.						].															 ]; ifFalse:[															].				].			].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList. ! !----QUIT----2016-06-22T18:19:47.395892+02:00 Pharo4.0.image priorSource: 1365747!----STARTUP----2016-06-23T15:25:21.341205+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:45' prior: 34925359!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))).															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [ 						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:45' prior: 34928130!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ] .															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [ 						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:47' prior: 34930260!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								((dict includesKey: (aToken at: 1) not) and:( dict includesKey: (strctChar getPaired: ( aToken at: 1 )) not ))															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [ 						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:47' prior: 34932481!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								((dict includesKey: (aToken at: 1) not) and:( dict includesKey: (strctChar getPaired: ( aToken at: 1 )) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [ 						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:48' prior: 34934820!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								((dict includesKey: (aToken at: 1) not) and:( dict includesKey: (strctChar getPaired: ( aToken at: 1 )) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:49' prior: 34937189!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								((dict includesKey: (aToken at: 1) not) and:( dict includesKey: (strctChar getPaired: ( aToken at: 1 )) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:51' prior: 34939650!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								((dict includesKey: (aToken at: 1) not) and:( dict includesKey: (strctChar getPaired: ( aToken at: 1 )) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:53' prior: 34942111!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: (aToken size = 1) not) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:54' prior: 34944698!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(strctChar = nil and: ((aToken size = 1) not)) ifFalse: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 15:55' prior: 34947290!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:01' prior: 34949884!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:03' prior: 34952480!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil]."no if Ture!!!!"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:04' prior: 34955104!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus.puncId := #punctuation asParser plus, #any asParser star.wordId := #word asParser plus.		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:05' prior: 34811320!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4' , Character cr asString, '{ 1 1 1 a a b c }'.testFeature := (StructureTypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:06' prior: 34789744!testMakeFromFeature| rep1 rep2 rep3|rep3 := (testFeature at: 3) representation.rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 0.self assert: (rep1 at: 10) = 2.self assert: (rep1 at: 11) = 1.self assert: (rep1 at: 12) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = (2).self assert: (rep2 at: 6) = (0).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:07' prior: 34960773!testMakeFromFeature| rep1 rep2 rep3|rep3 := (testFeature at: 3) representation.self assert: (rep3 at: 1) = 2.self assert: (rep3 at: 2) = 1.self assert: (rep3 at: 3) = 1.self assert: (rep3 at: 4) = (1).self assert: (rep3 at: 5) = 0.self assert: (rep3 at: 6) = (0).self assert: (rep3 at: 7) = 0.self assert: (rep3 at: 8) = 0.self assert: (rep3 at: 9) = 2.rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 0.self assert: (rep1 at: 10) = 2.self assert: (rep1 at: 11) = 1.self assert: (rep1 at: 12) = 0.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = (2).self assert: (rep2 at: 6) = (0).! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:20' prior: 34615073!DoIt	| string testFeature typeInt typeWord typePunc intId puncId wordId |	typeInt := 1.	typeWord := 0.	typePunc := 2.	intId := #digit asParser plus.	wordId := (#letter asParser , #any asParser plus)		/ ((#digit asParser , #letter asParser plus) / #punctuation asParser plus).	puncId := #punctuation asParser plus , intId not , wordId not.	string := '{ 1 1 1 a a b c }' , Character cr asString , 'a . , 1 2 3'.	testFeature := SpecificTypeRepresentator new		makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).	testFeature.	^ wordId matches: '1a'! !TestCase subclass: #TokanizerTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!(Smalltalk globals at: #TokanizerTest) rename: #NewLineStatementmakerTest!!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:31'!testcreateTokanizedStatement! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:31'!setUp! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:36' prior: 34963777!setUp|aStream stmt|aStream := '{{{asd 11 1a ab c}', Character cr asString, 'a . , 1 2 3'.stmt := NewLineStatementmaker new.stmt createTokanizedStatement: aStream.! !TestCase subclass: #NewLineStatementmakerTest	instanceVariableNames: 'testStmts'	classVariableNames: ''	category: 'StructureTests'!!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:36' prior: 34963903!setUp|aStream stmt|aStream := '{{{asd 11 1a ab c}', Character cr asString, 'a . , 1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:36' prior: 34964330!setUp|aStream stmt|aStream := '{{{asd 11 1a ab c}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !----SNAPSHOT----2016-06-23T16:41:47.595205+02:00 Pharo4.0.image priorSource: 1373389!!StructureTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:49' prior: 34816756!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".			aStatmentList do: [ :aStatement|  		| feature|		feature := Feature new.		feature statement: aStatement.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !----SNAPSHOT----2016-06-23T16:49:37.748205+02:00 Pharo4.0.image priorSource: 1410388!!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:51' prior: 34961631!testMakeFromFeature| rep1 rep2 rep3|rep3 := (testFeature at: 3) representation.self assert: (rep3 at: 1) = 2.self assert: (rep3 at: 2) = 1.self assert: (rep3 at: 3) = 1.self assert: (rep3 at: 4) = (1).self assert: (rep3 at: 5) = 0.self assert: (rep3 at: 6) = (0).self assert: (rep3 at: 7) = 0.self assert: (rep3 at: 8) = 0.self assert: (rep3 at: 9) = 2.rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 1.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 0.self assert: (rep2 at: 5) = (2).self assert: (rep2 at: 6) = (0).! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:52' prior: 34966297!testMakeFromFeature| rep1 rep2 rep3|rep3 := (testFeature at: 3) representation.self assert: (rep3 at: 1) = 2.self assert: (rep3 at: 2) = 1.self assert: (rep3 at: 3) = 1.self assert: (rep3 at: 4) = (1).self assert: (rep3 at: 5) = 0.self assert: (rep3 at: 6) = (0).self assert: (rep3 at: 7) = 0.self assert: (rep3 at: 8) = 0.self assert: (rep3 at: 9) = 2.rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 0.self assert: (rep1 at: 4) = (2).self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = (0).self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 2.self assert: (rep1 at: 10) = 1.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 2.self assert: (rep2 at: 5) = (0).! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:53' prior: 34957755!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: (aToken at: 1)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1)) not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 16:59' prior: 34851163!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/8)+1.self assert: (rep2 at: 5) = (1/2)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:08' prior: 34968422!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1))  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:08' prior: 34971913!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 )asString)) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1))  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ))) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:09' prior: 34974672!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 )asString)) ifTrue: [ feature addFeatureElement: 1/(strctChar getPaired: ( aToken at: 1 ))+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) asString)) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:09' prior: 34977431!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 )asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) asString)) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:10' prior: 34980209!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asSting) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) asString)) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:10' prior: 34983007!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) asString)) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:11' prior: 34985804!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !----SNAPSHOT----2016-06-23T17:11:22.165205+02:00 Pharo4.0.image priorSource: 1411665!----SNAPSHOT----2016-06-23T17:11:39.161205+02:00 Pharo4.0.image priorSource: 1436851!!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:12' prior: 34971165!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/4.self assert: (rep1 at: 9) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/8)+1.self assert: (rep2 at: 5) = (1/2)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:12' prior: 34991578!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/8)+1.self assert: (rep2 at: 5) = (1/2)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:13' prior: 34992363!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = (1/1)+2."rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/8)+1.self assert: (rep2 at: 5) = (1/2)+1.self assert: (rep2 at: 6) = (1/9)+1."! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:13' prior: 34848681!setUp|string |string := '{ 1 1 1 a a b c }' , Character cr asString, 'a . , 1 2 3'.testFeature := (SpecificTypeRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:18' prior: 34993148!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/8)+1.self assert: (rep2 at: 5) = (1/2)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:18' prior: 34994272!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = (1/1)+2.self assert: (rep1 at: 2) = (1/2)+1.self assert: (rep1 at: 3) = (1/2)+1.self assert: (rep1 at: 4) = (1/2)+1.self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = (1/1)+2.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/2)+1.self assert: (rep2 at: 5) = (1/8)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:19' prior: 34995057!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 3.self assert: (rep1 at: 2) = 3/2.self assert: (rep1 at: 3) = (3/2).self assert: (rep1 at: 4) = (3/2).self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = 3.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (1/6)+2.self assert: (rep2 at: 3) = (1/7)+2.self assert: (rep2 at: 4) = (1/2)+1.self assert: (rep2 at: 5) = (1/8)+1.self assert: (rep2 at: 6) = (1/9)+1.! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:20' prior: 34995842!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 3.self assert: (rep1 at: 2) = 3/2.self assert: (rep1 at: 3) = (3/2).self assert: (rep1 at: 4) = (3/2).self assert: (rep1 at: 5) = 1/3.self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = 1/4.self assert: (rep1 at: 8) = 1/5.self assert: (rep1 at: 9) = 3.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 1/3.self assert: (rep2 at: 2) = (13/6).self assert: (rep2 at: 3) = (15/7).self assert: (rep2 at: 4) = (3/2).self assert: (rep2 at: 5) = (9/8).self assert: (rep2 at: 6) = (10/9).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:21' prior: 34996607!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 3.self assert: (rep1 at: 2) = (3/2).self assert: (rep1 at: 3) = (3/2).self assert: (rep1 at: 4) = (3/2).self assert: (rep1 at: 5) = (1/3).self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = (1/4).self assert: (rep1 at: 8) = (1/5).self assert: (rep1 at: 9) = 3.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = (1/3).self assert: (rep2 at: 2) = (13/6).self assert: (rep2 at: 3) = (15/7).self assert: (rep2 at: 4) = (3/2).self assert: (rep2 at: 5) = (9/8).self assert: (rep2 at: 6) = (10/9).! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:22' prior: 34963645!testcreateTokanizedStatement|stmt1 stmt2|! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:23' prior: 34998129!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := testStmts at: 1! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:23' prior: 34998293!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:23' prior: 34998481!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.stmt2 := (testStmts at: 2) list.! !----SNAPSHOT----2016-06-23T17:24:42.666205+02:00 Pharo4.0.image priorSource: 1436938!!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:25' prior: 34998676!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.stmt2 := (testStmts at: 2) list.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:26' prior: 34998993!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 1) = '}'.stmt2 := (testStmts at: 2) list.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:26' prior: 34999261!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 7) = '}'.stmt2 := (testStmts at: 2) list.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:27' prior: 34999737!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 7) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '2'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:27' prior: 35000213!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 7) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = ''.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:27' prior: 35000893!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 7) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:29' prior: 34964634!setUp|aStream stmt|aStream := '{{{asd 11 1a  a1 a1a 1a1 ab c}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:30' prior: 35001572!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'ab'.self assert: (stmt1 at: 6) = 'c'.self assert: (stmt1 at: 7) = '}'.self assert: (stmt1 at: 8) = '}'.self assert: (stmt1 at: 9) = '}'.self assert: (stmt1 at: 10) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:30' prior: 35002567!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !AbstractRepresentator subclass: #DistanceBigRepresentator	instanceVariableNames: 'asString'	classVariableNames: ''	category: 'Structure-K-means'!AbstractRepresentator subclass: #DistanceBigRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:33'!asString'Distance Big Representator'! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:33'!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next *2).		 ].	list add: feature.	  ].^list! !!DistanceZeroRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:33'!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next *2).		 ].	list add: feature.	  ].^list! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:33'!initCentroids: k with: featureList|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next *2).		 ].	list add: feature.	  ].^list! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:34'!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"	! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:34' prior: 35005628!makeFeaturesFrom: aFeatureList "List containing Statement Elements, defined in StrucutureFinder"	! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:34' prior: 35005846!makeFeaturesFrom: aFeatureList "List containing Feature Elements, defined in StrucutureFinder"	! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:34' prior: 35006063!makeFeaturesFrom: aFeatureList "List containing Feature Elements, defined in Feature"	! !(Smalltalk globals at: #SpecificTypeRepresentator) rename: #TypeSpecificRepresentator!!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:35' prior: 34993935!setUp|string |string := '{ 1 1 1 a a b c }' , Character cr asString, 'a . , 1 2 3'.testFeature := (TypeSpecificRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:35' prior: 34962766!DoIt	| string testFeature typeInt typeWord typePunc intId puncId wordId |	typeInt := 1.	typeWord := 0.	typePunc := 2.	intId := #digit asParser plus.	wordId := (#letter asParser , #any asParser plus)		/ ((#digit asParser , #letter asParser plus) / #punctuation asParser plus).	puncId := #punctuation asParser plus , intId not , wordId not.	string := '{ 1 1 1 a a b c }' , Character cr asString , 'a . , 1 2 3'.	testFeature := TypeSpecificRepresentator new		makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).	testFeature.	^ wordId matches: '1a'! !(Smalltalk globals at: #StructureTypeRepresentator) rename: #TypeStructureRepresentator!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:35' prior: 34809085!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.	representator typeRep: TypeStructureRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:35' prior: 34810123!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeStructureRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:35' prior: 34960386!setUp|string |string := 'a ,, word, { 	df 45 d5 ,5' , Character cr asString, ' asdf.342.asfd4' , Character cr asString, '{ 1 1 1 a a b c }'.testFeature := (TypeStructureRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:37' prior: 35006278!makeFeaturesFrom: aFeatureList "List containing Feature Elements, defined in Feature"|currentMax|currentMax := 0.	maxValue := currentMax.! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:38' prior: 35010306!makeFeaturesFrom: aFeatureList "List containing Feature Elements, defined in Feature"|currentMax|currentMax := 0.aFeatureList do: [ : feature| 			 ].maxValue := currentMax.! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 17:38' prior: 35010566!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 18:13' prior: 35010865!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/23/2016 18:13' prior: 35011553!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.			(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].				n := currentPos - (typePosition at: (element asInteger)).				list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !----QUIT----2016-06-23T18:15:20.269205+02:00 Pharo4.0.image priorSource: 1444357!----STARTUP----2016-06-24T16:21:08.607649+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!TestCase subclass: #DistanceBigRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!TestCase subclass: #DistanceBigRepresentatorTest	instanceVariableNames: 'testFeatures'	classVariableNames: ''	category: 'StructureTests'!!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'Anonymous 6/24/2016 16:32'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !TestCase subclass: #DistanceBigRepresentatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:33'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:33' prior: 35014362!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:34' prior: 35013479!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:37' prior: 35015784!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:38' prior: 35015073!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 1.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 1.self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = 1.self assert: (rep1 at: 7) = 2.self assert: (rep1 at: 8) = 1.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:38' prior: 35016542!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 0.vector2 add: 2.vector2 add: 0.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:39' prior: 35017332!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 2.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:39' prior: 35018895!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 2.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 4.self assert: (rep2 at: 2) = 4.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 4.self assert: (rep2 at: 6) = 3.self assert: (rep2 at: 7) = 1.self assert: (rep2 at: 8) = 4.! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:43' prior: 35012290!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						typeValue at: element put: (currentPos - (typePosition at:element)).									n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:44' prior: 35020437!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						typeValue at: element asInteger put: (currentPos - (typePosition at:element)).									n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:44' prior: 35021251!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						typeValue at: element asInteger put: (currentPos - (typePosition at:element)).									n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:46' prior: 35022075!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[			typeValue at: element asInteger put: (currentPos - (typePosition at:element)).			].									n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:46' prior: 35022902!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element)).			].									n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:47' prior: 35023791!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			] ifTrue:[				(typeValue at:element asInteger )			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:49' prior: 35024681!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			] ifTrue:[				(typeValue at:element asInteger > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:50' prior: 35018105!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceBigRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 0.vector2 add: 2.vector2 add: 0.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 16:51' prior: 35025629!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				(typeValue at:element asInteger > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 17:00' prior: 35027525!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				((typeValue at:element asInteger) > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 17:01' prior: 35028633!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				((typeValue at:element asInteger) > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].			feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 17:02' prior: 35029743!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				((typeValue at:element asInteger) > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].						n := currentPos - (typePosition at: (element asInteger)).												(b < n) ifTrue: [ b := n ].			].			feature representation do:[:element|				list add: (typeValue at: element asInteger).				].			feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 17:04' prior: 35030857!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				((typeValue at:element asInteger) > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].																					].			feature representation do:[:element|  |n|				list add: (typeValue at: element asInteger).				n := typeValue at: element asInteger.				(b < n) ifTrue: [ b := n ].				].			feature representation: list.	].maxValue :=b.^aFeatureList ! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/24/2016 17:06' prior: 35032067!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element|				currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].						(typeValue includesKey: element asInteger) ifFalse:[				typeValue at: element asInteger put: (currentPos - (typePosition at:element asInteger)).			]; ifTrue:[				((typeValue at:element asInteger) > ( currentPos - (typeValue at: element asInteger))) ifTrue:[					typeValue at: element asInteger put: currentPos - (typeValue at: element asInteger).					].			].																					].			feature representation do:[:element|  |n|				list add: (typeValue at: element asInteger).				n := typeValue at: element asInteger.				(b < n) ifTrue: [ b := n ].				].			feature representation: list.	].maxValue :=b.^aFeatureList ! !----STARTUP----2016-06-24T17:07:47.699916+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:08' prior: 35012290!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !TestCase subclass: #DistanceBigRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:09'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector1 add: 2.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:09'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 6.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:42' prior: 35036187!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 1.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 1.self assert: (rep2 at: 3) = 0.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 0.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.self assert: (rep2 at: 8) = 1.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:42' prior: 35036898!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 1.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 4.self assert: (rep2 at: 2) = 4.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 4.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 4.self assert: (rep2 at: 8) = 0.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:43' prior: 35035445!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 0.vector2 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 3.vector2 add: 3.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:43' prior: 35038442!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceZeroRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:47' prior: 35039232!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceBigRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !----SNAPSHOT----2016-06-24T17:47:23.525916+02:00 Pharo4.0.image priorSource: 1458483!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:48' prior: 35034577!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: (element asInteger )) ifFalse: [				typePosition at: element asInteger put: currentPos].															n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:48' prior: 35040894!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse: [				typePosition at: elemntAsInt put: currentPos].															n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:50' prior: 35041700!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse: [				typePosition at: elemntAsInt put: currentPos].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[									].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:52' prior: 35042491!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse: [				typePosition at: elemntAsInt put: currentPos].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typeValue at: elemntAsInt))				].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:53' prior: 35043395!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse: [				typePosition at: elemntAsInt put: currentPos].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typeValue at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typeValue at: elemntAsInt) ].				].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:57' prior: 35044371!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typeValue at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typeValue at: elemntAsInt) ].				].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !----SNAPSHOT----2016-06-24T17:57:46.499916+02:00 Pharo4.0.image priorSource: 1486259!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:58' prior: 35045440!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typeValue at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:58' prior: 35046544!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].									n := currentPos - (typePosition at: (element asInteger)).			list add: n.									(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 17:59' prior: 35047564!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].											].		feature representation do:[:element| ||		].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:00' prior: 35048587!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue element at 		].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:00' prior: 35049542!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		].	feature representation: list.	].maxValue :=b.^aFeatureList! !----SNAPSHOT----2016-06-24T18:03:20.830916+02:00 Pharo4.0.image priorSource: 1491909!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:04' prior: 35050562!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.				(n > b) ifTrue: [  b := n].						].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:04' prior: 35051674!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.				(n > b) ifTrue: [ b := n ].						].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:04' prior: 35052738!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.				(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:04' prior: 35053802!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.								typePosition at: elemntAsInt put: currentPos.						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !----SNAPSHOT----2016-06-24T18:04:52.272916+02:00 Pharo4.0.image priorSource: 1497039!----SNAPSHOT----2016-06-24T18:05:37.555916+02:00 Pharo4.0.image priorSource: 1501414!!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:08' prior: 35054863!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition  includesKey: elemntAsInt) ifFalse:[			typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:08' prior: 35056136!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[			typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:08' prior: 35057291!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !----SNAPSHOT----2016-06-24T18:09:52.774916+02:00 Pharo4.0.image priorSource: 1501501!!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:10' prior: 35037670!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 1.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 1.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 1.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 3.self assert: (rep2 at: 2) = 3.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 3.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 3.self assert: (rep2 at: 8) = 0.! !(Smalltalk globals at: #DistanceBigRepresentator) rename: #DistanceAllSmallRepresentator!!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:10' prior: 35040022!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceAllSmallRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceAllBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:11'!asString	^'Distance All Big Representator'! !!DistanceAllSmallRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:12' prior: 35004411!asString'Distance All Small Representator'! !!DistanceAllBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:12'!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:15' prior: 35061697!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[											 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt + typeValue at:elemntAsInt).				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllBigRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:17' prior: 35062905!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[											 typeValue at: elemntAsInt put: (currentPos - (typePosition at: elemntAsInt) + (typeValue at:elemntAsInt)).				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:19' prior: 35060604!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceAllSmallRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !(Smalltalk globals at: #DistanceBigRepresentatorTest) rename: #DistanceAllSmallRepresentatorTest!!DistanceAllBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:20'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceAllSmallRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !!DistanceAllBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:21'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 5.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 5.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 5.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 4.self assert: (rep2 at: 2) = 4.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 4.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 4.self assert: (rep2 at: 8) = 0.! !!DistanceAllBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:21' prior: 35066865!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 5.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 5.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 5.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 6.self assert: (rep2 at: 2) = 6.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 6.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 6.self assert: (rep2 at: 8) = 0.! !!DistanceAllBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:22' prior: 35067640!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 4.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 4.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 4.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 6.self assert: (rep2 at: 2) = 6.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 6.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 6.self assert: (rep2 at: 8) = 0.! !!DistanceAllBigRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:23' prior: 35066084!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceAllBigRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !----SNAPSHOT----2016-06-24T18:23:24.883916+02:00 Pharo4.0.image priorSource: 1505102!!DistanceAllSmallRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'CedricWAlker 6/24/2016 18:24' prior: 35059741!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 8.self assert: (rep1 at: 2) = 0.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = 2.self assert: (rep1 at: 6) = 0.self assert: (rep1 at: 7) = 2.self assert: (rep1 at: 8) = 0.self assert: (rep1 at: 9) = 8.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 3.self assert: (rep2 at: 2) = 3.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 3.self assert: (rep2 at: 6) = 0.self assert: (rep2 at: 7) = 3.self assert: (rep2 at: 8) = 0.! !----QUIT----2016-06-24T18:24:30.170916+02:00 Pharo4.0.image priorSource: 1515430!----STARTUP----2016-06-27T13:20:04.600787+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:05' prior: 34414801!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:05' prior: 35071009!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.		structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !Smalltalk globals removeClassNamed: #Tokanizer!Object subclass: #Tokanizer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/27/2016 14:17'!tokanize: aStream! !!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/27/2016 14:17' prior: 35075184!tokanize: aStream|tokenIdentifier|tokenIdentifier := (#word asParser plus/ #punctuation asParser plus)flatten trim.! !!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/27/2016 14:18' prior: 35075305!tokanize: aStream|tokenIdentifier|tokenIdentifier := (#word asParser plus/ #punctuation asParser plus)flatten trim.tokenIdentifier   matchesSkipIn: aStream .! !!Tokanizer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/27/2016 14:18' prior: 35075527!tokanize: aStream|tokenIdentifier|tokenIdentifier := (#word asParser plus/ #punctuation asParser plus)flatten trim.^tokenIdentifier   matchesSkipIn: aStream .! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:18' prior: 35073019!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.		structureLevel := 1.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:19' prior: 35076046!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.		structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:19' prior: 35078034!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.		structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.		tokenList do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'CedricWalker 6/27/2016 14:20' prior: 35080031!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.		structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.		tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: token).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 6/27/2016 14:24' prior: 34433501!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList! !----STARTUP----2016-06-27T14:27:52.157005+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:28' prior: 34433501!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (tokenIdentifier matchesSkipIn: aStatement )) ].^statementList! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:29' prior: 35002252!setUp|aStream stmt|aStream := '{{asd 11 1a  a1 a1a 1a1 ab c}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:29' prior: 35085546!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:29' prior: 35003349!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{{{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.self assert: (stmt1 at: 11) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:29' prior: 35086174!testcreateTokanizedStatement|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.self assert: (stmt1 at: 11) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!TypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:31' prior: 34967374!testMakeFromFeature| rep1 rep2 rep3|rep3 := (testFeature at: 3) representation.self assert: (rep3 at: 1) = 2.self assert: (rep3 at: 2) = 1.self assert: (rep3 at: 3) = 1.self assert: (rep3 at: 4) = (1).self assert: (rep3 at: 5) = 0.self assert: (rep3 at: 6) = (0).self assert: (rep3 at: 7) = 0.self assert: (rep3 at: 8) = 0.self assert: (rep3 at: 9) = 2.rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 0.self assert: (rep1 at: 2) = 2.self assert: (rep1 at: 3) = 2.self assert: (rep1 at: 4) = 0.self assert: (rep1 at: 5) = (2).self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = (0).self assert: (rep1 at: 8) = 1.self assert: (rep1 at: 9) = 0.self assert: (rep1 at: 10) = 2.self assert: (rep1 at: 11) = 1.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = 0.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 1.self assert: (rep2 at: 4) = 2.self assert: (rep2 at: 5) = (0).! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:31' prior: 34414801!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !----SNAPSHOT----2016-06-27T14:31:51.107005+02:00 Pharo4.0.image priorSource: 1516294!!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:32' prior: 35088864!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize.	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:32' prior: 35090923!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray inputStream currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	inputStream := aStream.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!Tokanizer methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 14:32'!tokanize: aStream! !!Tokanizer methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 14:32' prior: 35094936!tokanize: aStream|tokenIdentifier|tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.! !!Tokanizer methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 14:33' prior: 35095047!tokanize: aStream|tokenIdentifier|tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.^tokenIdentifier matchesSkipIn: aStream.! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:33' prior: 35084848!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize:  aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:33' prior: 35095522!createTokanizedStatement: aStream	|statmentIdentifier tokenIdentifier allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.		tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:34' prior: 35096210!createTokanizedStatement: aStream	|statmentIdentifier  allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:35' prior: 35092933!buildTreeFrom: aStream	"comment stating purpose of message"	|structureArray  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureArray := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureArray returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:35' prior: 35097468!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:chr| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: chr.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: chr).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = chr) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: chr.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: chr.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:35' prior: 35099452!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	aStream do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: token).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !----SNAPSHOT----2016-06-27T14:35:38.432005+02:00 Pharo4.0.image priorSource: 1536313!!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:35' prior: 35101445!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: token).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:36' prior: 35103537!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 				]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:41' prior: 35105544!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: token).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 14:48' prior: 35106021!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: token).				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:54' prior: 34988602!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:54' prior: 35006577!setUp|string |string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := (TypeSpecificRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!SpecificTypeRepresentatorTest methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 14:55' prior: 34997365!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 3.self assert: (rep1 at: 2) = (3/2).self assert: (rep1 at: 3) = (3/2).self assert: (rep1 at: 4) = (3/2).self assert: (rep1 at: 5) = (1/3).self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = (1/4).self assert: (rep1 at: 8) = (1/5).self assert: (rep1 at: 9) = 3.self assert: (rep1 at: 10) = 3.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = (1/3).self assert: (rep2 at: 2) = (13/6).self assert: (rep2 at: 3) = (15/7).self assert: (rep2 at: 4) = (3/2).self assert: (rep2 at: 5) = (9/8).self assert: (rep2 at: 6) = (10/9).! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:00' prior: 35108028!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: (charElement isPaired) and: (currentNode structureChar = token) not.								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:00' prior: 35113983!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList|	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:02' prior: 35116010!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 1.	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:12' prior: 35118039!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 1.	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: aStream position + 1.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:13' prior: 35120107!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 1.	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:13' prior: 35122220!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[ (charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					tmpStructureNode position: aStream position + 1.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:15' prior: 35124328!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: token asCharacter.		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:18' prior: 35126464!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance structureArray.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:21' prior: 35128643!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].									].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:22' prior: 35130817!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level"].						charElement  := nil.				].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:23' prior: 35132976!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level but is in CharElements"].						charElement  := nil.				].					].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:23' prior: 35135156!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level but is in CharElements"].						charElement  := nil.				].					]; ifFalse:[			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:23' prior: 35137359!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Elementi s in CharElements"].						charElement  := nil.				].					]; ifFalse:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:23' prior: 35139578!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningChild: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifFalse:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:25' prior: 35141846!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifFalse:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:26' prior: 35144114!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 1.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:29' prior: 35146384!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: token.					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:32' prior: 35148652!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					tempOrderNode := TreeOrderElement new.					structureLevel  := structureLevel +1.					tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: (token at: 1).					positionCounter := positionCounter + 1.					tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 15:34' prior: 34379994!isOpeningElement: chr	^(chr = element1) and: isPaired.! !StructureChar removeSelector: #isClosing!StructureChar removeSelector: #isClosing:!!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 15:35'!isClosing: bolean! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 15:35' prior: 35153444!isClosing: boleanisClosing := bolean.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 15:36'!isClosing^isClosing! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 15:36' prior: 35153570!isClosing: bolean "gets set in StructureElements means its not only paired, but praenthesis."isClosing := bolean.! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:38' prior: 35150920!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.					tempOrderNode := TreeOrderElement new.															tempOrderNode structureLevel: structureLevel.					tempStructureNode := TreeStructureElement  new.					tempStructureNode structureChar: (token at: 1).										tempStructureNode position: positionCounter.					tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: token.					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:58' prior: 35154038!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.					tmpStructureNode parent: currentNode parent.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:59' prior: 35156332!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (currentNode parent) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 15:59' prior: 35158640!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									]; ifFalse:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:07' prior: 35153210!isOpeningElement: chr	^(chr = element1) and: isClosing .! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:07' prior: 35163267!isOpeningElement: chr	^(chr = element1) and: isClosing.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:10' prior: 35153701!isClosing||isClosing ifNil: [  isClosing := false].^isClosing! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:10' prior: 35163596!isClosingisClosing ifNil: [  isClosing := false].^isClosing! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:11' prior: 35163432!isOpeningElement: chr	^(chr = element1) and: self isClosing.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:11' prior: 35163938!isOpeningElement: chr	^(chr = element1) and: self isClosing.! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:25' prior: 35160949!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := (charElement isOpeningElement: (token at:1))not.				closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:27' prior: 35164262!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isPaired.												closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:27' prior: 35164107!isOpeningElement: chr	^(chr = element1) and: (self isClosing and: isPaired).! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:29' prior: 35166664!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isPaired.												closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:29' prior: 35169234!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.												closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:30'!isClosingElement:chrchr = element2 and: isClosing.! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:31' prior: 35171619!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and currentNode structureChar = token).												closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:31' prior: 35174155!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and currentNode structureChar = token).								closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:31' prior: 35176647!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[				(charElement isPaired ) ifTrue: [  					"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										];ifFalse: [  "add normal structure sign to current level, Element is in CharElements"].						charElement  := nil.				].					]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:33' prior: 35179134!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].			]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:34' prior: 35181622!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].				(closingChild or: isOpeningChild) not ifTrue: [ 					charElement := nil. 					].			]; ifNil:["add normal structure sign to current level"			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:34' prior: 35183953!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].				(closingChild or: isOpeningChild) not ifTrue: [ 					charElement := nil. 					].			]; ifNil:["add normal structure sign to current level"				currentNode addTokenChild: token.			].		]."need to be implemented: structureArray returnIfContains"! !AbstractTreeElement subclass: #TreeStructureElement	instanceVariableNames: 'children structureChar position tokens'	classVariableNames: ''	category: 'StructureTree'!!TreeStructureElement methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 16:36'!addTokenChild: tokentokens ifNil: [  tokens := OrderedCollection new].tokens add: token.! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:36' prior: 35186371!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].				(closingChild or: isOpeningChild) not ifTrue: [ 					charElement := nil. 					].			]; ifNil:["add normal structure sign to current level"				currentNode addTokenChild: token.			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:37' prior: 35174010!isClosingElement:chrchr = element2 and: self isClosing.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:42' prior: 35169063!isOpeningElement: chr	^(chr = element1) and: (self isClosing and: self isPaired).! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:43' prior: 35189177!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement: token.				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].				(closingChild or: isOpeningChild) not ifTrue: [ 					charElement := nil. 					].			]; ifNil:["add normal structure sign to current level"				currentNode addTokenChild: token.			].		]."need to be implemented: structureArray returnIfContains"! !!StructureTree methodsFor: 'build' stamp: 'cedricWalker 6/27/2016 16:43' prior: 35191987!buildTreeFrom: aStream	"comment stating purpose of message"	|structureElements  currentNode structureLevel tokenList positionCounter|	positionCounter := 0. "position of Token in List"	tokenList := Tokanizer new tokanize: aStream.	structureLevel := 0.	structureElements := StructureElements getUniqueInstance.	currentNode := rootNode.	tokenList do: [:token| 		| charElement | "check if pointer not overrides Everything"		charElement := structureElements returnIfContains: (token at:1).		charElement ifNotNil: [ 				|isOpeningChild closingChild|				"tabs, maybe add Stream Position"				isOpeningChild := (charElement isOpeningElement: (token at:1)). 				isOpeningChild := isOpeningChild or: ((charElement isPaired) and: (currentNode structureChar = token) not).								(isOpeningChild) ifTrue:[					|tempOrderNode tempStructureNode|					structureLevel  := structureLevel +1.					positionCounter := positionCounter + 1.										tempOrderNode := TreeOrderElement new.					tempStructureNode := TreeStructureElement  new.										tempOrderNode structureLevel: structureLevel.										tempStructureNode structureChar: (token at: 1).					tempStructureNode position: positionCounter.										tempOrderNode parent: currentNode.					currentNode addChild: tempOrderNode.					tempOrderNode leftChild: (tempStructureNode).					tempStructureNode parent: tempOrderNode.					currentNode := tempStructureNode.									].				closingChild := charElement isClosingElement: (token at: 1).				closingChild := closingChild or: (charElement isPaired and: currentNode structureChar = token).								closingChild ifTrue:[									"close level and walk up a level"					|tmpParentNode tmpStructureNode|					tmpParentNode := currentNode parent.								tmpStructureNode := TreeStructureElement new.					tmpStructureNode structureChar: (token at: 1).					positionCounter := positionCounter +1.					tmpStructureNode position: positionCounter.										tmpStructureNode parent: tmpParentNode.					tmpParentNode rightChild:  tmpStructureNode.					currentNode := (tmpParentNode) parent.										].				(closingChild or: isOpeningChild) not ifTrue: [ 					charElement := nil. 					].			]; ifNil:["add normal structure sign to current level"				currentNode addTokenChild: token.			].		]."need to be implemented: structureArray returnIfContains"! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/27/2016 16:43' prior: 35191647!isClosingElement:chr^chr = element2 and: self isClosing.! !!TreeStructureElement methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 16:50' prior: 34407020!structureChar: aStructureChar	"comment stating purpose of message"structureChar := aStructureChar.! !!TreeStructureElement methodsFor: 'accessing' stamp: 'cedricWalker 6/27/2016 16:50' prior: 34408770!structureChar	"comment stating purpose of message"^structureChar.! !----SNAPSHOT----2016-06-27T19:54:47.949005+02:00 Pharo4.0.image priorSource: 1548927!----QUIT----2016-06-27T20:22:44.607005+02:00 Pharo4.0.image priorSource: 1642940!----STARTUP----2016-06-28T08:18:40.701341+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:19' prior: 35008719!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeStructureRepresentator new.	representator distRep: DistanceZeroRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:20' prior: 34742607!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 50) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:20' prior: 35197755!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeStructureRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:21' prior: 35199995!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	representator distRep: DistanceZeroRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:21' prior: 35201183!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!DistanceAllSmallRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:23' prior: 35061548!asString^'Distance All Small Representator'! !----SNAPSHOT----2016-06-28T08:24:01.946341+02:00 Pharo4.0.image priorSource: 1643027!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:24' prior: 35202370!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	representator distRep: DistanceAllSmallRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:31' prior: 35198945!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].			"wrong!!"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:31' prior: 35203816!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	representator distRep: DistanceAllSmallRepresentator new.	"representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:36' prior: 35205009!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.							]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 08:40' prior: 35207266!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 09:19' prior: 34662048!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * maxValue/2).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 09:20' prior: 35209358!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * maxValue/6).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricWalker 6/28/2016 09:22' prior: 35209757!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * maxValue/10).		 ].	list add: feature.	  ].^list! !----QUIT----2016-06-28T09:30:29.943341+02:00 Pharo4.0.image priorSource: 1649193!----STARTUP----2016-06-28T10:10:40.446309+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-06-28T10:13:04.149309+02:00 Pharo4.0.image priorSource: 1656011!----SNAPSHOT----2016-06-28T10:40:30.555309+02:00 Pharo4.0.image priorSource: 1656202!----SNAPSHOT----2016-06-28T10:43:47.294309+02:00 Pharo4.0.image priorSource: 1656289!----SNAPSHOT----2016-06-28T11:15:53.151309+02:00 Pharo4.0.image priorSource: 1656376!----QUIT----2016-06-28T13:41:07.221309+02:00 Pharo4.0.image priorSource: 1656463!----STARTUP----2016-07-03T16:34:08.011317+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 16:40' prior: 35206060!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:03'!is: aStream thesameLanguageAs: anotherStream! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:04' prior: 35212465!is: aPath thesameLanguageAs: anotherPath! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:04' prior: 35212615!is: aPath thesameLanguageAs: anotherPath! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:06'!is: aPath thesameLanguageAs: anotherPath with: aType and: k |result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := anotherPath, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: anotherPath type: type.		representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:08' prior: 35212895!is: aPath thesameLanguageAs: anotherPath with: aType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: aType ! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:08'!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: aType ! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:08' prior: 35214040!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:08' prior: 35214350!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:09' prior: 35214665!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.bestResult at: 2. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:09' prior: 35214981!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [].. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:11' prior: 35215327!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [	(bestResult at: 1) do: [  ].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:12' prior: 35215684!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [ :ci|	(bestResult at: 1) do: [  :y|				].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:13' prior: 35216072!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [ :ci|	(bestResult at: 1) do: [  :y|				].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:13' prior: 35216474!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList|krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [ :ci|	|r bestR|	bestR := 0.	(bestResult at: 1) do: [  :y|				].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:14' prior: 35216887!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [ :ci|	|r bestR|	bestR := 0.	(bestResult at: 1) do: [  :y|				].	radiusList add: bestR.	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:14' prior: 35217324!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.(bestResult at: 2) do: [ :ci|	|r bestR|	bestR := 0.	(bestResult at: 1) do: [  :y|			r := Vector distanceFrom: ci to: y. 		].	radiusList add: bestR.	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:16' prior: 35217822!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		].	radiusList add: bestR.	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:17' prior: 35218357!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		].	radiusList add: bestR.	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:17' prior: 35218971!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	radiusList add: bestR.	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:18' prior: 35219593!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 	radiusList add: bestR.	].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:18' prior: 35220254!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count|radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 	radiusList add: bestR.	].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:18' prior: 35220944!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold |radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 	radiusList add: bestR.	].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:18' prior: 35221635!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 	radiusList add: bestR.	].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:19' prior: 35222337!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:19' prior: 35223057!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	]. "cetroids"! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:22' prior: 35223779!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:22' prior: 35224503!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:22' prior: 35225216!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.fHandler ! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:24' prior: 35225966!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.fHandler projectAsStream: aPath type: aType.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:24' prior: 35226726!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:24' prior: 35227521!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:25' prior: 35228335!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:30' prior: 35229150!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.		featureList do: [ :feature|																						 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:30' prior: 35230438!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].	(bestR = 0) ifFalse: [ 		radiusList add: bestR.		].	].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.		featureList do: [ :feature|																						 ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:31' prior: 35231793!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.		featureList do: [ :feature|																						 ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:33' prior: 35233154!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList count2|threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count2 := 0.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		count2 := count2 +1.		(bestResult at: 2) at: count2.																				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:34' prior: 35234490!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [  ].																								  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:34' prior: 35235902!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ 												 ].										  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:36' prior: 35237279!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc|			sc := Vector distanceFrom: feature representation  to:  ci.													  ].										  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:37' prior: 35238651!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  ].													  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:37' prior: 35240100!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  ].													  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:38' prior: 35241578!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  								].													  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:38' prior: 35243074!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  								].							  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:38' prior: 35244580!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  												].							  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:38' prior: 35246078!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  												].			  ].						  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:38' prior: 35247581!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [  												].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:39' prior: 35249079!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				(sc < rci) ifTrue: [										  ].				].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:41' prior: 35250572!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc  |						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				|bool|				bool := true.				(sc < rci) ifTrue: [					bool := false.										].				].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:42' prior: 35252100!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList all percetage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc  |						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				|bool|				bool := true.				(sc < rci) ifTrue: [					bool := false.					].				].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/3/2016 17:42' prior: 35253657!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList all percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc  |						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				|bool|				bool := true.				(sc < rci) ifTrue: [					bool := false.					].				].			  ].				  ].^true.! !----QUIT----2016-07-03T22:31:51.931317+02:00 Pharo4.0.image priorSource: 1656550!----STARTUP----2016-07-04T15:15:16.28887+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:17' prior: 35255222!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc |						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				|bool|				bool := true.				(sc < rci) ifTrue: [					bool := false.					].				].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:18' prior: 35256979!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc bool|			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].				  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:19' prior: 35258540!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc |			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].			  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:20' prior: 35260098!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |percentage := 0.threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc |			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].			bool ifTrue: [ percentage := percentage +1. 				].		  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:22' prior: 35261657!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |percentage := 0.threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc |			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].			bool ifTrue: [ percentage := percentage +1. 				].		  ].^ percentage / featureList size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:22' prior: 35263287!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |percentage := 0.threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc |			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].			bool ifTrue: [ percentage := percentage +1. 				].		  ].^ (percentage / featureList size) < threshold.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 15:24' prior: 35264943!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList percentage |percentage := 0.threshold := 0.8.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc |			bool := true.						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|								(sc < rci) ifTrue: [					bool := false.					].				].			  ].			bool ifTrue: [ percentage := percentage +1. 				].		  ].^ ((percentage / featureList size) < threshold).! !----STARTUP----2016-07-04T18:57:09.265697+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:07' prior: 35255222!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|				(bestResult at: 2) do: [ :ci|			|sc  |						sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|				|bool|				bool := true.				(sc < rci) ifTrue: [					bool := false.					].				].			  ].				  ].^true.! !----STARTUP----2016-07-04T19:17:04.811388+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:21' prior: 35255222!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 1.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:21' prior: 35270081!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 1.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:22' prior: 35271691!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 1.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^true.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:22' prior: 35273318!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 1.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^percentage / featureList size < threshold.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:23' prior: 35274960!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^percentage / featureList size < threshold.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:23' prior: 35276639!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^(percentage / featureList size) < threshold.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:25' prior: 35278320!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^(percentage / featureList size)" < threshold".! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/4/2016 19:36' prior: 35280003!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := true.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := false.					].				].			  ].		bool ifFalse: [ percentage := percentage +1 ].			  ].^(percentage / featureList size)" < threshold".! !----QUIT----2016-07-04T23:02:27.156388+02:00 Pharo4.0.image priorSource: 1702253!----STARTUP----2016-07-05T08:58:32.566097+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 09:00' prior: 35281688!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifFalse: [ percentage := percentage +1 ].			  ].^(percentage / featureList size)" < threshold".! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 09:00' prior: 35283565!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^(percentage / featureList size)" < threshold".! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 09:01' prior: 35208308!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 9) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 09:07' prior: 35286936!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 25) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----QUIT----2016-07-05T10:12:05.840097+02:00 Pharo4.0.image priorSource: 1728839!----STARTUP----2016-07-05T15:56:25.388438+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 15:56' prior: 35287974!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector distanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 15:59'!is: bestResult in: radiusList|count|(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 15:59' prior: 35290229!is: bestResult in: radiusList|count|count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:02' prior: 35290661!is: featureList in: radiusList! !KMeansRunner removeSelector: #is:in:!KMeansRunner removeSelector: #is:thesameLanguageAs:!KMeansRunner removeSelector: #is:thesameLanguageAs:with:and:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:03' prior: 35285251!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  1 to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:03' prior: 35291397!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor  to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:19' prior: 35293084!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ]."^1-(percentage / featureList size) < threshold".^featureList = bestResult at:2.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:20' prior: 35294782!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.representator := RepresentatorRunner new.	representator typeRep: TypeSpecificRepresentator new.	"representator distRep: DistanceAllSmallRepresentator new.	representator weightRep: WeightInverseRepresentator new."		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ]."^1-(percentage / featureList size) < threshold".^featureList = (bestResult at:2).! !Object subclass: #LanguageDifferentiator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:27'!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := krunner representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ]."^1-(percentage / featureList size) < threshold".^featureList = (bestResult at:2).! !KMeansRunner removeSelector: #is:with:thesameLanguageAs:with:and:!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:30'!calcRadiusListfrom: aResult! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:31' prior: 35299945!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:31' prior: 35300088!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r bestR|	count := count + 1.		bestR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > bestR ) ifTrue: [ bestR := r ].		].			radiusList add: bestR.			].^radiusList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:32' prior: 35298361!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.radiusList := self calcRadiusListfrom: bestResult.fHandler := FileHandler new.aStream := fHandler projectAsStream: aPath type: aType.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := krunner representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ]."^1-(percentage / featureList size) < threshold".^featureList = (bestResult at:2).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:32' prior: 35301107!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.radiusList := self calcRadiusListfrom: bestResult. fHandler := FileHandler new. aStream := fHandler projectAsStream: aPath type: aType.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := krunner representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ]."^1-(percentage / featureList size) < threshold".^featureList = (bestResult at:2).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:32' prior: 35302402!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream statementmaker featureList statementList  percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.radiusList := self calcRadiusListfrom: bestResult. fHandler := FileHandler new. aStream := fHandler projectAsStream: aPath type: aType.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := krunner representator makeFeaturesFrom: statementList.			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:35' prior: 35300591!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:37' prior: 35304963!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:37' prior: 35305474!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:37' prior: 35305985!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !TestCase subclass: #LanguageDifferentiatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:38'!testCalcRadiusListFrom! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:38'!setUp! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:42' prior: 35307259!setUp|list1 list2 c f1 f2  |list1 := OrderedCollection new.list2 = OrderedCollection new.c := OrderedCollection new.f1 := Feature new.f2 := Feature new.testFeature add: list1.testFeature add: list2.list2 add: c.list1 add: f1.list1 add: f2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:42' prior: 35307384!setUp|list1 list2 c f1 f2 rep1 rep2 |list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.c := OrderedCollection new.f1 := Feature new.f2 := Feature new.testFeature add: list1.testFeature add: list2.list2 add: c.list1 add: f1.list1 add: f2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:44' prior: 35307757!setUp|list1 list2 c f1 f2 rep1 rep2 |list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.c := OrderedCollection new.f1 := Feature new.f2 := Feature new.c add: 0.5.c add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.testFeature add: list1.testFeature add: list2.list2 add: c.list1 add: f1.list1 add: f2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:44' prior: 35307133!testCalcRadiusListFromLanguageDifferentiator new calcRadiusListfrom: testFeature.! !----SNAPSHOT----2016-07-05T16:44:59.685438+02:00 Pharo4.0.image priorSource: 1734478!!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:55' prior: 35308202!setUp|list1 list2 c f1 f2 rep1 rep2  |testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.c := OrderedCollection new.f1 := Feature new.f2 := Feature new.c add: 0.5.c add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.f1 representation: rep1.f2 representation: rep2.f1 klabel: 1.f2 klabel: 1.list1 add: f1.list1 add:f2.list2 add: c.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:57' prior: 35308729!testCalcRadiusListFrom|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: (list at: 1 = (0.5 squared + 0.5 squared)sqrt )! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 16:57' prior: 35309661!testCalcRadiusListFrom|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt )! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:02' prior: 35309019!setUp|list1 list2 c f1 f2 rep1 rep2  c2 rep3 rep4 f3 f4|testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.f1 representation: rep1.f2 representation: rep2.f1 klabel: 1.f2 klabel: 1.list1 add: f1.list1 add:f2.list2 add: c.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:03' prior: 35310221!setUp|list1 list2 c f1 f2 rep1 rep2  c2 rep3 rep4 f3 f4|testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.f1 representation: rep1.f2 representation: rep2.f1 klabel: 1.f2 klabel: 1.list1 add: f1.list1 add:f2.list2 add: c.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:03' prior: 35311010!setUp|list1 list2 c f1 f2 rep1 rep2  c2 rep3 rep4 f3 f4|testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f1 klabel: 1.f2 klabel: 1.list1 add: f1.list1 add:f2.list2 add: c.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:04' prior: 35311826!setUp|list1 list2 c f1 f2 rep1 rep2  c2 rep3 rep4 f3 f4|testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:05' prior: 35312700!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4|testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:06' prior: 35309940!testCalcRadiusListFrom|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !----SNAPSHOT----2016-07-05T17:06:54.401438+02:00 Pharo4.0.image priorSource: 1754383!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:08' prior: 35303699!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList count threshold fHandler aStream  featureList   percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.count := 0.radiusList := self calcRadiusListfrom: bestResult. fHandler := FileHandler new. aStream := fHandler projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:08' prior: 35315202!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold fHandler aStream  featureList   percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult. fHandler := FileHandler new. aStream := fHandler projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:09' prior: 35316335!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.radiusList := OrderedCollection new.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:09' prior: 35317451!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:20' prior: 35318537!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:22' prior: 35319585!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:23' prior: 35320632!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:23' prior: 35321696!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		anotherRadiusList := self calcRadiusListfrom: 	featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:25' prior: 35322776!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.	featureList do: [ :feature|		|bool|		(bestResult at: 2) do: [ :ci|			|sc  |			bool := false.			sc := Vector distanceFrom: feature representation  to:  ci.						radiusList do: [ :rci|												(sc < rci) ifTrue: [					bool := true.					].				].			  ].		bool ifTrue: [ percentage := percentage +1 ].			  ].^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:25' prior: 35323902!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:28' prior: 35325162!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :x|		radiusList do: [ :y| ]		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:28' prior: 35326102!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :y|		radiusList do: [ :x| ]		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:28' prior: 35327100!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :y |		radiusList do: [ :x| ]		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:28' prior: 35328098!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :y |		radiusList do: [ :x| 			].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:30' prior: 35329097!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :y |		self is: y in: radiusList.								].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:30'!is: aRadius in:aRadiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:32' prior: 35331096!is: aRadius in:aRadiusListaRadiusList do: [ :r|	(aRadius < r) ifTrue:[				].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:32' prior: 35331238!is: aRadius in:aRadiusListaRadiusList do: [ :r|	(aRadius < r) ifTrue:[		^true		].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:32' prior: 35331439!is: aRadius in:aRadiusListaRadiusList do: [ :r|	(aRadius < r) ifTrue:[		^true		].	 ].^false! !----SNAPSHOT----2016-07-05T17:33:07.398438+02:00 Pharo4.0.image priorSource: 1760570!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:33' prior: 35330101!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage anotherRadiusList featureAsResult|threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).	featureAsResult := OrderedCollection new.	featureAsResult add: featureList.	featureAsResult add: (bestResult at: 2).	anotherRadiusList := self calcRadiusListfrom: featureAsResult.		anotherRadiusList do:[ :y |		(self is: y in: radiusList) ifTrue: [ percentage + 1].								].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:34' prior: 35331945!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).			featureList do:[ :y |		(self is: y in: radiusList) ifTrue: [ percentage + 1].								].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:35' prior: 35332984!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[		featureList do:[ :y |			(self is: y in: radiusList) ifTrue: [ percentage + 1].									].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:35' prior: 35333802!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			(self is: (Vector distanceFrom: ci to: y) in: radiusList) ifTrue: [ percentage + 1].									].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:36' prior: 35334651!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |						(self is: (Vector distanceFrom: ci to: y) in: radiusList) ifTrue: [ percentage + 1].									].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:36' prior: 35335535!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y) in: radiusList) ifTrue: [ percentage + 1].									].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:37' prior: 35336436!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"									].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:37' prior: 35337351!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:37'!testIsIn! !TestCase subclass: #LanguageDifferentiatorTest	instanceVariableNames: 'testFeature isinFeature'	classVariableNames: ''	category: 'StructureTests'!!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:38' prior: 35313683!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4|isinFeature := OrderedCollection.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:39' prior: 35339514!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection.isinFeature add: 3.isinFeature add: 4.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:39' prior: 35340601!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:39' prior: 35341729!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:40' prior: 35339247!testIsIn|lang|lang := LanguageDifferentiator new.self assertFalse: (lang is: 8 in: isinFeature).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:41' prior: 35344036!testIsIn|lang|lang := LanguageDifferentiator new.self assertFalse: (lang is: 8 in: isinFeature).self assert: (lang is: 7 in: isinFeature).self assert: (lang is: 3.5 in: isinFeature).self assert: (lang is: 1 in: isinFeature).! !!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:41' prior: 35342877!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection new.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/5/2016 17:41' prior: 35344599!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection new.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.5.c add: 0.5.c2 add: 0.5.c2 add: 0.5.c3 add: 0.5.c3 add: 0.5.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:42' prior: 35344261!testIsIn|lang|lang := LanguageDifferentiator new.self assert: (lang is: 8 in: isinFeature) not.self assert: (lang is: 7 in: isinFeature).self assert: (lang is: 3.5 in: isinFeature).self assert: (lang is: 1 in: isinFeature).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:42' prior: 35331645!is: aRadius in:aRadiusListaRadiusList do: [ :r|	(aRadius <= r) ifTrue:[		^true		].	 ].^false! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:45'!representator^representator ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 17:46' prior: 35338306!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^1-(percentage / featureList size)" < threshold".! !----SNAPSHOT----2016-07-05T17:48:06.413438+02:00 Pharo4.0.image priorSource: 1777313!----SNAPSHOT----2016-07-05T17:50:12.366438+02:00 Pharo4.0.image priorSource: 1794003!----SNAPSHOT----2016-07-05T19:47:41.046438+02:00 Pharo4.0.image priorSource: 1794090!----QUIT----2016-07-05T19:55:49.482438+02:00 Pharo4.0.image priorSource: 1794177!----STARTUP----2016-07-05T20:11:32.394144+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:12' prior: 35347585!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^1-(percentage / all)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:14' prior: 35349001!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^(1-(percentage / all))" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:16' prior: 35349951!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |						(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^(1-(percentage / featureList size))" < threshold".! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:16' prior: 35346907!testIsIn|lang|lang := LanguageDifferentiator new.self assert: (lang is: 8 in: isinFeature).self assert: (lang is: 8 in: isinFeature) not.self assert: (lang is: 7 in: isinFeature).self assert: (lang is: 3.5 in: isinFeature).self assert: (lang is: 1 in: isinFeature).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:16' prior: 35351864!testIsIn|lang|lang := LanguageDifferentiator new.self assert: (lang is: 8 in: isinFeature) not.self assert: (lang is: 7 in: isinFeature).self assert: (lang is: 3.5 in: isinFeature).self assert: (lang is: 1 in: isinFeature).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:17' prior: 35350903!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^(1-(percentage / featureList size))" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:28'!calcMaxRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:28'!calcMinRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector distanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:28' prior: 35352607!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcMaxRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^(1-(percentage / featureList size))" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:29' prior: 35354036!calcMinRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|				r := Vector distanceFrom: ci to: y representation. 		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:29' prior: 35355500!calcMinRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 9999999999.	(bestResult at: 1) do: [  :y|				r := Vector distanceFrom: ci to: y representation. 		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:30' prior: 35355967!calcMinRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r minR|	count := count + 1.		minR := 9999999999.	(bestResult at: 1) do: [  :y|				r := Vector distanceFrom: ci to: y representation. 		(r > minR ) ifTrue: [ minR := r ].		].			radiusList add: minR.			].^radiusList! !!LanguageDifferentiatorTest methodsFor: 'tests' stamp: 'cedricwalker 7/5/2016 20:30'!testCalcMaxRadiusListFrom|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !LanguageDifferentiatorTest removeSelector: #testCalcRadiusListFrom!LanguageDifferentiator removeSelector: #calcRadiusListfrom:!!LanguageDifferentiatorTest methodsFor: 'tests' stamp: 'cedricwalker 7/5/2016 20:30' prior: 35356893!testCalcMaxRadiusListFrom|list|list := LanguageDifferentiator new calcMaxRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiatorTest methodsFor: 'tests' stamp: 'cedricwalker 7/5/2016 20:30' prior: 35357393!testCalcMaxRadiusListFrom|list|list := LanguageDifferentiator new calcMaxRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:30'!testCalcMinRadiusListFrom|list|list := LanguageDifferentiator new calcMaxRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:33' prior: 35356443!calcMinRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 1) do: [ :y|	|r minR|	count := count + 1.		minR := 9999999999.	(bestResult at: 2) do: [  :ci|				r := Vector distanceFrom: ci to: y representation. 		(r > minR ) ifTrue: [ minR := r ].		].			radiusList add: minR.			].^radiusList! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:34' prior: 35358141!testCalcMinRadiusListFrom|list|list := LanguageDifferentiator new calcMinRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:34' prior: 35359003!testCalcMinRadiusListFrom|list|list := LanguageDifferentiator new calcMinRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.25 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:34' prior: 35359389!testCalcMinRadiusListFrom|list|list := LanguageDifferentiator new calcMinRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !----STARTUP----2016-07-05T20:37:41.909551+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:41' prior: 35347585!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.	(bestResult at: 2) do:[ :ci|		featureList do:[ :y |			all := all +1.			(self is: (Vector distanceFrom: ci to: y representation ) in: radiusList) ifFalse: [ percentage + 1]." number of features not in a Centroid"			].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:41'!calcMin: Cs To: featureList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:41' prior: 35361297!calcMin: Cs To: featureList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:43' prior: 35361441!calcMin: Cs To: featureList|result min|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.		].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:44' prior: 35361585!calcMin: Cs To: featureList|result min r|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			 		].		].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:45' prior: 35361832!calcMin: Cs To: featureList|result min r|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].		].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:45' prior: 35362165!calcMin: Cs To: featureList|result min r|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].	].! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:45'!testCalcMinTo! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:46' prior: 35362879!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:47' prior: 35362526!calcMin: Cs To: featureList|result min r|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].	result add: min.	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:48' prior: 35363378!calcMin: Cs To: featureList|result min r|result := OrderedCollection new.featureList do: [:feature| 	min := 9999999999999.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].	result add: min.	].^result.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:50' prior: 35345744!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection new.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.25.c add: 0.25.c2 add: 0.5.c2 add: 0.5.c3 add: 0.75.c3 add: 0.75.rep1 add: 0.75.rep1 add: 0.75.rep2 add: 1.rep2 add: 1.rep3 add: 0.75.rep3 add: 0.75.rep4 add: 1.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:51' prior: 35364145!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection new.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.25.c add: 0.25.c2 add: 0.5.c2 add: 0.5.c3 add: 0.75.c3 add: 0.75.rep1 add: 0.0.rep1 add: 0.75.rep2 add: 0.rep2 add: 1.rep3 add: 0.0.rep3 add: 0.25.rep4 add: 0.rep4 add: 0.5.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 20:52' prior: 35365306!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |isinFeature := OrderedCollection new.isinFeature add: 3.isinFeature add: 4.isinFeature add: 7.testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.25.c add: 0.25.c2 add: 0.5.c2 add: 0.5.c3 add: 0.75.c3 add: 0.75.rep1 add: 0.0.rep1 add: 0.25.rep2 add: 0.rep2 add: 0.5.rep3 add: 0.0.rep3 add: 0.75.rep4 add: 0.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:04' prior: 35363012!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.25 squared)sqrt ).self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.25 squared + 1 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:04' prior: 35367628!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.25 squared)sqrt ).self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:05' prior: 35368096!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared)sqrt ).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:05' prior: 35368565!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared)sqrt ).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 1) = (0.25 squared + 0.5 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:06' prior: 35369020!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared)sqrt ).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 3) = (0.25 squared + 0.5 squared)sqrt ).self assert: ((list at: 4) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:06' prior: 35369474!testCalcMinTo|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25)).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 3) = (0.25 squared + 0.5 squared)sqrt ).self assert: ((list at: 4) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:07' prior: 35369934!testCalcMinTo|list|list := LanguageDifferentiator new calcMin: (testFeature at: 2) To: (testFeature at: 1).self assert: ((list at: 1) = (0.25)).self assert: ((list at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 3) = (0.25 squared + 0.5 squared)sqrt ).self assert: ((list at: 4) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:07' prior: 35314739!testCalcRadiusListFrom|list|list := LanguageDifferentiator new calcRadiusListfrom: testFeature.self assert: ((list at: 1) = (0.25 squared + 0.25 squared)sqrt ).self assert: ((list at: 2) = (0.5 squared + 0.5 squared)sqrt ).self assert: ((list at: 3) = 0 ).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:08' prior: 35360269!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:09' prior: 35371215!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1. ]				].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:09' prior: 35372034!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].				].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:09' prior: 35372956!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].		].	^1-(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:16' prior: 35373878!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].		].	^(percentage / featureList size)" < threshold".! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:17' prior: 35374797!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].		].	^1/(percentage / featureList size)" < threshold". "percentage should be high for "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:17' prior: 35375714!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].		].	^1-(percentage / featureList size)" < threshold". "percentage should be high for "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/5/2016 21:17' prior: 35376666!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		minCToFeature := self calcMin: (bestResult at: 2)To: featureList.		minCToFeature do:[ :d|		(self is: d in: radiusList) ifTrue: [ percentage := percentage +1 ].		].	^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !----QUIT----2016-07-05T21:17:27.156551+02:00 Pharo4.0.image priorSource: 1794264!----STARTUP----2016-07-06T19:42:43.365122+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:44' prior: 35363755!calcMin: Cs To: featureList|result min r|result := Dictionary new.featureList do: [:feature|	|count| 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].	result at: min put: count.	].^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:47' prior: 35378807!calcMin: Cs To: featureList|result numberc min r|result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r ].		].	result at: min put: count.	].^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:47' prior: 35379217!calcMin: Cs To: featureList|result numberc min r|result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r.				cCount := c.				].		].	result at: min put: count.	].^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:48' prior: 35379697!calcMin: Cs To: featureList|result numberc min r|result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ min := r.				cCount := c.				].		].	result add: min.	cCount add: cCount.	].^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:49' prior: 35380199!calcMin: Cs To: featureList|result numberc min r radius|radius := OrderedCollection new.result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ 				min := r.				cCount := c.				].		].	result add: min.	numberc add: cCount.	].result add: radius.result add: numberc.^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:51' prior: 35380712!calcMin: Cs To: featureList|result numberc min r radius|radius := OrderedCollection new.result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ 				min := r.				cCount := c.				].		].	radius add: min.	numberc add: cCount.	].result add: radius.result add: numberc.^result.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:51' prior: 35381312!calcMin: Cs To: featureList|result numberc min r radius|radius := OrderedCollection new.result := OrderedCollection new.numberc := OrderedCollection new.featureList do: [:feature|	|count cCount|	cCount := 0. 	min := 9999999999999.	count :=0.	Cs do: [ :c|			r := Vector distanceFrom:  c to: feature representation.			(r<min) ifTrue: [ 				min := r.				count := count +1.				cCount  := count.				].		].	radius add: min.	numberc add: cCount.	].result add: radius.result add: numberc.^result.! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:52' prior: 35370375!testCalcMinTo|list|list := LanguageDifferentiator new calcMin: (testFeature at: 2) To: (testFeature at: 1).self assert: (((list at:1) at: 1)  = (0.25)).self assert: (((list at:1) at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: (((list at:1) at: 3) = (0.25 squared + 0.5 squared)sqrt ).self assert: (((list at:1) at: 4) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiatorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 19:52' prior: 35382544!testCalcMinTo|list|list := LanguageDifferentiator new calcMin: (testFeature at: 2) To: (testFeature at: 1).self assert: (((list at:1) at: 1)  = (0.25)).self assert: (((list at:1) at: 2) = (0.25 squared + 0.25 squared)sqrt ).self assert: (((list at:1) at: 3) = (0.25 squared + 0.5 squared)sqrt ).self assert: (((list at:1) at: 4) = (0.5 squared + 0.5 squared)sqrt ).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:03' prior: 35377618!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all minCToFeature|all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ 						 ].	^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:04' prior: 35383523!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage all |all := 0.threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |				 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:04' prior: 35384383!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |				 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:06' prior: 35385235!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |				(bestResult at: 2) do: [ :ci|			|d| 			d := Vector distanceFrom: feature representation to: ci.			 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:06' prior: 35386075!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d| 			d := Vector distanceFrom: feature representation to: ci.						 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:06' prior: 35387025!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d| 			ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:07' prior: 35388010!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d| 			ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.												 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !----SNAPSHOT----2016-07-06T20:07:58.941122+02:00 Pharo4.0.image priorSource: 1824070!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:10' prior: 35389027!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d| 			ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) < d)						 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:11' prior: 35390139!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d isInC| 			isInC := false.			ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) < d)						 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:12' prior: 35391197!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition|		ciPosition := 0.		(bestResult at: 2) do: [ :ci|			|d isInC| 			isInC := false.			ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) > d) ifTrue: [  isInC := true].						 			]		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:13' prior: 35392280!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition isInC|		ciPosition := 0.		isInC := false.		(bestResult at: 2) do: [ :ci|			|d | 						ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) > d) ifTrue: [  isInC := true].						 			].			isInC ifTrue:  [  ].		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:13' prior: 35393390!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition isInC|		ciPosition := 0.		isInC := false.		(bestResult at: 2) do: [ :ci|			|d | 						ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) > d) ifTrue: [  isInC := true].			 			].			isInC ifTrue:  [  percentage + 1].		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:13' prior: 35394529!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		|ciPosition isInC|		ciPosition := 0.		isInC := false.		(bestResult at: 2) do: [ :ci|			|d | 						ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) > d) ifTrue: [  isInC := true].			 			].			isInC ifTrue:  [  percentage := percentage + 1].		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !----SNAPSHOT----2016-07-06T20:29:24.917122+02:00 Pharo4.0.image priorSource: 1835507!----SNAPSHOT----2016-07-06T20:33:24.976122+02:00 Pharo4.0.image priorSource: 1842296!LanguageDifferentiator removeSelector: #calcMin:To:!LanguageDifferentiatorTest removeSelector: #testCalcMinTo!!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:35'!testCalcRadiusListfrom! !LanguageDifferentiatorTest removeSelector: #testCalcRadiusListfrom!LanguageDifferentiatorTest removeSelector: #testIsIn!LanguageDifferentiator removeSelector: #is:in:!----SNAPSHOT----2016-07-06T20:37:42.147122+02:00 Pharo4.0.image priorSource: 1842383!----STARTUP----2016-07-06T20:42:33.115167+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiatorTest methodsFor: 'running' stamp: 'cedricwalker 7/6/2016 20:43' prior: 35366467!setUp|list1 list2 c f1 f2 rep1 rep2  c2 c3 rep3 rep4 f3 f4 |testFeature := OrderedCollection new.list1 := OrderedCollection new.list2 := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.c := OrderedCollection new.c2 := OrderedCollection new.c3 := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.c add: 0.25.c add: 0.25.c2 add: 0.5.c2 add: 0.5.c3 add: 0.75.c3 add: 0.75.rep1 add: 0.0.rep1 add: 0.25.rep2 add: 0.rep2 add: 0.5.rep3 add: 0.0.rep3 add: 0.75.rep4 add: 0.rep4 add: 1.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.f1 klabel: 1.f2 klabel: 1.f4 klabel: 2.list1 add: f1.list1 add:f2.list1 add:f3.list1 add:f4.list2 add: c.list2 add: c2.list2 add: c3.testFeature add: list1.testFeature add: list2.! !TestCase subclass: #LanguageDifferentiatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!----SNAPSHOT----2016-07-06T20:45:44.823167+02:00 Pharo4.0.image priorSource: 1842889!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:50' prior: 35395678!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |				|ciPosition isInC|				ciPosition := 0.		isInC := false.		(bestResult at: 2) do: [ :ci|			|d | 						ciPosition := ciPosition +1.			d := Vector distanceFrom: feature representation to: ci.						((radiusList at: ciPosition) > d) ifTrue: [  isInC := true].			 			].			isInC := self is: feature to: (bestResult at:2) in: radiusList.			isInC ifTrue:  [  percentage := percentage + 1].		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:51' prior: 35398906!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |	|isInC|			isInC := self is: feature to: (bestResult at:2) in: radiusList.			isInC ifTrue:  [  percentage := percentage + 1].		 ].^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:52'!is: feature to: centroids in: radiusList		|ciPosition |				ciPosition := 0.			centroids do: [ :ci|		|d | 					ciPosition := ciPosition +1.		d := Vector distanceFrom: feature representation to: ci.					((radiusList at: ciPosition) > d) ifTrue: [ ^true].			 		].^false.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:53' prior: 35400142!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |threshold := 0.9.percentage := 0.krunner := KMeansRunner new.bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.radiusList := self calcRadiusListfrom: bestResult.  aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:53' prior: 35401091!is: feature to: centroids in: radiusList	|ciPosition |			ciPosition := 0.			centroids do: [ :ci|		|d | 					ciPosition := ciPosition +1.		d := Vector distanceFrom: feature representation to: ci.					((radiusList at: ciPosition) > d) ifTrue: [ ^true].			 		].^false.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/6/2016 20:54' prior: 35401488!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult krunner radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	krunner := KMeansRunner new.	bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !----SNAPSHOT----2016-07-06T20:54:14.195167+02:00 Pharo4.0.image priorSource: 1844274!----QUIT----2016-07-06T20:56:18.379167+02:00 Pharo4.0.image priorSource: 1849236!----STARTUP----2016-07-06T21:08:28.944132+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-07-06T21:09:25.843132+02:00 Pharo4.0.image priorSource: 1849323!----QUIT----2016-07-06T21:09:28.932132+02:00 Pharo4.0.image priorSource: 1849515!----STARTUP----2016-07-07T18:04:31.206593+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:06'!testIsToIn! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:11' prior: 35404333!testIsToIn|cs features|cs := testFeature at: 2.features := testFeature at:1.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:13' prior: 35404469!testIsToIn|cs features radiusList lang|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) in: radiusList).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:16' prior: 35404674!testIsToIn|cs features radiusList lang|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) in: radiusList).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:16' prior: 35405075!testIsToIn|cs features radiusList lang|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:17' prior: 35402434!is: feature to: centroids in: radiusList	|ciPosition |			ciPosition := 0.			centroids do: [ :ci|		|d | 					ciPosition := ciPosition +1.		d := Vector distanceFrom: feature representation to: ci.					((radiusList at: ciPosition) >= d) ifTrue: [ ^true].			 		].^false.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:17' prior: 35405542!testIsToIn|cs features radiusList lang|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:19' prior: 35406411!testIsToIn|cs features radiusList lang|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:21' prior: 35406980!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:23' prior: 35407638!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.radiusList at: 2 put: 0.25.radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:24' prior: 35408400!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.radiusList at: 2 put: 0.25.radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 2 put: 0.1.radiusList at: 1 put: 0.25.self assert: ( lang is: f to:cs in: radiusList) not.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:24' prior: 35409266!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.radiusList at: 2 put: 0.25.radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 2 put: 0.1.radiusList at: 1 put: 0.25.self assert: ( lang is: f to:cs in: radiusList).! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:24' prior: 35410241!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.radiusList at: 2 put: 0.25.radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 2 put: 0.1.radiusList at: 1 put: 0.25.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 1 put: 0.1.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:24' prior: 35411212!testIsToIn|cs features radiusList lang f rep|lang := LanguageDifferentiator new.radiusList := OrderedCollection new. " achtung grösse muss gleich grösse cs sein"radiusList add: 0.25.radiusList add: 0.25.radiusList add: 0.25.cs := testFeature at: 2.features := testFeature at:1.self assert: ( lang is: (features at: 1) to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: (features at: 1) to:cs in: radiusList) not.radiusList at: 1 put: 3.self assert: ( lang is: (features at: 1) to:cs in: radiusList).f := Feature new.rep := OrderedCollection new.rep add:0.5.rep add: 0.25.f representation: rep.radiusList at: 2 put: 0.25.radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 2 put: 0.1.radiusList at: 1 put: 0.25.self assert: ( lang is: f to:cs in: radiusList).radiusList at: 1 put: 0.1.self assert: ( lang is: f to:cs in: radiusList) not.! !!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:25'!testIsWithThesameLanguageAsWithAnd! !----SNAPSHOT----2016-07-07T18:29:44.142593+02:00 Pharo4.0.image priorSource: 1849602!LanguageDifferentiatorTest removeSelector: #testIsWithThesameLanguageAsWithAnd!!LanguageDifferentiatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:41'!testIsWithThesameLanguageAsWithAnd! !LanguageDifferentiatorTest removeSelector: #testIsWithThesameLanguageAsWithAnd!!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:43'!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 35289205!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to: 100) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 34807456!testsumVec|list1 list2|self assert: (Vector euclideanDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list2 add: 2.list2 add: 1.list1 add: 0.list1 add: 1.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 1) = 0.self assert: ((Vector sumVec: LinkedList new plus: list1) at: 2) = 1. self assert: ((Vector sumVec: list1 plus: LinkedList new ) at: 1) = 0.self assert: ((Vector sumVec: list1 plus: LinkedList new) at: 2) = 1.self assert: ((Vector sumVec: list1 plus: list2) at: 1) = 2.self assert: ((Vector sumVec: list1 plus: list2) at: 2) = 2.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 34802648!testdivideThrough|list1|self assert: (Vector euclideanDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: ((Vector divide: list1 through: 5)at: 1 ) = 0.self assert: ((Vector divide: list1 through: 5)at: 2 ) = (1/5).self should: [Vector divide: list1 through: 0] raise: ZeroDivide.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 34793927!testdistanceFrom|list1|self assert: (Vector euclideanDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 34760040!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector euclideanDistanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector euclideanDistanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]. ^sum/kc.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 34611932!analyze: result| sum |sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector euclideanDistanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].^sum.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 35406005!is: feature to: centroids in: radiusList	|ciPosition |			ciPosition := 0.			centroids do: [ :ci|		|d | 					ciPosition := ciPosition +1.		d := Vector euclideanDistanceFrom: feature representation to: ci.					((radiusList at: ciPosition) >= d) ifTrue: [ ^true].			 		].^false.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:43' prior: 35306496!calcRadiusListfrom: bestResult|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector euclideanDistanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !Vector class removeSelector: #distanceFrom:to:!----SNAPSHOT----2016-07-07T18:45:48.591593+02:00 Pharo4.0.image priorSource: 1858848!!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:49'!featureDistanceFrom: aVector to:  anotherVector.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:49' prior: 35418950!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:52' prior: 35419089!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:53' prior: 35419508!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount						]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:53' prior: 35419928!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount						]; ifTrue: [  b:=0].		d:= d+(c squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 18:55' prior: 35420369!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[c:= 1].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ].			].		d:= d+(c squared).	 ].	^d sqrt.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:56'!testfeatureDistanceFromTo! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:57' prior: 35421296!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:59' prior: 35421425!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 1.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 18:59' prior: 35421856!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector euclideanDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector euclideanDistanceFrom: list1  to: LinkedList new) = 1.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/7/2016 19:02' prior: 35420806!featureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[c:= 1]; ifTrue:[c:=0].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ]; ifTrue:[c:=0].			].		d:= d+(c squared).	 ].	^d sqrt.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 19:04' prior: 35422470!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 19:04' prior: 35423607!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt .self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/7/2016 19:04' prior: 35424213!testfeatureDistanceFromTo|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !----QUIT----2016-07-07T23:38:47.706593+02:00 Pharo4.0.image priorSource: 1864359!----STARTUP----2016-07-08T13:15:07.339509+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-07-08T13:27:23.421509+02:00 Pharo4.0.image priorSource: 1870913!AbstractRepresentator subclass: #WeightSummaryRepresentator	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:28'!asString	^'Weight Summary Representator'! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:30'!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.		feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:39' prior: 35426014!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	list := OrderedCollection new.		feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:39' prior: 35426496!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:41' prior: 35426989!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].	].].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:42' prior: 35427503!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  ].	].feature representation: list.].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:43' prior: 35427966!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement asInteger.			lastElement := element.			].	].feature representation: list.].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:43' prior: 35428538!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].	].feature representation: list.].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:44' prior: 35429177!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement|	lastElement := nil.	list := OrderedCollection new.		feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !TestCase subclass: #WeightSummaryRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Structure-K-means-Tests'!!WeightSummaryRepresentatorTest commentStamp: '<historical>' prior: 0!A WeightSummaryRepresentatorTest is a test class for testing the behavior of WeightSummaryRepresentator!!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:44'!testMakeFeaturesFrom! !TestCase subclass: #WeightSummaryRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:45'!setUp! !TestCase subclass: #WeightSummaryRepresentatorTest	instanceVariableNames: 'features'	classVariableNames: ''	category: 'StructureTests'!!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:46' prior: 35431061!setUp|f1 f2 f3 f4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:46' prior: 35431336!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:47' prior: 35431562!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:47' prior: 35431931!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:48' prior: 35432400!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:48' prior: 35430795!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features at: 1.t2 := features at: 2.t3 := features at: 3.t4 := features at: 4.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:49' prior: 35433445!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features at: 1.t2 := features at: 2.t3 := features at: 3.t4 := features at: 4.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:50' prior: 35433697!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features at: 1.t2 := features at: 2.t3 := features at: 3.t4 := features at: 4.self assert: ((t1) at: 1) = 0.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:50' prior: 35433951!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features at: 1.t2 := features at: 2.t3 := features at: 3.t4 := features at: 4.self assert: ((t1 at: 1) = 0).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:51' prior: 35432883!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:52' prior: 35434521!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:56' prior: 35429806!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	list := OrderedCollection new.			feature representation do:[ :element|		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:56' prior: 35435850!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|		count := count +1.		(lastElement = nil) ifTrue: [ lastElement := element ].		(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:57' prior: 35436514!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			(lastElement = nil) ifTrue: [ lastElement := element ].			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			(count = feature representation size) ifTrue: [ list add:element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:58' prior: 35435154!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 1.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:58' prior: 35437994!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:58' prior: 35438792!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep2 add: 1.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:58' prior: 35439592!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 1.rep3 add: 1.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:59' prior: 35440484!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 1.rep3 add: 1.rep4 add: 1.rep4 add: 2.rep4 add: 0.rep4 add: 1.rep4 add: 2.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 13:59' prior: 35441376!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep3 add: 1.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 1.rep3 add: 1.rep4 add: 1.rep4 add: 2.rep4 add: 0.rep4 add: 1.rep4 add: 2.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:00' prior: 35437212!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			(lastElement = nil) ifTrue: [ lastElement := element ].			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			(count = feature representation size) ifTrue: [ list add: element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:01' prior: 35442333!setUp|f1 f2 f3 f4 rep1 rep2 rep3 rep4|features := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.f4 := Feature new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep4 := OrderedCollection new.f1 representation: rep1.f2 representation: rep2.f3 representation: rep3.f4 representation: rep4.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep3 add: 1.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 1.rep3 add: 1.rep4 add: 1.rep4 add: 2.rep4 add: 0.rep4 add: 1.rep4 add: 2.features add: f1.features add: f2.features add: f3.features add: f4.features := WeightSummaryRepresentator new makeFeaturesFrom: features.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:01' prior: 35434236!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features at: 1.t2 := features at: 2.t3 := features at: 3.t4 := features at: 4.self assert: ((t1 representation at: 1) = 0).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:01' prior: 35445054!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := features representation at: 1.t2 := features representation at: 2.t3 := features representation at: 3.t4 := features representation at: 4.self assert: ((t1  at: 1) = 0).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:02' prior: 35445354!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:03' prior: 35445700!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).self assert: ((t2 at: 1) = 0).self assert: ((t2 at: 2) = 1).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:03' prior: 35446054!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).self assert: ((t2 at: 1) = 0).self assert: ((t2 at: 2) = 1).self assert: ((t3 at: 1) = 1).self assert: ((t3 at: 2) = 0).self assert: ((t3 at: 3) = 1).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:04' prior: 35446470!testMakeFeaturesFrom|t1 t2 t3 t4|t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).self assert: ((t2 at: 1) = 0).self assert: ((t2 at: 2) = 1).self assert: ((t3 at: 1) = 1).self assert: ((t3 at: 2) = 0).self assert: ((t3 at: 3) = 1).self assert: ((t4 at: 1) = 1).self assert: ((t4 at: 2) = 2).self assert: ((t4 at: 3) = 0).self assert: ((t4 at: 4) = 1).self assert: ((t4 at: 5) = 2).! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:05' prior: 35446980!testMakeFeaturesFrom|t1 t2 t3 t4 r|t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).self assert: ((t2 at: 1) = 0).self assert: ((t2 at: 2) = 1).self assert: ((t3 at: 1) = 1).self assert: ((t3 at: 2) = 0).self assert: ((t3 at: 3) = 1).self assert: ((t4 at: 1) = 1).self assert: ((t4 at: 2) = 2).self assert: ((t4 at: 3) = 0).self assert: ((t4 at: 4) = 1).self assert: ((t4 at: 5) = 2).r := OrderedCollection new.r add: 0.! !!WeightSummaryRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 14:05' prior: 35447649!testMakeFeaturesFrom|t1 t2 t3 t4 |t1 := (features at: 1) representation.t2 := (features at: 2) representation.t3 := (features at: 3) representation.t4 := (features at: 4) representation.self assert: ((t1  at: 1) = 0).self assert: ((t2 at: 1) = 0).self assert: ((t2 at: 2) = 1).self assert: ((t3 at: 1) = 1).self assert: ((t3 at: 2) = 0).self assert: ((t3 at: 3) = 1).self assert: ((t4 at: 1) = 1).self assert: ((t4 at: 2) = 2).self assert: ((t4 at: 3) = 0).self assert: ((t4 at: 4) = 1).self assert: ((t4 at: 5) = 2).! !----SNAPSHOT----2016-07-08T14:13:19.598509+02:00 Pharo4.0.image priorSource: 1871105!!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 15:58' prior: 35110073!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 15:59'!reverse: aRepresentation! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 15:59' prior: 35451882!reverse: cList! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:00' prior: 35452025!reverse: cListcList do: [ :c|				 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:00' prior: 35452158!reverse: cListcList do: [ :c|	c do:[ :element|										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:02' prior: 35452318!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element < 2 and: element > 1) ifTrue: [  n := element - 1].										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:04' prior: 35452507!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 1].										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:05' prior: 35452765!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 1].									]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:10' prior: 35453087!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].									]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:10' prior: 35453408!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n.						]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:10' prior: 35453729!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n.										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:13' prior: 35454059!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n.										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:16' prior: 35454395!reverse: cListcList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.								]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:17' prior: 35454731!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:17' prior: 35455125!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.										]		 ].! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:18' prior: 35455564!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].			n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		rep add: (dict at: n).		].	result add: rep.	 ].^result! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:18' prior: 35456041!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		rep add: (dict at: n).		].	result add: rep.	 ].^result! !TestCase subclass: #TypeSpecificRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Structure-K-means-Tests'!!TypeSpecificRepresentatorTest commentStamp: '<historical>' prior: 0!A TypeSpecificRepresentatorTest is a test class for testing the behavior of TypeSpecificRepresentator!!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:18'!testReverse! !TestCase subclass: #TypeSpecificRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:19'!setUp|string |string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := (TypeSpecificRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:20'!testMakeFromFeature| rep1 rep2|rep1 := (testFeature at: 1) representation.self assert: (rep1 at: 1) = 3.self assert: (rep1 at: 2) = (3/2).self assert: (rep1 at: 3) = (3/2).self assert: (rep1 at: 4) = (3/2).self assert: (rep1 at: 5) = (1/3).self assert: (rep1 at: 6) = (1/3).self assert: (rep1 at: 7) = (1/4).self assert: (rep1 at: 8) = (1/5).self assert: (rep1 at: 9) = 3.self assert: (rep1 at: 10) = 3.rep2 := (testFeature at: 2) representation.self assert: (rep2 at: 1) = (1/3).self assert: (rep2 at: 2) = (13/6).self assert: (rep2 at: 3) = (15/7).self assert: (rep2 at: 4) = (3/2).self assert: (rep2 at: 5) = (9/8).self assert: (rep2 at: 6) = (10/9).! !Smalltalk globals removeClassNamed: #SpecificTypeRepresentatorTest!(Smalltalk globals at: #TypeRepresentatorTest) rename: #TypeStructureRepresentatorTest!AbstractRepresentator subclass: #TypeSpecificRepresentator	instanceVariableNames: 'dict2'	classVariableNames: ''	category: 'Structure-K-means'!!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:31' prior: 35449106!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:32' prior: 35459083!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:32' prior: 35461880!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].												].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:33' prior: 35456557!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		rep add: (dict2 at: n).		].	result add: rep.	 ].^result! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/8/2016 16:34' prior: 35467627!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		rep add: (dict2 at: n).		].	result add: rep.	 ].^result! !----SNAPSHOT----2016-07-08T16:34:46.972509+02:00 Pharo4.0.image priorSource: 1894471!----SNAPSHOT----2016-07-08T17:07:03.128509+02:00 Pharo4.0.image priorSource: 1914171!----SNAPSHOT----2016-07-08T17:16:01.694509+02:00 Pharo4.0.image priorSource: 1914258!----SNAPSHOT----2016-07-08T17:18:50.961509+02:00 Pharo4.0.image priorSource: 1914345!----QUIT----2016-07-08T18:45:42.379509+02:00 Pharo4.0.image priorSource: 1914432!----STARTUP----2016-07-08T20:01:53.917383+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!TestCase subclass: #TypeSpecificRepresentatorTest	instanceVariableNames: 'testFeature vectors'	classVariableNames: ''	category: 'StructureTests'!!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:04' prior: 35457656!setUp|string |string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := (TypeSpecificRepresentator new) makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).vectors add: (testFeature at:1 representation).vectors add: (testFeature at:1 representation).! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:05' prior: 35469419!setUp|string t|t := TypeSpecificRepresentator new.string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := t makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).vectors add: (testFeature at:1 representation).vectors add: (testFeature at:1 representation).vectors :=  t reverse: vectors.! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:06' prior: 35457401!testReverseself assert: (vectors at:1) = $}.! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:06' prior: 35470335!testReverseself assert: ((vectors at:1) = $}).! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:06' prior: 35469858!setUp|string t|t := TypeSpecificRepresentator new.string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := t makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).vectors add: ((testFeature at:1) representation).vectors add: ((testFeature at:1) representation).vectors :=  t reverse: vectors.! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:06' prior: 35470685!setUp|string t|t := TypeSpecificRepresentator new.vectors := OrderedCollection new.string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := t makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).vectors add: ((testFeature at:1) representation).vectors add: ((testFeature at:1) representation).vectors :=  t reverse: vectors.! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:07' prior: 35470509!testReverseself assert: ((vectors at:1) = ${).! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:08' prior: 35471681!testReverse|vec1 vec2|vec1 := vectors at: 1.vec2 := vectors at: 2.self assert: ((vec1 at:1) = ${).! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:08' prior: 35471857!testReverse|vec1 vec2|vec1 := vectors at: 1.vec2 := vectors at: 2.self assert: ((vec1 at:1) = '{').! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:09' prior: 35472088!testReverse|vec1 vec2|vec1 := vectors at: 1.vec2 := vectors at: 2.self assert: ((vec1 at:1) = '{').self assert: ((vec1 at:2) = '1').self assert: ((vec1 at:3) = '1').self assert: ((vec1 at:4) = '1').self assert: ((vec1 at:5) = 'a').self assert: ((vec1 at:6) = 'a').self assert: ((vec1 at:7) = 'b').self assert: ((vec1 at:8) = 'c').self assert: ((vec1 at:9) = '{').self assert: ((vec1 at:10) = '{').! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:10' prior: 35472320!testReverse|vec1 vec2|vec1 := vectors at: 1.vec2 := vectors at: 2.self assert: ((vec1 at:1) = '{').self assert: ((vec1 at:2) = '1').self assert: ((vec1 at:3) = '1').self assert: ((vec1 at:4) = '1').self assert: ((vec1 at:5) = 'a').self assert: ((vec1 at:6) = 'a').self assert: ((vec1 at:7) = 'b').self assert: ((vec1 at:8) = 'c').self assert: ((vec1 at:9) = '{').self assert: ((vec1 at:10) = '{').self assert: ((vec2 at:1) = 'a').self assert: ((vec2 at:2) = '.').self assert: ((vec2 at:3) = ',').self assert: ((vec2 at:4) = '1').self assert: ((vec2 at:5) = '2').self assert: ((vec2 at:6) = '3').! !!TypeSpecificRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'cedricwalker 7/8/2016 20:11' prior: 35471166!setUp|string t|t := TypeSpecificRepresentator new.vectors := OrderedCollection new.string := '{ 1 1 1 a a b c }}' , Character cr asString, 'a . , 1 2 3'.testFeature := t makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: string).vectors add: ((testFeature at:1) representation).vectors add: ((testFeature at:2) representation).vectors :=  t reverse: vectors.! !----SNAPSHOT----2016-07-08T22:21:00.641383+02:00 Pharo4.0.image priorSource: 1914519!!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/8/2016 22:21'!advancedFeatureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[c:= 1]; ifTrue:[c:=0].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ]; ifTrue:[c:=0].			].		d:= d+(c squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/8/2016 22:35' prior: 35474151!advancedFeatureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[								(b floor = a floor) ifTrue: [ c:= 0.25 ]; ifFalse: [ c:= 1 ].				]; ifTrue:[c:=0].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ]; ifTrue:[c:=0].			].		d:= d+(c squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/8/2016 22:35' prior: 35474682!advancedFeatureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[				(b floor = a floor) ifTrue: [ c:= 0.25 ]; ifFalse: [ c:= 1 ].				]; ifTrue:[c:=0].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ]; ifTrue:[c:=0].			].		d:= d+(c squared).	 ].	^d sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:35'!advancedFeatureDistanceTest! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:36' prior: 35475865!advancedFeatureDistanceTest|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:37'!testadvancedFeatureDistance|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !VectorTest removeSelector: #advancedFeatureDistanceTest!!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:37' prior: 35476568!testadvancedFeatureDistance|list1|self assert: (Vector featureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector featureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector featureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:38' prior: 35477227!testadvancedFeatureDistance|list1|self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:38' prior: 35477828!testadvancedFeatureDistance|list1|"regress"self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:40' prior: 35478469!testadvancedFeatureDistance|list1|"regress"self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1. ! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 7/8/2016 22:41' prior: 35475285!advancedFeatureDistanceFrom: vec1 to:  vec2	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b c|		c:=0.		a := v1 at: cCount.		(cCount>(v2 size)) ifFalse: [ 			b:= v2 at: cCount.			(b=a) ifFalse:[				(b ceiling  = a ceiling) ifTrue: [ c:= 0.25 ]; ifFalse: [ c:= 1 ].				]; ifTrue:[c:=0].				]; ifTrue: [  			(a = 0) ifFalse: [ c:= 1 ]; ifTrue:[c:=0].			].		d:= d+(c squared).	 ].	^d sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:41' prior: 35479120!testadvancedFeatureDistance|list1|"regress"self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:41' prior: 35480440!testadvancedFeatureDistance|list1|"regress"self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:47' prior: 35481177!testadvancedFeatureDistance|list1 list2|"regress"self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 := LinkedList new.list2 := LinkedList new.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:47' prior: 35481916!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:48' prior: 35482859!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.self assert: (Vector advancedFeatureDistanceFrom: list2 new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: list2) = 2 sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:49' prior: 35483858!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.self assert: (Vector advancedFeatureDistanceFrom: list2 new to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 new to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:50' prior: 35484843!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:50' prior: 35485898!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:50' prior: 35486945!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list2 add:1.list2 add:1.list2 add:1.list2 add:1.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:50' prior: 35487992!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:51' prior: 35489038!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:51' prior: 35490117!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:51' prior: 35491201!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:55' prior: 35492318!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared ) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:55' prior: 35493440!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add:0.25.list1 add:0.25.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:56' prior: 35494580!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add: 0.25.list1 add: 0.25.list1 add: 1.list2 add:1.list2 add:1.list2 add:1.list2 add:1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:56' prior: 35495719!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add: 0.25.list1 add: 0.25.list1 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 0.25.list2 add: 0.95.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:56' prior: 35496874!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add: 0.25.list1 add: 0.25.list1 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 0.25.list2 add: 0.95.list2 add: 3.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared) sqrt.! !!VectorTest methodsFor: 'tests' stamp: 'cedricwalker 7/8/2016 22:56' prior: 35498033!testadvancedFeatureDistance|list1 list2|"regress"list1 := LinkedList new.list2 := LinkedList new.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to:  LinkedList new) = 0.list1 add: 0.list1 add: 1.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 1.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 1.list1 add: 0.list1 add: 3.self assert: (Vector advancedFeatureDistanceFrom: LinkedList new to: list1 ) = 2 sqrt.self assert: (Vector advancedFeatureDistanceFrom: list1  to: LinkedList new) = 2 sqrt.list1 at: 1 put: 0.25.list1 at: 2 put: 0.75.list1 at: 3 put: 1.list1 at: 4 put: 2.list1 add: 0.25.list1 add: 0.25.list1 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 1.list2 add: 0.25.list2 add: 0.95.list2 add: 3.self assert: (Vector advancedFeatureDistanceFrom: list1 to: list2 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared + 1) sqrt.self assert: (Vector advancedFeatureDistanceFrom: list2 to: list1 ) = (0.25 squared + 0.25 squared + 1 +0.25 squared + 1) sqrt.! !----SNAPSHOT----2016-07-08T22:58:13.716383+02:00 Pharo4.0.image priorSource: 1919560!----QUIT----2016-07-08T23:06:57.972383+02:00 Pharo4.0.image priorSource: 1945868!----STARTUP----2016-07-09T15:50:01.768662+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-07-09T15:50:05.850662+02:00 Pharo4.0.image priorSource: 1945955!Object subclass: #StructureClassifier	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k1 k2'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k1 k2 path'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:06'!run! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:07' prior: 35501160!run(mode = 1) ifTrue: [  ].(mode = 2) ifTrue: [  ].(mode = 3) ifTrue: [  ].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:07' prior: 35501276!run|krunner lDiff|(mode = 1) ifTrue: [  ].(mode = 2) ifTrue: [  ].(mode = 3) ifTrue: [  ].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:09' prior: 35501467!run|krunner lDiff|(mode = 1) ifTrue: [  ].(mode = 2) ifTrue: [  ].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:09' prior: 35501674!run|krunner lDiff|(mode = 1) ifTrue: [  krunner := KMeansRunner new.].(mode = 2) ifTrue: [  krunner := KMeansRunner new.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:10' prior: 35501998!run|krunner lDiff|(mode = 1) ifTrue: [  krunner := KMeansRunner new.].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:11' prior: 35502378!run|krunner lDiff|(mode = 1) ifTrue: [  krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:11' prior: 35502815!run|krunner lDiff|(path = nil)ifTure:[^'Path is not Defined!!'.].(mode = 1) ifTrue: [  krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:11' prior: 35503296!run|krunner lDiff|(path = nil)ifTure:[^'Path is not Defined!!'.].(mode = 1) ifTrue: [  krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:13' prior: 35503826!run|krunner lDiff|(path = nil)ifTure:[^'Path is not Defined!!'.].(k1 = nil)ifTrue:[	^'Please define k1'].(mode = 1) ifTrue: [  krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:16' prior: 35504357!run|krunner lDiff|(path = nil)ifTure:[^'Path is not Defined!!'.].(k1 = nil)ifTrue:[^'Please define k1'].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:17' prior: 35504930!run|krunner lDiff|(path = nil)ifTure:[^'Path is not Defined!!'.].(k1 = nil)ifTrue:[^'Please define k1'].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:19' prior: 35505605!run|krunner lDiff message|message := ''.(path = nil)ifTure:[^'Path is not Defined!!'.].(k1 = nil)ifTrue:[^'Please define k1'].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:19' prior: 35506286!run|krunner lDiff message|message := ''.(path = nil)ifTure:[^'Path is not Defined'.].(k1 = nil)ifTrue:[^'Please define k1'].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:20' prior: 35507016!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined'.	^message.	].(k1 = nil)ifTrue:[^'Please define k1'].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:20' prior: 35507744!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined'.	^message.	].(k1 = nil)ifTrue:[message := message,'Please define k1'.	^message].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:20' prior: 35508506!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined'.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1'.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [ ^'please enter valid mode'. ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:21' prior: 35509297!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:21' prior: 35510092!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:21' prior: 35510978!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  ].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:21' prior: 35511864!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:22' prior: 35512760!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:22' prior: 35513726!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k1 = nil)ifTrue:[	message := message,'Please define k1', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k1 to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k1.	].! !Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k1 k2 path aType anotherType'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:24' prior: 35514704!run|krunner lDiff message|message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:25'!path: aPathpath := aPath! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:25'!k: aKk := aK.	! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:25'!k2: aKk2 := aK.	! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:26'!loops:aNumberloops := aNumber.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:26'!mode:aNumbermode := aNumber.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:29'!type1: aStringaType := aString.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:29'!type2: aStringanotherType := aString.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:31' prior: 35516002!run|krunner lDiff message|loops := 100.(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:32' prior: 35517845!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:32' prior: 35518872!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100							krunner loops:loops].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator loops'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:32'!loops: aNumberloops := aNumber.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:33' prior: 35414310!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to:loops) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:33' prior: 35519886!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:33' prior: 35522250!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:34'!metric: aNumbermetric := aNumber.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:39' prior: 35523307!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:39' prior: 35524661!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:39' prior: 35525720!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.		krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:39' prior: 35526804!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:40' prior: 35527914!run|krunner lDiff message|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].		krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:45' prior: 35529023!run|krunner lDiff message|	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !----SNAPSHOT----2016-07-09T16:45:44.394662+02:00 Pharo4.0.image priorSource: 1946146!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:46' prior: 35530143!run|krunner lDiff message|	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.		^message.		].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !Object subclass: #LanguageDifferentiator	instanceVariableNames: 'krunner'	classVariableNames: ''	category: 'Structure-K-means'!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:46'!krunner:aKMeansRunnerkrunner := aKMeansRunner.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:46' prior: 35402829!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	krunner := KMeansRunner new.	bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 16:46' prior: 35532776!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: anotherType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: aPath type: aType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !----SNAPSHOT----2016-07-09T16:49:20.287662+02:00 Pharo4.0.image priorSource: 1976721!----SNAPSHOT----2016-07-09T17:39:22.411662+02:00 Pharo4.0.image priorSource: 1980091!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:10'!representator:aRepresentatorrepresentator :=aRepresentator .! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:11' prior: 35211276!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distanceRep WeithRep.'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distanceRep WeithRep'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:13'!typeRep:aReptypeRep  := aRep.! !Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distanceRep weigthRep'	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distRep weigthRep'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:13'!distRep:aRepdistRep  := aRep.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:14'!wheigthRep:aRepweigthRep := aRep.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:16' prior: 35531350!run|krunner lDiff message|	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	^message.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	^message	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	^message	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				].(typeRep = nil) ifTrue:[ message := message, 'TypeRep must be defined' , Character cr asString.].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:16' prior: 35537104!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				].(typeRep = nil) ifTrue:[ message := message, 'TypeRep must be defined' , Character cr asString.].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:17' prior: 35538337!run|krunner lDiff message|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				].(typeRep = nil) ifTrue:[ message := message, 'TypeRep must be defined' , Character cr asString.].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !----SNAPSHOT----2016-07-09T18:17:27.040662+02:00 Pharo4.0.image priorSource: 1980178!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:17' prior: 35539536!run|krunner lDiff message result|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				].(typeRep = nil) ifTrue:[ message := message, 'TypeRep must be defined' , Character cr asString.].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:18' prior: 35540858!run|krunner lDiff message result|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				].(typeRep = nil) ifTrue:[ message := message, 'TypeRep must be defined' , Character cr asString.].	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:19' prior: 35542100!run|krunner lDiff message result|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:19' prior: 35543372!run|krunner lDiff message result|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:22' prior: 35544559!run|krunner lDiff message result|(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString.].(mode = 1) ifTrue: [  	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner.	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:23' prior: 35545749!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	].(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:23' prior: 35547036!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	].(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:24' prior: 35548248!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/9/2016 18:25' prior: 35549509!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTure:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep Rep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !----SNAPSHOT----2016-07-09T18:27:49.828662+02:00 Pharo4.0.image priorSource: 1986229!----SNAPSHOT----2016-07-09T21:36:00.564662+02:00 Pharo4.0.image priorSource: 1997662!----QUIT----2016-07-09T22:19:20.326662+02:00 Pharo4.0.image priorSource: 1997749!----STARTUP----2016-07-10T14:58:42.883232+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator loops metric'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:00'!metric: aNumbermetric := aNumber.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:29' prior: 35521193!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to:loops) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:30' prior: 35552846!kMean: featureList with: k on:  aRepresentator	|centroids result|	centroids := representator initCentroids: k with: featureList.		(1 to:loops) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].				(metric = 3)ifTrue:[d := Vector advancedFeatureDistanceFrom: (centroids at:aC) to: feature representation].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:30' prior: 35007681!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.	representator := RepresentatorRunner new.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:35' prior: 35533720!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: anotherPath from:  (k/2) floor to: k onType: aType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: aPath type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !----SNAPSHOT----2016-07-10T15:35:07.677232+02:00 Pharo4.0.image priorSource: 1997836!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:36' prior: 35550813!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep Rep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:36' prior: 35557160!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: 8 type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifTrue: [  ^message].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:41' prior: 35555280!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !----SNAPSHOT----2016-07-10T15:41:47.065232+02:00 Pharo4.0.image priorSource: 2002530!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:44' prior: 35558552!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k to: k2 onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].^result! !!RepresentatorRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:48' prior: 34663189!makeFeaturesFrom: aStatementList "List containing Statement Elements, defined in StrucutureFinder"	|list|list := LinkedList new.	list := typeRep makeFeaturesFrom: aStatementList.	((distRep = nil)) ifFalse: [  list := distRep  makeFeaturesFrom: list ].	((weightRep = nil)) ifFalse: [  list := weightRep  makeFeaturesFrom: list ].	^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 15:57' prior: 35534951!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ]."self saveConfig: fHandler to: newpath."self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).^bestResult.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:00' prior: 35562700!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ]."self saveConfig: fHandler to: newpath.""self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp)."^bestResult.! !!UndefinedObject methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:02' prior: 35006900!DoIt	| sClass |	sClass := StructureClassifier new.	sClass path: 'C:\Users\Cedric\Dropbox\pharo\testFiles'.	sClass type1: 'java'.	sClass type2: 'xml'.	sClass k: 6.	sClass k2: 4.	sClass mode: 2.	sClass loops: 20.	sClass typeRep: TypeSpecificRepresentator new.	sClass wheigthRep: WeightSummaryRepresentator new.	sClass metric: 1.	^ sClass run! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:02' prior: 35563772!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !----SNAPSHOT----2016-07-10T16:04:05.036232+02:00 Pharo4.0.image priorSource: 2006223!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:06' prior: 35565308!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kTwo to: kOne) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:14' prior: 35560853!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:14' prior: 35566382!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^bestResult.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 16:17' prior: 35556159!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !----SNAPSHOT----2016-07-10T16:18:04.767232+02:00 Pharo4.0.image priorSource: 2011759!----SNAPSHOT----2016-07-10T16:35:05.100232+02:00 Pharo4.0.image priorSource: 2016162!----SNAPSHOT----2016-07-10T16:54:19.964232+02:00 Pharo4.0.image priorSource: 2016249!----SNAPSHOT----2016-07-10T20:14:17.363232+02:00 Pharo4.0.image priorSource: 2016336!Object subclass: #StructureAnalyzer	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distRep weigthRep'	classVariableNames: ''	category: 'StructureFinder'!StructureClassifier subclass: #StructureFinder	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!StructureClassifier subclass: #StructureAnalyzer	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:26'!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].^result! !StructureClassifier removeSelector: #run!----SNAPSHOT----2016-07-10T20:28:24.735232+02:00 Pharo4.0.image priorSource: 2016423!----SNAPSHOT----2016-07-10T20:29:47.306232+02:00 Pharo4.0.image priorSource: 2018379!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:31' prior: 35571482!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].(typeRep isMemberOf: TypeSpecificRepresentator) ifTrue: [ ^krunner representator reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:31' prior: 35573092!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].(typeRep isMemberOf: TypeSpecificRepresentator) ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:32' prior: 35574593!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:34'!analyze! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:34' prior: 35577643!analyze|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:43'!clustersAsStreams: path type: type! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:43' prior: 35579289!clustersAsStreams: path type: type|projectPath streamList|projectPath := path , '\results\',type.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:44' prior: 35579417!clustersAsStreams: path type: type|projectPath streamList|streamList := OrderedCollection new.projectPath := path , '\results\',type.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:44' prior: 35579610!clustersAsStreams: path type: type|projectPath streamList|streamList := OrderedCollection new.projectPath := path , '\results\',type.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:44' prior: 35579840!clustersAsStreams: path type: type|projectPath streamList inputLoader stream |streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:44' prior: 35580071!clustersAsStreams: path type: type|projectPath streamList inputLoader stream|streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:45' prior: 35580617!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.		projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ streamList.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:46' prior: 35581162!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.		projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)].				streamList add: stream].	^ streamList.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:46' prior: 35581711!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.		projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [					stream nextPutAll: (inputLoader					loadFromFile: reference)].				streamList add: stream].	^ streamList.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/10/2016 20:46' prior: 35582287!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\results\',type.	inputLoader := FileHandler  new.		projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [					stream nextPutAll: (inputLoader loadFromFile: reference).					streamList add: stream].					].	^ streamList.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:47'!featurize: streamList! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:48' prior: 35577762!analyze|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:49' prior: 35583588!analyze|krunner fileHandler|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.! !----SNAPSHOT----2016-07-10T20:49:50.212232+02:00 Pharo4.0.image priorSource: 2018466!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:49' prior: 35583872!analyze|krunner fileHandler|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:50' prior: 35584260!analyze|krunner fileHandler|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:51' prior: 35584563!analyze|krunner fileHandler perfectResult|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := fileHandler clustersAsStreams: path type: typeRep . ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:51' prior: 35584866!analyze|krunner fileHandler perfectResult|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := fileHandler clustersAsStreams: path type: aType. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:53' prior: 35585252!analyze|krunner fileHandler perfectResult|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self reateResult:path type:aType. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:53' prior: 35585635!analyze|krunner fileHandler perfectResult|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:54'!createResult|fHandler streams|fHandler := FileHandler new.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:54' prior: 35586356!createResult|fHandler streams|fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:55' prior: 35586529!createResult|fHandler streams|fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	]. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:55' prior: 35586759!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 		]. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:56' prior: 35587017!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker)	]. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:57' prior: 35587325!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/10/2016 20:58' prior: 35587672!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [  ].! !----SNAPSHOT----2016-07-10T20:58:14.363232+02:00 Pharo4.0.image priorSource: 2029632!----QUIT----2016-07-10T23:27:40.644232+02:00 Pharo4.0.image priorSource: 2033913!----STARTUP----2016-07-11T14:42:30.958164+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:44' prior: 35586003!analyze|krunner fileHandler perfectResult cPerfekt cbestResult|	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType. ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:47' prior: 35588733!analyze|krunner fileHandler perfectResult cPerfekt cbestResult bestResult |	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: 1 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:47' prior: 35589123!analyze|krunner fileHandler perfectResult cPerfekt cbestResult bestResult |	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: 1 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:49' prior: 35588053!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|			  ].! !StructureClassifier subclass: #StructureAnalyzer	instanceVariableNames: 'krunner'	classVariableNames: ''	category: 'StructureFinder'!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:50' prior: 35589778!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult |	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: 1 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:50' prior: 35590435!createResult|fHandler streams statements|statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	krunner representator makeFeaturesFrom: statementList.		  ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:52' prior: 35591644!createResult|fHandler streams statements features|features := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	features add: (krunner representator makeFeaturesFrom: statementList).	  ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:52' prior: 35592120!createResult|fHandler streams statements features featurePerFile|features := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:52' prior: 35592654!createResult|fHandler streams statements features featurePerFile|features := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:53' prior: 35593209!createResult|fHandler streams statements features featurePerFile result|features := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:54' prior: 35593805!createResult|fHandler streams statements features featurePerFile result cCount|cCount := 0.features := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList| ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:54' prior: 35594442!createResult|fHandler streams statements features featurePerFile result cCount|cCount := 0.features := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList| 	cCount := cCount +1.		].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:54' prior: 35595136!createResult|fHandler streams statements features featurePerFile result cCount|cCount := 0.features := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList| 	cCount := cCount +1.				].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:55' prior: 35595856!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|			cCount := cCount +1.				].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:56' prior: 35596579!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|		cCount := cCount +1.	featureList do: [ :feature| feature klabel: cCount].				].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 14:56' prior: 35597351!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|		cCount := cCount +1.	featureList do: [ :feature| feature klabel: cCount].			].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:02' prior: 35598175!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|		cCount := cCount +1.	featureList do: [ :feature| feature klabel: cCount].	featureList 			].! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:03'!longestFeature^longestFeature! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:07' prior: 35598998!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|	|fCount|	fCount :=0.	cCount := cCount +1.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|		|sum|		sum := OrderedCollection new.		sum := Vector sumVec: sum plus: feature representation.		 ].			].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:07' prior: 35599965!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|	|fCount|	fCount :=0.	cCount := cCount +1.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|		|sum|		fCount := fCount +1.		sum := OrderedCollection new.		sum := Vector sumVec: sum plus: feature representation.		 ].			].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:08' prior: 35600966!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|	|fCount sum |	fCount :=0.	cCount := cCount +1.	sum := OrderedCollection new.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|				fCount := fCount +1.				sum := Vector sumVec: sum plus: feature representation.		 ].		centroids add: (Vector divide: sum through: fCount).		].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:08' prior: 35601990!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|	|fCount sum |	fCount :=0.	cCount := cCount +1.	sum := OrderedCollection new.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|				fCount := fCount +1.				sum := Vector sumVec: sum plus: feature representation.		 ].		centroids add: (Vector divide: sum through: fCount).	].result add: features.result add: centroids.^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:09' prior: 35590995!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: 1 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !----SNAPSHOT----2016-07-11T15:21:51.800164+02:00 Pharo4.0.image priorSource: 2033913!----SNAPSHOT----2016-07-11T15:26:06.746164+02:00 Pharo4.0.image priorSource: 2050388!!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/11/2016 15:26' prior: 35582868!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\perfect\',type.inputLoader := FileHandler  new.		(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [					stream nextPutAll: (inputLoader loadFromFile: reference).					streamList add: stream].					].	^ streamList.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:27' prior: 35603069!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: aType.streams do:[ :stream| 	statements add: (NewLineStatementmaker new createTokanizedStatement: stream).	]. statements do: [:statementList|	featurePerFile add: (krunner representator makeFeaturesFrom: statementList).	  ].featurePerFile do: [ :featureList|	|fCount sum |	fCount :=0.	cCount := cCount +1.	sum := OrderedCollection new.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|				fCount := fCount +1.				sum := Vector sumVec: sum plus: feature representation.		 ].		centroids add: (Vector divide: sum through: fCount).	].result add: features.result add: centroids.^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:31' prior: 35604199!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: k to: k2 onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:31' prior: 35606782!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult:path type:aType.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:31' prior: 35607513!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:32' prior: 35608244!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.			perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:32' prior: 35608959!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res message|	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:32' prior: 35609678!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult at: 1)with:  (perfectResult at:2).	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult at: 1)with:  (bestResult at:2).	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 15:35' prior: 35610639!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult)with:  (perfectResult at:2) size.	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult)with:  (bestResult at:2) size.	res add: cPerfekt.	res add: cbestResult.	^res! !----SNAPSHOT----2016-07-11T16:21:01.032164+02:00 Pharo4.0.image priorSource: 2050475!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:24' prior: 35568766!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self elbow:c.self saveConfig: fHandler to: newpath.^bestResult.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:25' prior: 35612671!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self elbow.self saveConfig: fHandler to: newpath.^bestResult.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:25'!elbowc do: [ :aC|		 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:26' prior: 35614655!elbow|bestK count|count := 0.c do: [ :aC|		 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:26' prior: 35614788!elbow|bestK count|count := 0.c do: [ :aC|	count := count +1.	 ].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:27' prior: 35614947!elbow|bestK count|count := 0.c do: [ :aC|].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:29' prior: 35615124!elbow|bestK count|count := 0.c do: [ :aC|count := count +1.].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:29' prior: 35615279!elbow|bestK count|bestK := 0.count := 0.c do: [ :aC|count := count +1.].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:30' prior: 35615452!elbow|bestK count|bestK := 0.count := 0.c do: [ :aC|count := count +1.(count =1 and count => c size)ifFalse: [ 			 ].].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:33' prior: 35615639!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.(count =1 and count => c size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	 ].].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:39' prior: 35615875!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.(count =1 and count => c size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > b*a ) ifTrue: [ ^ count].	 ].].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:39' prior: 35616214!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.(count =1 and count => c size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > b*a ) ifTrue: [ ^ count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:39' prior: 35613672!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^ self elbow.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:40' prior: 35616967!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:41' prior: 35616586!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )and: (count => c) size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > b*a ) ifTrue: [ ^ count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:41' prior: 35618952!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )and: (count >= c) size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > b*a ) ifTrue: [ ^ count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:42' prior: 35619338!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )and: (count >= c) size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*a) ) ifTrue: [ ^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:42' prior: 35619724!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )and: (count >= c) size)ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*a) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:45' prior: 35620111!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )and: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*a) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:45' prior: 35620501!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*a) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:47' prior: 35620891!elbow|bestK count alpha|alpha := 0.95.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*alpha) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:48' prior: 35621280!elbow|bestK count alpha|alpha := 0.75.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*alpha) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 16:49' prior: 35621673!elbow|bestK count alpha|alpha := 0.1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*alpha) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:00' prior: 35622066!elbow|bestK count alpha|alpha := 0.99.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*alpha) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:02' prior: 35622458!elbow|bestK count alpha|alpha := 0.5.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a  > (b*alpha) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:03' prior: 35617956!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne -1.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:09' prior: 35622851!elbow|bestK count alpha|alpha := 2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a * alpha > (b) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:09' prior: 35624242!elbow|bestK count alpha|alpha := 5.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a * alpha > (b) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:09' prior: 35624633!elbow|bestK count alpha|alpha := 10.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count) / (c at: count -1).	b := (c at: count +1) / (c at: count).	(a * alpha > (b) ) ifTrue: [ 		^count].	 ].].^c size.! !----SNAPSHOT----2016-07-11T17:10:11.097164+02:00 Pharo4.0.image priorSource: 2058048!!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:20' prior: 35468143!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ].				].	result add: rep.	 ].^result! !!TypeSpecificRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:20' prior: 35625516!reverse: cList|result|result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !TestCase subclass: #AbstractRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Structure-K-means-Tests'!!AbstractRepresentatorTest commentStamp: '<historical>' prior: 0!An AbstractRepresentatorTest is a test class for testing the behavior of AbstractRepresentator!!AbstractRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:28'!testInitCentroidsWithMaxedTo! !TestCase subclass: #AbstractRepresentatorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!!AbstractRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:28'!setUp|vector1 vector2 feature1 feature2 rep| rep := DistanceAllBigRepresentator new.vector1 := LinkedList new.vector2 := LinkedList new.feature1 := Feature new.feature2 := Feature new.testFeature := LinkedList new.feature1 representation: vector1.feature2 representation: vector2.testFeature add: feature1.testFeature add: feature2.vector1 add: 0.vector1 add: 1.vector1 add: 2.vector1 add: 3.vector1 add: 2.vector1 add: 4.vector1 add: 2.vector1 add: 5.vector1 add: 0.vector2 add: 1.vector2 add: 1.vector2 add: 2.vector2 add: 2.vector2 add: 1.vector2 add: 3.vector2 add: 1.vector2 add: 4.testFeature := rep makeFeaturesFrom: testFeature.! !!AbstractRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:30' prior: 35627091!testInitCentroidsWithMaxedTo|c|c := AbstractRepresentator new initCentroids: 3  with: testFeature maxedTo: 6. ! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:33'!longestFeature: aNumberlongestFeature:= aNumber.! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:33'!maxValue: aNumbermaxValue := aNumber.! !!TypeStructureRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:35' prior: 34546273!initCentroids: k with: featureList^super initCentroids: k with: featureList maxedTo: maxValue.! !!WeightInverseRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:35' prior: 35004553!initCentroids: k with: featureList^super initCentroids: k with: featureList maxedTo: maxValue.! !!AbstractRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:37' prior: 35628151!testInitCentroidsWithMaxedTo|c rep2|rep2 := AbstractRepresentator new.rep2 maxValue: 2.rep2 longestFeature: 3.c := rep2 initCentroids: 3  with: testFeature maxedTo: 6.  ! !!AbstractRepresentatorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/11/2016 17:37' prior: 35629108!testInitCentroidsWithMaxedTo|c rep2|rep2 := AbstractRepresentator new.rep2 maxValue: 2.rep2 longestFeature: 3.c := rep2 initCentroids: 3  with: testFeature maxedTo: 6.! !----SNAPSHOT----2016-07-11T18:03:58.803164+02:00 Pharo4.0.image priorSource: 2070880!----SNAPSHOT----2016-07-11T20:10:59.521164+02:00 Pharo4.0.image priorSource: 2075151!!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:12'!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:14' prior: 35629854!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.			collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].	(1 to: collection size) do: [:k|										].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:15' prior: 35630465!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|				(k/number = 1) ifTrue:[						].						].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:15' prior: 35631129!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|				(k/number = 1) ifTrue:[						].						].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:16' prior: 35631845!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		(k/number = 1) ifTrue:[			(1 to: number)do:[:c| 								].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:16' prior: 35632601!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		(k/number = 1) ifTrue:[			(1 to: number)do:[:c|												].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:19' prior: 35633382!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		stream := String String new writeStream.		(k/number = 1) ifTrue:[			(1 to: number)do:[:c|					stream nextPutAll: (collection at: (k-c)).								].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:19' prior: 35634174!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		stream := String String new writeStream.		(k/number = 1) ifTrue:[			(1 to: number)do:[:c|					stream nextPutAll: (collection at: (k-c)).				].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:20'!testcreateTokanizedStatementwithLines|stmt1 stmt2|stmt1 := (testStmts at: 1) list.self assert: (stmt1 at: 1) = '{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.self assert: (stmt1 at: 11) = '}'.stmt2 := (testStmts at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:21' prior: 35085860!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:21' prior: 35636741!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:22' prior: 35637003!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.testStmts2 := stmt createTokanizedStatement: aStream withLines: 2.testStmts3 := stmt createTokanizedStatement: aStream withLines: 2.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:22' prior: 35637317!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3', Character cr asString,  'a . ,1 2 3'.testStmts2 := stmt createTokanizedStatement: aStream withLines: 2.testStmts3 := stmt createTokanizedStatement: aStream withLines: 2.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:22' prior: 35637766!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3', Character cr asString,  'a . ,1 2 3'.testStmts2 := stmt createTokanizedStatement: aStream withLines: 2.testStmts3 := stmt createTokanizedStatement: aStream withLines: 3.! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:22' prior: 35635052!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(1 to: number)do:[:c|					stream nextPutAll: (collection at: (k-c)).				].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:23' prior: 35638896!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|					stream nextPutAll: (collection at: (k-c)).				].			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:25' prior: 35639762!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.				(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|					stream nextPutAll: (collection at: (k-c)).				].			].		newCollection add: stream.		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:31' prior: 35640630!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|					stream nextPutAll: (collection at: (k-c)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:35' prior: 35641527!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|					|n|					n := number - c-					stream nextPutAll: (collection at: (k-c)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:37' prior: 35642421!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|					stream nextPutAll: (collection at: (k-number-c)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:38' prior: 35643346!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -c					stream nextPutAll: (collection at: (k-number-c)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:38' prior: 35644247!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -c					stream nextPutAll: (collection at: (k-c)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:39' prior: 35645175!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -c.				stream nextPutAll: (collection at: (k-n)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:40' prior: 35646096!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				].			newCollection add: stream.			].		].	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:42' prior: 35647017!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				].			newCollection add: stream.			].		].	(collection size / number = 1) ifFalse: [ 						].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:44' prior: 35647940!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (collection size-n)).							newCollection add: stream.			].				].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:45' prior: 35648920!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (collection size-n)).							newCollection add: stream.			].				].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:46' prior: 35650093!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).							newCollection add: stream.			].				].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:46' prior: 35651282!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			newCollection add: stream.			].				].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:47' prior: 35652471!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:47' prior: 35653655!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.		(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 20:48' prior: 35654837!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k/number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:07' prior: 35638333!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3', Character cr asString,  'a . ,1 2 3'.testStmts2 := stmt createTokanizedStatement: aStream withLines: 2.testStmts3 := stmt createTokanizedStatement: aStream withLines: 3.testStmts3 := stmt createTokanizedStatement: aStream withLines: 4.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:08' prior: 35635913!testcreateTokanizedStatementwithLines|stmt1 stmt2|stmt1 := (testStmts2 at: 1) list.self assert: (stmt1 at: 1) = '{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.self assert: (stmt1 at: 11) = '}'.self assert: (stmt1 at: 12) = 'a'.self assert: (stmt1 at: 13) = '.'.self assert: (stmt1 at: 14) = ','.self assert: (stmt1 at: 15) = '1'.self assert: (stmt1 at: 16) = '2'.self assert: (stmt1 at: 17) = '3'.stmt2 := (testStmts2 at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:09' prior: 35657229!setUp|aStream stmt|aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3'.stmt := NewLineStatementmaker new.testStmts := stmt createTokanizedStatement: aStream.aStream := '{asd 11 1a  a1 a1a 1a1 ab c}}', Character cr asString, 'a . ,1 2 3', Character cr asString,  'a . ,1 2 3'.testStmts2 := stmt createTokanizedStatement: aStream withLines: 2.testStmts3 := stmt createTokanizedStatement: aStream withLines: 3.testStmts4 := stmt createTokanizedStatement: aStream withLines: 4.! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:13' prior: 35656021!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % number = 1) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:14' prior: 35659534!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % number = 0) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size / number = 1) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:15' prior: 35660740!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % number = 0) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % number = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).					].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:17' prior: 35661946!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := LinkedList new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % number = 0) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % number = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmakerTest methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:17' prior: 35657863!testcreateTokanizedStatementwithLines|stmt1 stmt2|stmt1 := (testStmts2 at: 1) list.self assert: (stmt1 at: 1) = '{'.self assert: (stmt1 at: 2) = 'asd'.self assert: (stmt1 at: 3) = '11'.self assert: (stmt1 at: 4) = '1a'.self assert: (stmt1 at: 5) = 'a1'.self assert: (stmt1 at: 6) = 'a1a'.self assert: (stmt1 at: 7) = '1a1'.self assert: (stmt1 at: 8) = 'ab'.self assert: (stmt1 at: 9) = 'c'.self assert: (stmt1 at: 10) = '}'.self assert: (stmt1 at: 11) = '}'.self assert: (stmt1 at: 12) = 'a'.self assert: (stmt1 at: 13) = '.'.self assert: (stmt1 at: 14) = ','.self assert: (stmt1 at: 15) = '1'.self assert: (stmt1 at: 16) = '2'.self assert: (stmt1 at: 17) = '3'.stmt2 := (testStmts2 at: 2) list.self assert: (stmt2 at: 1) = 'a'.self assert: (stmt2 at: 2) = '.'.self assert: (stmt2 at: 3) = ','.self assert: (stmt2 at: 4) = '1'.self assert: (stmt2 at: 5) = '2'.self assert: (stmt2 at: 6) = '3'.! !----SNAPSHOT----2016-07-11T21:21:51.013164+02:00 Pharo4.0.image priorSource: 2075238!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:43' prior: 35625024!elbow|bestK count alpha|alpha := 10.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (c at: count +1) / (c at: count).	(a * alpha > (b) ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:44' prior: 35665475!elbow|bestK count alpha|alpha := -0.1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/11/2016 21:46' prior: 35665870!elbow|bestK count alpha|alpha := -0.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !----QUIT----2016-07-11T21:54:10.702164+02:00 Pharo4.0.image priorSource: 2110852!----STARTUP----2016-07-12T10:33:32.219595+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distRep weigthRep multiline'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/12/2016 10:34'!multiline: aNumbermultiline := aNumber.! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:35' prior: 35576102!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: multiline.	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:37' prior: 35667162!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'java'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'java'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:37' prior: 35611615!analyze|fileHandler perfectResult cPerfekt cbestResult bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult)with:  (perfectResult at:2) size.	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult)with:  (bestResult at:2) size.	res add: cPerfekt.	res add: cbestResult.	^res! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:38'!multiline: aNumbermultiline := aNumber.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:38' prior: 35623243!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC bestResult statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		(aC < bestC ) ifTrue: [ 			bestC:= aC.			bestResult := result.						]	 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne -1.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/12/2016 10:38' prior: 35559933!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !----SNAPSHOT----2016-07-12T10:49:36.581595+02:00 Pharo4.0.image priorSource: 2112104!----SNAPSHOT----2016-07-12T11:00:29.923595+02:00 Pharo4.0.image priorSource: 2119002!----SNAPSHOT----2016-07-12T14:01:55.124595+02:00 Pharo4.0.image priorSource: 2119089!----QUIT----2016-07-12T16:58:54.286595+02:00 Pharo4.0.image priorSource: 2119176!----STARTUP----2016-07-18T20:55:09.672155+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-07-18T22:10:27.072155+02:00 Pharo4.0.image priorSource: 2119263!----STARTUP----2016-07-19T08:41:08.453204+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Object subclass: #Evaluator	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureFinder'!Object subclass: #Evaluator	instanceVariableNames: 'path type'	classVariableNames: ''	category: 'StructureFinder'!!Evaluator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:43'!path: aPathpath := aPath.! !!Evaluator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:43'!type: aTypetype := aType .! !!Evaluator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:43'!run! !!Evaluator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:47'!createResult|fHandler streams statements features featurePerFile result cCount centroids|cCount := 0.features := OrderedCollection new.centroids := OrderedCollection new.result := OrderedCollection new.featurePerFile := OrderedCollection new.statements := OrderedCollection new.fHandler := FileHandler new.streams := fHandler clustersAsStreams: path type: type.streams do:[ :stream| 	statements add: (NewLineStatementmaker new createTokanizedStatement: stream).	]. statements do: [:statementList|	"featurePerFile add: (krunner representator makeFeaturesFrom: statementList)."	  ].featurePerFile do: [ :featureList|	|fCount sum |	fCount :=0.	cCount := cCount +1.	sum := OrderedCollection new.	featureList do: [ :feature| feature klabel: cCount.	features add: feature].	featureList do: [ :feature|				fCount := fCount +1.				sum := Vector sumVec: sum plus: feature representation.		 ].		centroids add: (Vector divide: sum through: fCount).	].result add: features.result add: centroids.^result! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/19/2016 08:48' prior: 35605085!clustersAsStreams: path type: type|projectPath streamList inputLoader|streamList := OrderedCollection new.projectPath := path , '\perfect\',type.inputLoader := FileHandler  new.		(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [					stream nextPutAll: (inputLoader loadFromFile: reference).					streamList add: stream].					].	^streamList.! !Smalltalk globals removeClassNamed: #Evaluator!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:49'!analyzeC|fileHandler perfectResult cPerfekt cbestResult bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult)with:  (perfectResult at:2) size.	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult)with:  (bestResult at:2) size.	res add: cPerfekt.	res add: cbestResult.	^res! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:49'!analyzePositives|fileHandler perfectResult cPerfekt cbestResult bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		cPerfekt := (SqrSumAnalyzer new) analyze: (perfectResult)with:  (perfectResult at:2) size.	cbestResult := (SqrSumAnalyzer new) analyze: (bestResult)with:  (bestResult at:2) size.	res add: cPerfekt.	res add: cbestResult.	^res! !StructureAnalyzer removeSelector: #analyze!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 08:56'!createStatementsLists! !StructureAnalyzer removeSelector: #createStatementsLists!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:06' prior: 35677521!analyzePositives|fileHandler perfectResult   bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		(perfectResult at: 1) do: [:perfectFeature|														 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:07' prior: 35678858!analyzePositives|fileHandler perfectResult   bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		(perfectResult at: 1) do: [:perfectFeature|		(bestResult at: 1) do: [:bestFeature|			(1 to: k)			 ]		 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:08' prior: 35679794!analyzePositives|fileHandler perfectResult   bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		(perfectResult at: 1) do: [:perfectFeature|		(bestResult at: 1) do: [:bestFeature|			(1 to: ((perfectResult at: 2 )size)) do: [ :i|				(1 to: ((perfectResult at: 2 )size)) do: [ :j|									]				 ]			 ]		 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:08' prior: 35680774!analyzePositives|fileHandler perfectResult   bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 		(perfectResult at: 1) do: [:perfectFeature|		(bestResult at: 1) do: [:bestFeature|			(1 to: ((perfectResult at: 2 )size)) do: [ :i|				(1 to: ((perfectResult at: 2 )size)) do: [ :j|										]				 ]			 ]		 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:11' prior: 35681859!analyzePositives|fileHandler perfectResult   bestResult res message|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	self resultToBuckets: perfectResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:11'!resultToBuckets: result.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:12' prior: 35683835!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ 	|list2|	list2 := OrderedCollection new.	1	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:13' prior: 35683971!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ 	|list2|	list2 := OrderedCollection new.	(1 to: (result at: 2) size )do: [ :i|		 ]	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:13' prior: 35684216!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ :feature|	|list2|	list2 := OrderedCollection new.	(1 to: (result at: 2) size )do: [ :i|				 ]	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:14' prior: 35684502!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ :feature|	|list2|	list2 := OrderedCollection new.	(1 to: (result at: 2) size )do: [ :i|		(feature klabel = i) ifTrue: [ list2 add: feature ]		 ]	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:14' prior: 35684800!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ :feature|	|list2|	list2 := OrderedCollection new.	(1 to: (result at: 2) size )do: [ :i|		(feature klabel = i) ifTrue: [ list2 add: feature]		 ]	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:14' prior: 35685149!resultToBuckets: result|list |list := OrderedCollection new.(result at: 1)do: [ :feature|	|list2|	list2 := OrderedCollection new.	(1 to: (result at: 2) size )do: [ :i|		(feature klabel = i) ifTrue: [ list2 add: feature].		 ]	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:15' prior: 35685497!resultToBuckets: result|list |list := OrderedCollection new.(1 to: (result at: 2) size )do: [ :i|	|list2|	list2 := OrderedCollection new.	(result at: 1)do: [ :feature|		(feature klabel = i) ifTrue: [ list2 add: feature].		 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:15' prior: 35685846!resultToBuckets: result|list |list := OrderedCollection new.(1 to: (result at: 2) size )do: [ :i|	|list2|	list2 := OrderedCollection new.	(result at: 1)do: [ :feature|		(feature klabel = i) ifTrue: [ list2 add: feature].		 ].	list add: list.	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:15' prior: 35686197!resultToBuckets: result|list |list := OrderedCollection new.(1 to: (result at: 2) size )do: [ :i|	|list2|	list2 := OrderedCollection new.	(result at: 1)do: [ :feature|		(feature klabel = i) ifTrue: [ list2 add: feature].		 ].	list add: list2.	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:15' prior: 35686564!resultToBuckets: result|list |list := OrderedCollection new.(1 to: (result at: 2) size )do: [ :i|	|list2|	list2 := OrderedCollection new.	(result at: 1)do: [ :feature|		(feature klabel = i) ifTrue: [ list2 add: feature].		 ].	list add: list2.	 ].^list! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:16' prior: 35682945!analyzePositives|fileHandler perfectResult   bestResult res message perfectBucket bestBucket|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBucket := self resultToBuckets: perfectResult.	bestBucket := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:17' prior: 35687306!analyzePositives|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.		perfectBuckets do: [  ]	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:18' prior: 35688302!analyzePositives|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.		perfectBuckets do: [ :bucketi|		bestBuckets do: [ :bucketj|			 ].		].	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:18' prior: 35689329!analyzePositives|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.		perfectBuckets do: [ :bucketi|		bestBuckets do: [ :bucketj|									 ].		].	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 09:29' prior: 35690405!analyzePositives|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.		perfectBuckets do: [ :bucketi|		bestBuckets do: [ :bucketj|			bucketi do: [ :featurei|				bucketj do:[ : featurej|														].			 ].		].	].! !----QUIT----2016-07-19T09:29:13.617204+02:00 Pharo4.0.image priorSource: 2119455!----STARTUP----2016-07-19T14:13:29.21085+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:13'!analyzeVMeasure|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.		perfectBuckets do: [ :bucketi|		bestBuckets do: [ :bucketj|			bucketi do: [ :featurei|				bucketj do:[ : featurej|														].			 ].		].	].! !StructureAnalyzer removeSelector: #analyzePositives!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:15' prior: 35692817!analyzeVMeasure|fileHandler perfectResult   bestResult res message perfectBuckets bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	perfectBuckets := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:16' prior: 35694023!analyzeVMeasure|fileHandler perfectResult   bestResult res message clusters bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	clusters := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:16' prior: 35695022!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes bestBuckets|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	classes := self resultToBuckets: perfectResult.	bestBuckets := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:16' prior: 35696009!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	classes := self resultToBuckets: perfectResult.	clusters := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:17' prior: 35696994!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	clusters := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:17' prior: 35697973!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result."	clusters := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:17' prior: 35699026!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:17' prior: 35700141!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:19' prior: 35701255!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters|message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.		^2*(self homogeneity * self completness)/(self homogeneity + self completness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:20'!homogeneityof: classes and:clusters! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:20'!completenessof: classes and:clusters! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:20' prior: 35702371!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.		^2*(homogeneity * completness)/(homogeneity + completness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:21' prior: 35703829!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity = self homogeneityof: clusters and: classes.	^2*(homogeneity * completness)/(homogeneity + completness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:21' prior: 35705029!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: clusters and: classes.	^2*(homogeneity * completness)/(homogeneity + completness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:22' prior: 35706285!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes and: clusters.	completness:= self completenessof: classes and: clusters.	^2*(homogeneity * completness)/(homogeneity + completness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:22' prior: 35707542!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes and: clusters.	completeness:= self completenessof: classes and: clusters.	^2*(homogeneity * completeness)/(homogeneity + completeness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:23' prior: 35703550!homogeneityof: classes and:clustersclusters do: [ :feature|		 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:25' prior: 35710178!homogeneityof: classes and:clusters(1 to: (clusters size)) do: [ :ki|		 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:26' prior: 35710357!homogeneityof: classes and:clusters(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|		 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:26' prior: 35710546!homogeneityof: classes and:clusters(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|						 ].	 ].! !!StructureAnalyzer commentStamp: 'CedricWalker 7/19/2016 14:26' prior: 0!homogenity calculated from:  V-Measure: A conditional entropy-based external cluster evaluationmeasure!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:28' prior: 35710773!homogeneityof: classes and:clusters(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			self a: (classes at: cj) and: (clusters at: ki)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:28' prior: 35711185!homogeneityof: classes and:clusters|sum|sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			self a: (classes at: cj) and: (clusters at: ki)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:28' prior: 35711466!homogeneityof: classes and:clusters|sum|sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum +self a: (classes at: cj) and: (clusters at: ki)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:28' prior: 35711763!homogeneityof: classes and:clusters|sum|sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + self a: (classes at: cj) and: (clusters at: ki)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:29' prior: 35712072!homogeneityof: classes and:clusters|sum N|sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:30' prior: 35712382!homogeneityof: classes and:clusters|sum N|N := 0.classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:30' prior: 35712699!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in classes"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:30' prior: 35713069!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N)				 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:31' prior: 35713513!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).							 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:36' prior: 35713960!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|CackSum|			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).							 ].	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:36' prior: 35714412!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).							 ].	 ].! !----SNAPSHOT----2016-07-19T14:36:54.59885+02:00 Pharo4.0.image priorSource: 2138101!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:37' prior: 35714877!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 			].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:38' prior: 35715445!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:39' prior: 35715966!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum * (((classes at: cj) and: (clusters at: ki))/ackSumc)		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:39' prior: 35716552!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) "logarithm of that!!"		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:40' prior: 35717199!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:40' prior: 35717868!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:41' prior: 35718539!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	].	sum := 0 - sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:41' prior: 35719217!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]."change sign"	sum := 0 - sum.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:41' prior: 35719912!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]."change sign of sum"	sum := 0 - sum.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:41' prior: 35720623!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:42' prior: 35721341!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	(sum = 0) ifTrue: [ ^1. ].	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:42' prior: 35722060!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	(sum = 0) ifTrue: [ ^1 ].	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:42' prior: 35722807!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ].sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	(sum = 0) ifTrue: [ ^1 ].			! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:43' prior: 35723553!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	(sum = 0) ifTrue: [ ^1 ].			! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:43' prior: 35724303!homogeneityof: classes and:clusters|sum N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"sum := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			sum := sum + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			sum := sum * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	sum := 0 - sum.	(sum = 0) ifTrue: [ ^1 ].	"calculate H(C)"		! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:44' prior: 35725072!homogeneityof: classes and:clusters|hCK N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"		! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:44' prior: 35725857!homogeneityof: classes and:clusters|hCK N|N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"		! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:44' prior: 35726642!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"	^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:44' prior: 35727427!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:44' prior: 35728226!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:45' prior: 35729031!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:45' prior: 35729836!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0."change sign"hC := 0 - hC.^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:46' prior: 35730641!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|		 ]."change sign"hC := 0 - hC.^hCK/hC.	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:48' prior: 35731473!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		].	 ]."change sign"hC := 0 - hC.^hCK/hC.	 ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:49' prior: 35732346!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a		].	 ]."change sign"hC := 0 - hC.^hCK/hC.	 ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:50' prior: 35733284!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	 ]."change sign"hC := 0 - hC.^hCK/hC.	 ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:51' prior: 35734254!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln	 ]."change sign"hC := 0 - hC.^hCK/hC.	 ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:51' prior: 35735265!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^hCK/hC.	 ! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:51'!a:class and: cluster! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:54' prior: 35737412!a:class and: cluster|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi = elementj) ifTrue: [  sum := sum + 1].				].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:54' prior: 35737544!a:class and: cluster|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi = elementj) ifTrue: [  sum := sum + 1].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:57' prior: 35737805!a:class and: cluster|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement= elementj statement) ifTrue: [  sum := sum + 1].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:58' prior: 35738063!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes"|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement= elementj statement) ifTrue: [  sum := sum + 1].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 14:59' prior: 35738340!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement= elementj statement) ifTrue: [  sum := sum + 1].		].	].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:18' prior: 35736346!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln"logarithm of that!!"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^hCK/hC.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:20' prior: 35703681!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:20' prior: 35740225!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ 	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:20' prior: 35740555!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:20' prior: 35740920!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: clusters size)	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:21' prior: 35741289!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:21' prior: 35741681!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:23' prior: 35742092!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		hKC := hKC + (self a: (classes at: ci) and: (clusters at: kj))/ N.		 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:26' prior: 35742506!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + (self a: (classes at: ci) and: (clusters at: kj))/ N.				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:26' prior: 35742986!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj)))/ N.				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:26' prior: 35743497!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:28' prior: 35744010!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (classes size)) do: [ :cj|			ackSumk := ackSumk + self a: (classes at: cj) and: (clusters at: kj).			].				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:28' prior: 35744523!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].				 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:29' prior: 35745151!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:32' prior: 35745780!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. (hKC = 0)ifTrue: [ ^1 ].hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:32' prior: 35746484!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:32' prior: 35747213!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:33' prior: 35747957!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:33' prior: 35748702!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ci|	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:33' prior: 35749455!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ci|		 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:33' prior: 35750247!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ci|		 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:34' prior: 35751041!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ci|	|ackSumC|	ackSumC := 0.	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:35' prior: 35751834!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		 ].	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:35' prior: 35739145!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * (((classes at: cj) and: (clusters at: ki))/ackSumc) ln" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^hCK/hC.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:37' prior: 35752651!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki)		 ].	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:37' prior: 35754588!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:39' prior: 35755516!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + ackSumC/(classes size) + (ackSumC/classes size)ln. 	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:39' prior: 35756445!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) + (ackSumC/classes size)ln). 	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:39' prior: 35753508!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * ((((classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^hCK/hC.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 15:39' prior: 35757438!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^hKC/hK.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:18' prior: 35759515!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:18' prior: 35758433!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + self a:(classes at: ci) and: (clusters at: ki)			].			hCK := hCK * ((((classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:45' prior: 35671671!bestKMean: path from: kOne to: kTwo onType: aType|result  bestC  statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|	|results|	results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		results add:result.					 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne -1.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:45' prior: 35762590!bestKMean: path from: kOne to: kTwo onType: aType|result  bestC  statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|	|results|	results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		results add:result.	 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne -1.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:46' prior: 35763529!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|	|results|	results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^ self elbow + kOne -1.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:46' prior: 35764462!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^ results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:48' prior: 34726230!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, self elbow.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:48' prior: 35766470!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, self elbow asString.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:48' prior: 35767238!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, self elbow asString.fileHandler saveFile: string to: path, fileName.! !Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator loops metric multiline k1 k2'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:50' prior: 35765465!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|k1 := kTwo.k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^ results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:50' prior: 35768966!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^ results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:50' prior: 35672691!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	k1 := k.	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result			! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:51' prior: 35768015!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, (self elbow + k2)asString.fileHandler saveFile: string to: path, fileName.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:52' prior: 35738704!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement= elementj statement) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:52' prior: 35761509!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * ((((classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:53' prior: 35773118!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + (self a: (classes at: cj) and: (clusters at: ki)/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * ((self a:(classes at: cj) and: (clusters at: ki)/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:53' prior: 35774207!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + ((self a: (classes at: cj) and: (clusters at: ki))/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * ((self a:(classes at: cj) and: (clusters at: ki)/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:54' prior: 35775301!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + ((self a: (classes at: cj) and: (clusters at: ki))/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 16:56' prior: 35708858!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes and: clusters.	completeness:= self completenessof: classes and: clusters.	^2*(homogeneity * completeness)/(homogeneity + completeness)! !----SNAPSHOT----2016-07-19T17:06:48.42985+02:00 Pharo4.0.image priorSource: 2160818!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:27' prior: 35769995!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:36' prior: 35771883!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, (self elbow + k2) asString.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:38' prior: 35778905!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.		aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:38' prior: 35780719!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|		results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !----SNAPSHOT----2016-07-19T17:39:03.09985+02:00 Pharo4.0.image priorSource: 2224283!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:45' prior: 35781749!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.(kOne to: kTwo) do: [:k|			results := OrderedCollection new.		result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 17:46' prior: 35782864!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: k to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !----SNAPSHOT----2016-07-19T18:20:49.71985+02:00 Pharo4.0.image priorSource: 2228242!----SNAPSHOT----2016-07-19T19:42:55.70385+02:00 Pharo4.0.image priorSource: 2230389!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:47' prior: 35772671!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement = elementj statement) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer commentStamp: 'CedricWalker 7/19/2016 19:48' prior: 35710972!homogenity and compleetness calculated from:  V-Measure: A conditional entropy-based external cluster evaluationmeasure!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:50' prior: 35776397!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + ((self a: (classes at: cj) and: (clusters at: ki))/ N).			"(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln) base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + self a:(classes at: ci) and: (clusters at: kj).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:52' prior: 35785102!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.cluster do: [ :elementi|	class do: [ :elementj|		(elementi statement = elementj statement) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:57' prior: 35786851!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.cluster do: [ :elementi|	class do: [ :elementj|		(elementi statement list = elementj statement list) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:58' prior: 35785753!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + ((self a: (classes at: cj) and: (clusters at: ki))/ N).			"(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln) base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:58' prior: 35787757!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc|			ackSumc := 0.			hCK := hCK + ((self a: (classes at: cj) and: (clusters at: ki))/ N).			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 19:59' prior: 35787299!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement list = elementj statement list) ifTrue: [  sum := sum + 1].		].	].^sum.! !----SNAPSHOT----2016-07-19T19:59:35.54085+02:00 Pharo4.0.image priorSource: 2230475!!Statement methodsFor: 'accessing' stamp: 'CedricWalker 7/19/2016 20:11' prior: 34426984!initialize	super initialize.	list := OrderedCollection new.! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:11' prior: 35096897!createTokanizedStatement: aStream	|statmentIdentifier  allbutnewline collection statementList|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:12' prior: 35663152!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % number = 0) ifTrue:[			(0 to: number-1)do:[:c|				|n|				n := number -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % number = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!Vector class methodsFor: 'Math' stamp: 'CedricWalker 7/19/2016 20:13' prior: 34551630!divide: sum through: count|list|list := OrderedCollection new.sum do:[:entry| list add: (entry / count)].^list.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:15' prior: 35788857!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:19' prior: 35789957!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|cluster isEmpty ifTrue: [ ^nil ].sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement list = elementj statement list) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:20' prior: 35793787!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|(cluster isEmpty) ifTrue: [ ^nil ].sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement list = elementj statement list) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:20' prior: 35794279!a:class and: cluster"classes and clusters are generatet in resultToBuckets and consist of Feature classes Method calculates numbers of elements a class with are asigned to a cluster"|sum|(cluster isEmpty) ifTrue: [ ^1 ].sum := 0.class do: [ :elementi|	cluster do: [ :elementj|		(elementi statement list = elementj statement list) ifTrue: [  sum := sum + 1].		].	].^sum.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:21' prior: 35760510!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:21' prior: 35795265!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:21' prior: 35796266!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:23' prior: 35792674!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p o|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln).			hCK := hCK * o" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:24' prior: 35798274!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p o|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc)).			hCK := hCK * (o ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:30' prior: 35799400!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.		(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			|p|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.					hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:31' prior: 35800528!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.		(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			|p o|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			o := ((self a:(classes at: cj) and: (clusters at: ki))/ackSumc).			hCK := hCK + p.			hCK := hCK * ( o ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:32' prior: 35797269!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|				ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).				hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:33' prior: 35802779!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.				hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:33' prior: 35803797!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := (self a:(classes at: ci) and: (clusters at: kj) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:34' prior: 35804812!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := (self a:(classes at: ci) and: (clusters at: kj) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:35' prior: 35805837!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := (self a:(classes at: ci) and: (clusters at: kj) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC o|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	o := (ackSumC/(classes size)).	hK := hK + o * (o)ln. 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:36' prior: 35806878!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := (self a:(classes at: ci) and: (clusters at: kj) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC o q|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	o := (ackSumC/(classes size)).	q := o * (o)ln.	hK := hK +  q.	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:37' prior: 35807911!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			|p|			p := self a: (classes at: ci) and: (clusters at: ki).			ackSumk := ackSumk + p.			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := (self a:(classes at: ci) and: (clusters at: kj) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC o q|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	o := (ackSumC/(classes size)).	q := o * (o)ln.	hK := hK +  q.	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:37' prior: 35808955!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			|p|			p := self a: (classes at: ci) and: (clusters at: ki).			ackSumk := ackSumk + p.			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC o q|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	o := (ackSumC/(classes size)).	q := o * (o)ln.	hK := hK +  q.	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:37' prior: 35810017!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|			|p|			p := self a: (classes at: ci) and: (clusters at: ki).			ackSumk := ackSumk + p.			].	(1 to: (clusters size)) do: [ :kj|		|p o|		p := (self a: (classes at: ci) and: (clusters at: kj))/ N.		hKC := hKC + p.		o := ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk).		hKC := hKC *  (o ln).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC o q|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		|p|		p := self a: (classes at: ci) and: (clusters at: ki).		ackSumC := ackSumC + p.		 ].	o := (ackSumC/(classes size)).	q := o * (o)ln.	hK := hK +  q.	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:40' prior: 35801648!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.		(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			|p o|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			o := ((self a:(classes at: cj) and: (clusters at: ki))/ackSumc).			hCK := hCK + p.			hCK := hCK * ( o)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:42' prior: 35811081!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + self a: (classes at: ci) and: (clusters at: ki).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) "ln".		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:44' prior: 35813273!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:44' prior: 35814274!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) "ln".		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:44' prior: 35812145!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) "ln")" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:45' prior: 35815275!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + self a: (classes at: ci) and: (clusters at: ki).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !----SNAPSHOT----2016-07-19T20:45:26.39085+02:00 Pharo4.0.image priorSource: 2235874!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:45' prior: 35817393!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !----SNAPSHOT----2016-07-19T20:45:35.01685+02:00 Pharo4.0.image priorSource: 2263853!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:46' prior: 35818480!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * (self a:(classes at: ci) and: (clusters at: kj)) / ackSumk "ln".		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !----QUIT----2016-07-19T20:46:33.65385+02:00 Pharo4.0.image priorSource: 2264942!----STARTUP----2016-07-19T20:47:14.070406+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:47' prior: 35819569!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) "ln".		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:50' prior: 35820765!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !----SNAPSHOT----2016-07-19T20:51:13.019406+02:00 Pharo4.0.image priorSource: 2266033!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:52' prior: 35816278!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p o|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (self a:(classes at: cj) and: (clusters at: ki)).			hCK := hCK * ackSumc." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:52' prior: 35822864!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p o q|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * ackSumc." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:53' prior: 35823982!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p o q|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T20:53:12.191406+02:00 Pharo4.0.image priorSource: 2268236!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:53' prior: 35825121!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T20:53:35.499406+02:00 Pharo4.0.image priorSource: 2271718!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:53' prior: 35826346!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.						o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:53' prior: 35827577!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.						o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:53' prior: 35828723!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.						o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T20:53:56.447406+02:00 Pharo4.0.image priorSource: 2272949!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:54' prior: 35829866!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).						o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK * (q ln)." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:54' prior: 35831096!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| p o q|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).						o := (self a:(classes at: cj) and: (clusters at: ki)).			q := o/ackSumc.			hCK := hCK + (p * (q ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:56' prior: 35832220!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| ack|						ack := ((self a: (classes at: cj) and: (clusters at: ki))).						hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:56' prior: 35833350!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:57' prior: 35834416!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|			ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).		].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk |	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a:(classes at: ci) and: (clusters at: kj)).		ackSumk := ackSumk + ack.		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:58' prior: 35835474!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		|ack|		ack := self a:(classes at: ci) and: (clusters at: ki).			ackSumc := ackSumc + ack.		].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk |	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a:(classes at: ci) and: (clusters at: kj)).		ackSumk := ackSumk + ack.		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:58' prior: 35836555!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		|ack|		ack := self a:(classes at: ci) and: (clusters at: ki).		ackSumc := ackSumc + ack.	].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk |	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a:(classes at: ci) and: (clusters at: kj)).		ackSumk := ackSumk + ack.		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T20:58:45.656406+02:00 Pharo4.0.image priorSource: 2276468!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 20:59' prior: 35837656!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc|	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		|ack|		ack := self a:(classes at: ci) and: (clusters at: ki).		ackSumc := ackSumc + ack.	].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + (ack/N * ((ack/ackSumc) ln))." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk |	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a:(classes at: ci) and: (clusters at: kj)).		ackSumk := ackSumk + ack.		].	hC := hC + (ackSumk / (classes size)) * ((ackSumk / (classes size))ln).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T20:59:13.225406+02:00 Pharo4.0.image priorSource: 2284214!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:02'!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	(1 to:(classes size)) do: [ :cj|			|ackSumc p|			ackSumc := 0.			p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.			(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].			hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:02' prior: 35840014!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| p|						p := ((self a: (classes at: cj) and: (clusters at: ki))/ N).			hCK := hCK + p.						hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:02' prior: 35841126!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))/ N).						hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:03' prior: 35842247!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).						hCK := hCK * (((self a:(classes at: cj) and: (clusters at: ki))/ackSumc) ln)" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:03' prior: 35843349!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).						hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T21:03:43.141406+02:00 Pharo4.0.image priorSource: 2285402!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:03' prior: 35844448!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			| ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:03' prior: 35845601!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|				 ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).			].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:04'!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	(1 to: (clusters size)) do: [ :kj|		|ackSumk|		ackSumk := 0.		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).		(1 to: (clusters size)) do: [ :ki|			ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).			].		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:05' prior: 35846663!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + (ackSumk / (classes size)) * (ackSumk / (classes size))ln.	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:05' prior: 35848712!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / (classes size)) * (ackSumk / (classes size))ln).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:06' prior: 35849768!homogeneityof: classes nd:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:06' prior: 35838842!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:08' prior: 35847708!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|				hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).				hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:08' prior: 35852935!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		hKC := hKC + ((self a: (classes at: ci) and: (clusters at: kj))/ N).				hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:10' prior: 35853940!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).				hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !----SNAPSHOT----2016-07-19T21:11:29.611406+02:00 Pharo4.0.image priorSource: 2290973!----SNAPSHOT----2016-07-19T21:12:04.162406+02:00 Pharo4.0.image priorSource: 2301400!----SNAPSHOT----2016-07-19T21:12:27.956406+02:00 Pharo4.0.image priorSource: 2301487!----SNAPSHOT----2016-07-19T21:16:17.021406+02:00 Pharo4.0.image priorSource: 2301574!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:35' prior: 35854942!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC * ((self a:(classes at: ci) and: (clusters at: kj)) / ackSumk) ln.		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:36' prior: 35856289!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + (ack/N) * (ack/ackSumk).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:37' prior: 35857285!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + ((ack/N) * ((ack/ackSumk)ln)).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC|	ackSumC := 0.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:37' prior: 35858241!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + ((ack/N) * ((ack/ackSumk)ln)).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(classes size) * (ackSumC/classes size)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:37' prior: 35859203!completenessof: classes nd:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + ((ack/N) * ((ack/ackSumk)ln)).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:37' prior: 35821772!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + ((ack/N) * ((ack/ackSumk)ln)).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 21:40' prior: 35851880!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))" base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.		"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !----SNAPSHOT----2016-07-19T21:41:10.691406+02:00 Pharo4.0.image priorSource: 2301661!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 22:03' prior: 35862112!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			(ack = 0) ifFalse: [hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))]." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.		"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 22:04' prior: 35863229!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			(ack = 0) ifFalse: [hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))]." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 22:04' prior: 35861149!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		(ack = 0 )ifFalse: [hKC := hKC + ((ack/N) * ((ack/ackSumk)ln))].		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].^1-(hKC/hK).! !----SNAPSHOT----2016-07-19T22:58:52.574406+02:00 Pharo4.0.image priorSource: 2308601!----QUIT----2016-07-19T23:01:57.250406+02:00 Pharo4.0.image priorSource: 2311801!----STARTUP----2016-07-19T23:16:25.612576+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 23:16' prior: 35864281!homogeneityof: classes and:clusters|hCK N hC |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(C|K)"hCK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumc |	ackSumc := 0.	(1 to:(classes size)) do: [ :ci|		ackSumc := ackSumc + (self a:(classes at: ci) and: (clusters at: ki)).	].	(1 to:(classes size)) do: [ :cj|			|ack|			ack := ((self a: (classes at: cj) and: (clusters at: ki))).			(ack = 0) ifFalse: [hCK := hCK + ((ack/N) * ((ack/ackSumc) ln))]; ifTrue:[				hCK := hCK + ((1/N) * ((1/ackSumc) ln))				]." base of logarithm?"		].	]. "change sign of sum"	hCK := 0 - hCK.	(hCK = 0) ifTrue: [ ^1 ].	"calculate H(C)"hC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk n|	n := classes size.	ackSumk :=0.	(1 to: (clusters size)) do: [ :kj|		ackSumk := ackSumk + (self a:(classes at: ci) and: (clusters at: kj)).		].	hC := hC + ((ackSumk / n * (ackSumk / n)ln)).	 ]."change sign"hC := 0 - hC.^1-(hCK/hC).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 23:17' prior: 35865358!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		(ack = 0 )ifFalse: [hKC := hKC + ((ack/N) * ((ack/ackSumk)ln))] ifTrue:[			hKC := hKC + ((1/N) * ((1/ackSumk)ln))			].		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/19/2016 23:19' prior: 35867758!completenessof: classes and:clusters|hKC N hK |N := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| N := N + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		(ack = 0 )ifFalse: [hKC := hKC + ((ack/N) * ((ack/ackSumk)ln))] ifTrue:[			hKC := hKC + ((1/N) * ((1/ackSumk)ln))			].		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].hK:=0-hK.^1-(hKC/hK).! !----QUIT----2016-07-19T23:30:28.357576+02:00 Pharo4.0.image priorSource: 2311888!----STARTUP----2016-07-20T17:14:14.744995+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:14' prior: 35860187!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."calculate H(K|C)"hKC :=0.(1 to: (classes size)) do: [ :ci|	|ackSumk|	ackSumk := 0.	(1 to: (clusters size)) do: [ :ki|		ackSumk := ackSumk + (self a: (classes at: ci) and: (clusters at: ki)).	].		(1 to: (clusters size)) do: [ :kj|		|ack|		ack := (self a: (classes at: ci) and: (clusters at: kj)).		hKC := hKC + ((ack/n) * ((ack/ackSumk)ln)).		 ].	 ]. hKC := 0-hKC.(hKC = 0)ifTrue: [ ^1 ].hK := 0.(1 to: (clusters size)) do: [ :ki|	|ackSumC n|	ackSumC := 0.	n := classes size.	(1 to:(classes size)) do: [ :ci|		ackSumC := ackSumC + (self a: (classes at: ci) and: (clusters at: ki)).		 ].	hK := hK + (ackSumC/(n) * (ackSumC/n)ln). 	 ].^1-(hKC/hK).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:17' prior: 35870040!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hKC :=0.hK := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:18' prior: 35850826!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:35' prior: 35871426!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"(1 to:(classes size)) do: [ :ci|		 ].hCK :=0.hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:35' prior: 35871849!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.(1 to:(classes size)) do: [ :ci|		 ].hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:35' prior: 35872313!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|				].	].hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:38' prior: 35872778!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		hCK := hCK + ( (nck/n)*((nck/nk)ln)  ).		].	].hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:38' prior: 35873286!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		hCK := hCK + ( (nck/n)*((nck/nk)ln) ).		].	].hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:38' prior: 35873929!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		hCK := hCK + ( (nck/n)*((nck/nk)ln)).		].	].hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:38' prior: 35874571!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		hCK := hCK + ( (nck/n)*((nck/nk)ln)).		].	].hCK := hCK * (-1).hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:39' prior: 35875212!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))].		].	].hCK := hCK * (-1).hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:39' prior: 35875871!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:41' prior: 35876552!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ 	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:41' prior: 35877266!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	 ].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:41' prior: 35878015!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|		 ].hC := hC * (-1).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:42' prior: 35878768!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	 ].hC := hC * (-1).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:43' prior: 35879540!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:43' prior: 35880346!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:44' prior: 35881184!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:44' prior: 35882084!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:46' prior: 35871002!completenessof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:46' prior: 35883957!completenessof: classes nd:clusters|hKC n hC |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:46' prior: 35884924!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj).		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hK := hK + ((nc/n)*((nc/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:46' prior: 35885891!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nc|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nc := (clusters at: kj).		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hK := hK + ((nc/n)*((nc/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:47' prior: 35886858!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nc|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nc := (clusters at: kj).		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (classes size)) do: [ :ci|	|nk|	nk := (classes at: ci) size.	hK := hK + ((nk/n)*((nk/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:48' prior: 35887825!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj).		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (classes size)) do: [ :ci|	|nk|	nk := (classes at: ci) size.	hK := hK + ((nk/n)*((nk/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:48' prior: 35888792!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (classes size)) do: [ :ci|	|nk|	nk := (classes at: ci) size.	hK := hK + ((nk/n)*((nk/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:48' prior: 35883015!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj) size.		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:50' prior: 35889759!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	hK := hK + ((nk/n)*((nk/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:50' prior: 35891678!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	hK := hK + ((nk/n)*((nk/n)ln)).	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[	^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:50' prior: 35890731!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj) size.		( nck = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[	^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:55' prior: 35777495!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness |message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	^2*(homogeneity * completeness)/(homogeneity + completeness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:56' prior: 35893628!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj) size.		( nck = 0 or: nk = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[	^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 17:59' prior: 35895904!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj) size.		( nck = 0 or: nk = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[	^1-(hCK/hC)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 18:02' prior: 35892652!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	(nk = 0) ifFalse: [hK := hK + ((nk/n)*((nk/n)ln))].	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[	^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 18:02' prior: 35897824!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	(nk = 0) ifFalse: [hK := hK + ((nk/n)*((nk/n)ln))];ifTrue:[		hK := hK +0.		].	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[	^1-(hKC/hK)].! !----SNAPSHOT----2016-07-20T19:27:28.946995+02:00 Pharo4.0.image priorSource: 2315307!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 20:18' prior: 35898820!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (clusters at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	(nk = 0) ifFalse: [		hK := hK + ((nk/n)*((nk/n)ln))];ifTrue:[		hK := hK +0.		].	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[	^1-(hKC/hK)].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/20/2016 20:27' prior: 35899931!completenessof: classes nd:clusters|hKC n hK |n := 0."N = Number of all data points i Name already defined ->s equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hKC :=0.	(1 to:(clusters size)) do: [ :ki|		(1 to:(classes size)) do: [ :cj|		|nck nc|		nck := self a: (classes at: cj) and: (clusters at: ki). 		nc := (classes at: cj) size.		( nck = 0) ifFalse: [hKC := hKC + ( (nck/n)*((nck/nc)ln))];ifTrue:[			hKC := hKC + 0.			].		].	].hKC := hKC * (-1).hK := 0.(1 to: (clusters size)) do: [ :ki|	|nk|	nk := (clusters at: ki) size.	(nk = 0) ifFalse: [		hK := hK + ((nk/n)*((nk/n)ln))];ifTrue:[		hK := hK +0.		].	].hK := hK * (-1).(hKC=0)ifTrue:[^1];ifFalse:[	^1-(hKC/hK)].! !----QUIT----2016-07-20T23:08:31.193995+02:00 Pharo4.0.image priorSource: 2345303!----STARTUP----2016-07-21T13:39:32.454853+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 14:59' prior: 35896864!homogeneityof: classes nd:clusters|hCK n hC |n := 0."N = Number of all data points is equal to number of elements in each class"classes do: [:class| n := n + class size ]."n := number of samples""nc = number of samples in class c""nk = number of samples in cluster k""nck = number of samlples in class c associatet to cluster k""calculate H(K|C)"hCK :=0.	(1 to:(classes size)) do: [ :ci|		(1 to:(clusters size)) do: [ :kj|		|nck nk|		nck := self a: (classes at: ci) and: (clusters at: kj). 		nk := (clusters at: kj) size.		( nck = 0 or: nk = 0) ifFalse: [hCK := hCK + ( (nck/n)*((nck/nk)ln))];ifTrue:[			hCK := hCK + 0.			].		].	].hCK := hCK * (-1).hC := 0.(1 to: (classes size)) do: [ :ci|	|nc|	nc := (classes at: ci) size.	hC := hC + ((nc/n)*((nc/n)ln)).	].hC := hC * (-1).(hCK=0)ifTrue:[^1];ifFalse:[	^1-(hCK/hC)].! !----SNAPSHOT----2016-07-21T15:43:28.720853+02:00 Pharo4.0.image priorSource: 2347443!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:11'!nearestStatementsFromCentroids: result(result at:1)do:[	(result at:2) do:[						].	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:12' prior: 35903202!nearestStatementsFromCentroids: result|features centroids list|list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[		(result at:2) do:[						].	].! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:13' prior: 35903400!nearestStatementsFromCentroids: result|features centroids list|list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[		(result at:2) do:[						].	].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:13' prior: 35903706!nearestStatementsFromCentroids: result|features centroids list nearest|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[		(features) do:[						].	].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:15' prior: 35904019!nearestStatementsFromCentroids: result|features centroids list nearest|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min. ].		].	].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:16' prior: 35904361!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].		].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:16' prior: 35904847!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature 	].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:16' prior: 35905379!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:21'!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature.	].^list.! !KMeansRunner removeSelector: #nearestStatementsFromCentroids:!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:22' prior: 35894577!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	^2*(homogeneity * completeness)/(homogeneity + completeness)! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:23' prior: 35907098!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	2*(homogeneity * completeness)/(homogeneity + completeness).	! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:25' prior: 35908472!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes ', completeness asString, Character cr asString.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:25' prior: 35909855!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes ', completeness asString, Character cr asString.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:25' prior: 35911390!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:26' prior: 35912946!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.	(self nearestStatementsFromCentroids: bestResult) do: [:statement|].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:27' prior: 35914580!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure nearestStatments|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.	nearestStatments := self nearestStatementsFromCentroids: bestResult.	(nearestStatments) do: [:statement|].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:28' prior: 35916284!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure nearestStatments|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.	nearestStatments := self nearestStatementsFromCentroids: bestResult.	(nearestStatments) do: [:statement| string := string, statement asString, Character cr asString].! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:29' prior: 35918044!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure nearestStatments|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.	nearestStatments := self nearestStatementsFromCentroids: bestResult.	(nearestStatments) do: [:statement| string := string, statement asString, Character cr asString].	string := string,  'best K: ', (nearestStatments size) asString, Character cr asString! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 17:29' prior: 35919864!analyzeVMeasure|fileHandler perfectResult   bestResult res message classes clusters homogeneity completeness resultList string vmeasure nearestStatments|resultList := OrderedCollection new.message := ''.	res := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.		perfectResult := self createResult.	"mode?"	bestResult := krunner bestKMean: path from: k2 to: k onType: aType. 	"classes are the prelabeled featuters manually out togehter in \perfect"	classes := self resultToBuckets: perfectResult.	"clustsers are the labeld features of the generatet result"	clusters := self resultToBuckets: bestResult.	homogeneity := self homogeneityof: classes nd: clusters.	completeness:= self completenessof: classes nd: clusters.	vmeasure := 2*(homogeneity * completeness)/(homogeneity + completeness).	string := 'homogenity: ', homogeneity asString, Character cr asString.	string := string,  'completenes: ', completeness asString, Character cr asString.	string := string,  'v-measure: ', vmeasure asString, Character cr asString.	nearestStatments := self nearestStatementsFromCentroids: bestResult.	(nearestStatments) do: [:statement| string := string, statement asString, Character cr asString].	string := string,  'best K: ', (nearestStatments size) asString, Character cr asString.	^string.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:30' prior: 35906472!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(centroids)do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature statement.	].^list.! !!Statement methodsFor: 'accessing' stamp: 'CedricWalker 7/21/2016 17:32'!asString	|string|	string := ''.	list do:  [ :token| string := string, token asString, ' ']! !!Statement methodsFor: 'accessing' stamp: 'CedricWalker 7/21/2016 17:32' prior: 35924219!asString	|string|	string := ''.	list do:  [ :token| string := string, token asString, ' '].	^string.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:34' prior: 35923681!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :centroid|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: centroid. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:34' prior: 35924612!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: c. 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:34' prior: 35925187!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:34' prior: 35925748!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		(feature klabel =c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 		(min < nearest) ifTrue: [ nearest := min.			nearestFeature := feature ].		].	].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:34' prior: 35926324!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		(feature klabel =c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [ nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:35' prior: 35926935!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		(feature klabel =c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:35' prior: 35927550!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|nearest := 99999999999.list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	(features) do:[:feature|		(feature klabel = c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:36' prior: 35928169!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	nearest := 99999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:39' prior: 35928789!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	nearest := 99999999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:40' prior: 35929411!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[		min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:45' prior: 35930042!nearestStatementsFromCentroids: result|features centroids list nearest nearestFeature|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min|	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:46' prior: 35930668!nearestStatementsFromCentroids: result|features centroids list nearest|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|min nearestFeature|	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			min := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(min < nearest) ifTrue: [				nearest := min.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:46' prior: 35931295!nearestStatementsFromCentroids: result|features centroids list nearest|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:46' prior: 35931922!nearestStatementsFromCentroids: result|features centroids list nearest|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	list add: nearestFeature statement.	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:54' prior: 35932541!nearestStatementsFromCentroids: result|features centroids list nearest|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	(nearestFeature = nil) isTrue: [list add: nearestFeature statement].	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'CedricWalker 7/21/2016 17:55' prior: 35933184!nearestStatementsFromCentroids: result|features centroids list nearest|list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 18:11' prior: 35666255!elbow|bestK count alpha|alpha := -0.15.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 19:45' prior: 35934577!elbow|bestK count alpha|alpha := -0.1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 19:46' prior: 35934963!elbow|bestK count alpha|alpha := -0.25.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 19:52' prior: 35935348!elbow|bestK count alpha|alpha := -0.3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 19:54' prior: 35935734!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 20:12' prior: 35936119!elbow|bestK count alpha|alpha := -0.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:22'!crossLanguageComparison: path types: types withk: k! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:24' prior: 35936883!crossLanguageComparison: path types: types withk: k|list|types do: [ :typeA|	types do: [ :typeB|						 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:26' prior: 35937051!crossLanguageComparison: path types: types withk: k||types do: [ :typeA|	types do: [ :typeB|				 |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:26' prior: 35937283!crossLanguageComparison: path types: types withk: ktypes do: [ :typeA|	types do: [ :typeB|				 |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:26' prior: 35938259!crossLanguageComparison: path types: types withk: k|list|types do: [ :typeA|	list := OrderedCollection new.	types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:27' prior: 35939232!crossLanguageComparison: path types: types withk: k|list|types do: [ :typeA|	list := OrderedCollection new.	list add: typeA.	types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:29' prior: 35940238!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.	list add: typeA.		types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					typeList add: (1-(percentage / featureList size))" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:29' prior: 35941262!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					typeList add: (1-(percentage / featureList size))" < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:30' prior: 35942351!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ]	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:30' prior: 35943424!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ].	typeList add:list.	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:34' prior: 35944517!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ].	typeList add:list.	].^typeList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:38' prior: 35945631!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|			|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.	featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ].	typeList add:list.	].^typeList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 21:38' prior: 35946756!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list|	list := OrderedCollection new.			types do: [ :typeB|		|bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.	featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ].	typeList add:list.	].^typeList.! !----SNAPSHOT----2016-07-21T21:41:28.152853+02:00 Pharo4.0.image priorSource: 2348595!!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 22:35' prior: 35791260!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % number = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 22:35' prior: 35949071!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 22:36' prior: 35554007!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	loops ifNil: [ iterations := 50. ].	(1 to:loops) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].				(metric = 3)ifTrue:[d := Vector advancedFeatureDistanceFrom: (centroids at:aC) to: feature representation].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/21/2016 22:36' prior: 35951514!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].				(metric = 3)ifTrue:[d := Vector advancedFeatureDistanceFrom: (centroids at:aC) to: feature representation].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !----QUIT----2016-07-21T22:51:45.190853+02:00 Pharo4.0.image priorSource: 2394439!----STARTUP----2016-07-22T10:19:28.787458+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:30' prior: 35947871!crossLanguageComparison: path types: types withk: k|typeList|typeList := OrderedCollection new.types do: [ :typeA|	|list bestResult|	list := OrderedCollection new.	bestResult := krunner bestKMean: (path, '\compare\training' )from:  (k/2) floor to: k onType: typeA.		types do: [ :typeB|		| radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (path, '\compare\test') type: typeB.	featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					list add: typeA, typeB, (1-(percentage / featureList size)) asString." < threshold". "percentage should be high for same language and low for different langague "		 ].	typeList add:list.	].^typeList.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:33' prior: 35954359!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType|kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path from: k/2 to: k onType: type).	 ].types do: [  ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:34' prior: 35955474!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType|resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path from: k/2 to: k onType: type).	 ].types do: [  :type|			].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:35' prior: 35955828!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType|resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path from: k/2 to: k onType: type).	 ].kmeansList do: [ :result|	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:37' prior: 35956235!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:37' prior: 35956646!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|			 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:37' prior: 35957205!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	streams do: [ :stream|				 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:38' prior: 35957768!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	streams do: [ :stream|		|radiusList|		radiusList := self calcRadiusListfrom: result.				 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:40' prior: 35958360!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].					 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:40' prior: 35959016!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			1-(percentage / featureList size).		 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:41' prior: 35959968!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	resultsPerType := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			1-(percentage / featureList size).		 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:42' prior: 35960954!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			1-(percentage / featureList size).		 ].	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:42' prior: 35961942!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:42' prior: 35962968!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (self krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 10:44' prior: 35964032!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/22/2016 10:54' prior: 34650475!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |newpath := path, '\' , k asString.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',(c floor)asString, '.txt'.	].! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 11:01' prior: 35950299!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr:=number.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 11:02' prior: 35952833!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].				(metric = 3)ifTrue:[d := Vector advancedFeatureDistanceFrom: (centroids at:aC) to: feature representation].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/22/2016 11:08' prior: 35966164!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |newpath := path, '\' , (k floor )asString.(1 to:k) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',(c floor)asString, '.txt'.	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 11:40' prior: 35965112!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].				].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:39' prior: 35970498!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams|streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:40' prior: 35971578!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:40' prior: 35972652!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list|	type1count := type1count +1.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:40' prior: 35973753!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:41' prior: 35974884!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.				radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:41' prior: 35976044!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:41' prior: 35977237!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)), (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:47' prior: 35978428!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)), (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 12:48' prior: 35979666!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)) asString, (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 13:53' prior: 35668748!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: 'type'. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: 'type'.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 13:54' prior: 35982154!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/22/2016 14:08' prior: 35779935!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, (self elbow + k2 -1) asString.fileHandler saveFile: string to: path, fileName.! !----STARTUP----2016-07-25T14:17:40.588118+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:18' prior: 35779935!saveConfig: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, (self elbow + k2-1) asString.fileHandler saveFile: string to: path, fileName.! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:20' prior: 35668748!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentator) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:21' prior: 35947871!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: k/2 to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)) asString, (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:25' prior: 35783894!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: (k floor)to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !----SNAPSHOT----2016-07-25T14:43:00.196118+02:00 Pharo4.0.image priorSource: 2399621!----QUIT----2016-07-25T14:46:02.521118+02:00 Pharo4.0.image priorSource: 2436645!----STARTUP----2016-07-25T14:46:17.691161+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:47' prior: 35990143!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: (k)to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !!FileHandler methodsFor: 'loading' stamp: 'CedricWalker 7/25/2016 14:48' prior: 34650475!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp"| aStream newpath |newpath := path, '\' , k asString.(1 to:k floor) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',(c floor) asString, '.txt'.	].! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:51' prior: 35988903!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: (k/2) floor to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)) asString, (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 14:51' prior: 35993369!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new.types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: ((k/2) floor) to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)) asString, (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !----SNAPSHOT----2016-07-25T14:58:26.776161+02:00 Pharo4.0.image priorSource: 2436732!!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 16:41' prior: 35950299!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 16:42' prior: 35952833!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	loops ifNil: [ iterations := 50. ].	iterations := loops.	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation. "TODO imp. distanceFrom"				(metric = 2)ifTrue:[d := Vector featureDistanceFrom: (centroids at:aC) to: feature representation.].				(metric = 3)ifTrue:[d := Vector advancedFeatureDistanceFrom: (centroids at:aC) to: feature representation].								(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!TypeStructureRepresentator methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 17:35' prior: 34697074!asString	^'Type Structure Representator'! !AbstractRepresentator subclass: #WeightSumFirstRepresentor	instanceVariableNames: ''	classVariableNames: ''	category: 'Structure-K-means'!!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 17:36'!asString^'Weight Sum First Representor'.! !TestCase subclass: #WeightSumFirstRepresentatorTest	instanceVariableNames: 'testFeature'	classVariableNames: ''	category: 'StructureTests'!!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:54'!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !TestCase subclass: #WeightSumFirstRepresentorTest	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'Structure-K-means-Tests'!!WeightSumFirstRepresentorTest commentStamp: '<historical>' prior: 0!A WeightSumFirstRepresentorTest is a test class for testing the behavior of WeightSumFirstRepresentor!!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:54'!testMakeFeaturesFrom! !TestCase subclass: #WeightSumFirstRepresentorTest	instanceVariableNames: ''	classVariableNames: ''	category: 'StructureTests'!Smalltalk globals removeClassNamed: #WeightSumFirstRepresentatorTest!!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:55'!setUp.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:55' prior: 36000343!setUp|featureList f1 f2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:56' prior: 36000479!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:57' prior: 36000712!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:57' prior: 36001106!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.f1 representation: rep1.f2 representation: rep2.featureList add: f1.featureList add: f2.! !TestCase subclass: #WeightSumFirstRepresentorTest	instanceVariableNames: 'restFeatures'	classVariableNames: ''	category: 'StructureTests'!TestCase subclass: #WeightSumFirstRepresentorTest	instanceVariableNames: 'testFeatures'	classVariableNames: ''	category: 'StructureTests'!!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 19:59' prior: 36001592!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 0.f1 representation: rep1.f2 representation: rep2.featureList add: f1.featureList add: f2.testFeatures := WeightSumFirstRepresentor new makeFeaturesFrom: featureList.! !!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:00' prior: 35999140!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:01' prior: 36000007!testMakeFeaturesFrom|f1 f2|f1 := testFeatures at: 1.f2 := testFeatures at: 2.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:02' prior: 36003668!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := list2 := OrderedCollection new.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: rep1 = list1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:02' prior: 36003880!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := OrderedCollection new.list2 := OrderedCollection new.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: rep1 = list1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:04' prior: 36004236!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := OrderedCollection new.list2 := OrderedCollection new.list1 add: 7.list1 add: 6.list1 add: 5.list1 add: 4.list1 add: 3.list1 add: 2.list1 add: 1.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: (rep1 at: 1) = 1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:05' prior: 36004615!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := OrderedCollection new.list2 := OrderedCollection new.list1 add: 7.list1 add: 6.list1 add: 5.list1 add: 4.list1 add: 3.list1 add: 2.list1 add: 1.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: (rep1 at: 1) = 7.self assert: (rep1 at: 2) = 6.self assert: (rep1 at: 3) = 5.self assert: (rep1 at: 4) = 4.self assert: (rep1 at: 5) = 3.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:05' prior: 36002457!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep2 add: 1.rep2 add: 0.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep2 add: 0.f1 representation: rep1.f2 representation: rep2.featureList add: f1.featureList add: f2.testFeatures := WeightSumFirstRepresentor new makeFeaturesFrom: featureList.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:06' prior: 36005763!setUp|featureList f1 f2 rep1 rep2|f1 := Feature new.f2 := Feature new.featureList := OrderedCollection new.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep1 add: 1.rep2 add: 1.rep2 add: 0.rep2 add: 1.rep2 add: 0.rep2 add: 0.rep2 add: 1.rep2 add: 0.f1 representation: rep1.f2 representation: rep2.featureList add: f1.featureList add: f2.testFeatures := WeightSumFirstRepresentor new makeFeaturesFrom: featureList.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:06' prior: 36005096!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := OrderedCollection new.list2 := OrderedCollection new.list1 add: 7.list1 add: 6.list1 add: 5.list1 add: 4.list1 add: 3.list1 add: 2.list1 add: 1.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: (rep1 at: 1) = 7.self assert: (rep1 at: 2) = 6.self assert: (rep1 at: 3) = 5.self assert: (rep1 at: 4) = 4.self assert: (rep1 at: 5) = 3.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 1.self assert: (rep2 at: 1) = 3.self assert: (rep2 at: 2) = 3.self assert: (rep2 at: 3) = 2.self assert: (rep2 at: 4) = 2.self assert: (rep2 at: 5) = 2.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 1.! !!WeightSumFirstRepresentorTest methodsFor: 'tests-as yet unclassified' stamp: 'CedricWalker 7/25/2016 20:06' prior: 36007074!testMakeFeaturesFrom|f1 f2 rep1 rep2 list1 list2|list1 := OrderedCollection new.list2 := OrderedCollection new.list1 add: 7.list1 add: 6.list1 add: 5.list1 add: 4.list1 add: 3.list1 add: 2.list1 add: 1.f1 := testFeatures at: 1.f2 := testFeatures at: 2.rep1 := f1 representation.rep2 := f2 representation.self assert: (rep1 at: 1) = 7.self assert: (rep1 at: 2) = 6.self assert: (rep1 at: 3) = 5.self assert: (rep1 at: 4) = 4.self assert: (rep1 at: 5) = 3.self assert: (rep1 at: 6) = 2.self assert: (rep1 at: 7) = 1.self assert: (rep2 at: 1) = 3.self assert: (rep2 at: 2) = 2.self assert: (rep2 at: 3) = 2.self assert: (rep2 at: 4) = 1.self assert: (rep2 at: 5) = 1.self assert: (rep2 at: 6) = 1.self assert: (rep2 at: 7) = 0.! !----QUIT----2016-07-25T22:54:27.958161+02:00 Pharo4.0.image priorSource: 2441341!----STARTUP----2016-07-26T14:42:46.845809+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-26T23:31:20.497809+02:00 Pharo4.0.image priorSource: 2454285!----STARTUP----2016-07-27T15:32:32.751481+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/27/2016 15:33' prior: 36003103!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"|max|max := 0.aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/27/2016 15:34' prior: 36009218!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"|max|max := 0.aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		(sum >max) ifTrue:[max := sum].		 ].	feature representation: list.	].maxValue :=max.^aFeatureList.! !----STARTUP----2016-07-28T10:50:26.560911+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:32' prior: 35936504!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:35' prior: 36010490!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:35' prior: 36010875!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:54' prior: 36011260!elbow|bestK count alpha|alpha := -0.7.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:55' prior: 36011645!elbow|bestK count alpha|alpha := -0.6.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:56' prior: 36012030!elbow|bestK count alpha|alpha := -0.5.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 20:59' prior: 36012415!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:00' prior: 36012800!elbow|bestK count alpha|alpha := -0.3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:01' prior: 36013185!elbow|bestK count alpha|alpha := -0.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:04' prior: 36013570!elbow|bestK count alpha|alpha := -0.3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:06' prior: 36013955!elbow|bestK count alpha|alpha := -0.1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:07' prior: 36014340!elbow|bestK count alpha|alpha := -1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:28' prior: 36014725!elbow|bestK count alpha|alpha := -0.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:29' prior: 36015108!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:31' prior: 36015493!elbow|bestK count alpha|alpha := -0.6.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:38' prior: 36015878!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:40' prior: 36016263!elbow|bestK count alpha|alpha := -1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:41' prior: 36016648!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:44' prior: 36017031!elbow|bestK count alpha|alpha := -1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:46' prior: 36017416!elbow|bestK count alpha|alpha := -1.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:47' prior: 36017799!elbow|bestK count alpha|alpha := -1.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:48' prior: 36018184!elbow|bestK count alpha|alpha := -5.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:49' prior: 36018569!elbow|bestK count alpha|alpha := -3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:50' prior: 36018952!elbow|bestK count alpha|alpha := -4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 21:52' prior: 36019335!elbow|bestK count alpha|alpha := -0.2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 22:00' prior: 36019718!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 22:10' prior: 36020103!elbow|bestK count alpha|alpha := -0.6.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/28/2016 23:14' prior: 36020488!elbow|bestK count alpha|alpha := -4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !----QUIT----2016-07-28T23:37:10.718911+02:00 Pharo4.0.image priorSource: 2454477!----STARTUP----2016-07-29T10:55:26.29219+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 11:02' prior: 36020873!elbow|bestK count alpha|alpha := -5.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 11:13' prior: 36021447!elbow|bestK count alpha|alpha := -3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 11:23' prior: 36021830!elbow|bestK count alpha|alpha := -2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 11:30' prior: 36022213!elbow|bestK count alpha|alpha := -1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:04' prior: 36022596!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:11' prior: 36022979!elbow|bestK count alpha|alpha := -0.6.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:17' prior: 36023364!elbow|bestK count alpha|alpha := -0.4.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:25' prior: 36023749!elbow|bestK count alpha|alpha := -1.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:27' prior: 36024134!elbow|bestK count alpha|alpha := -2.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:29' prior: 36024517!elbow|bestK count alpha|alpha := -0.8.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'CedricWalker 7/29/2016 12:30' prior: 36024900!elbow|bestK count alpha|alpha := -0.6.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !----QUIT----2016-07-29T16:23:26.64919+02:00 Pharo4.0.image priorSource: 2466720!----STARTUP----2016-07-29T17:06:49.072042+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/29/2016 17:07' prior: 36025285!elbow|bestK count alpha|alpha := -3.bestK := 0.count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/29/2016 17:23' prior: 35210156!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * (maxValue/10)).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/29/2016 17:23' prior: 36026252!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * (maxValue/5)).		 ].	list add: feature.	  ].^list! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 7/29/2016 17:42' prior: 36026654!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			feature add: (rand next * (maxValue/10)).		 ].	list add: feature.	  ].^list! !----QUIT----2016-07-29T20:41:29.717042+02:00 Pharo4.0.image priorSource: 2471134!----STARTUP----2016-07-30T15:29:32.146188+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-30T23:38:19.284188+02:00 Pharo4.0.image priorSource: 2472912!----STARTUP----2016-07-31T13:42:18.948156+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-31T17:33:13.885156+02:00 Pharo4.0.image priorSource: 2473103!----STARTUP----2016-07-31T17:33:20.207475+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-31T17:54:32.973475+02:00 Pharo4.0.image priorSource: 2473294!----STARTUP----2016-07-31T17:54:38.598636+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-31T17:55:15.575636+02:00 Pharo4.0.image priorSource: 2473485!----STARTUP----2016-07-31T17:55:25.97442+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-07-31T17:55:47.08542+02:00 Pharo4.0.image priorSource: 2473676!----STARTUP----2016-07-31T17:55:53.239622+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT/NOSAVE----2016-08-01T13:46:03.061622+02:00 Pharo4.0.image priorSource: 2473866!----STARTUP----2016-08-01T15:27:04.532616+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT/NOSAVE----2016-08-01T20:43:22.355616+02:00 Pharo4.0.image priorSource: 2473866!!Vector commentStamp: 'CedricWalker 8/2/2016 10:16' prior: 0!Implemetation of Vector calclations for K-Means implementation.Methods are implemented on the Class side.!!Vector commentStamp: 'CedricWalker 8/2/2016 10:17' prior: 36028839!Implemetation of Vector calclations for K-Means implementation.Methods are implemented on the Class side. Vector does not need to be instantiated.!----STARTUP----2016-08-02T10:15:03.023538+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-08-02T10:22:39.984538+02:00 Pharo4.0.image priorSource: 2561270!!LanguageDifferentiator commentStamp: 'CedricWalker 8/2/2016 10:27' prior: 0!Obejct responsible for calling the Languege Differentiation algorithm.The class is responsible  for setting up the k means runner and calculating the precisions values for the difference between two languages.!!KMeansRunner commentStamp: 'CedricWalker 8/2/2016 10:34' prior: 0!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	c:		<Object>	k1:		<Object>	k2:		<Object>	loops:		<Object>	metric:		<Object>	multiline:		<Object>	projectPath:		<Object>	representator:		<Object>	timestamp:		<Object>	type:		<Object>    Implementation Points!!KMeansRunner commentStamp: 'CedricWalker 8/2/2016 10:35' prior: 36029722!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	c:		<holds the calculated distorition functions>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	metric:		<Object>	multiline:		<Object>	projectPath:		<Object>	representator:		<Object>	timestamp:		<Object>	type:		<Object>    Implementation Points!Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator loops multiline k1 k2 projectPath'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner commentStamp: 'CedricWalker 8/2/2016 10:36' prior: 36030577!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	c:		<holds the calculated distorition functions>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	multiline:		<number of lines newline statementmaker should use>	projectPath:		<path of the projext>	representator:		<the represetor runner>	timestamp:		<timee the project started in string form>	type:		<folder of the actual code>    Implementation Points!!KMeansRunner commentStamp: 'CedricWalker 8/2/2016 10:36' prior: 36031556!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	c:		<holds the calculated distorition functions>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	multiline:		<number of lines newline statementmaker should use>	projectPath:		<path of the projext>	representator:		<the represetor runner>	timestamp:		<timee the project started in string form>	type:		<folder of the actual code>!!KMeansRunner commentStamp: 'CedricWalker 8/2/2016 10:36' prior: 36032461!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.    Instance Variables	c:		<holds the calculated distorition functions>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	multiline:		<number of lines newline statementmaker should use>	projectPath:		<path of the projext>	representator:		<the represetor runner>	timestamp:		<timee the project started in string form>	type:		<folder of the actual code>!!Feature commentStamp: 'CedricWalker 8/2/2016 10:37' prior: 0!Containter element for running kMeans Runner    Instance Variables	klabel:		<Object>	representation:		<Object>	statement:		<Object>    Implementation Points!!Feature commentStamp: 'CedricWalker 8/2/2016 10:37' prior: 36033994!Containter element for running kMeans Runner    Instance Variables	klabel:		<label assigned by the k means runner>	representation:		<vector represetnation of statement>	statement:		<line of code in form of tokens>    Implementation Points!!Feature commentStamp: 'CedricWalker 8/2/2016 10:38' prior: 36034230!Containter element for running kMeans Runner    Instance Variables	klabel:		<label assigned by the k means runner>	representation:		<vector represetnation of statement>	statement:		<line of code in form of tokens>!!Feature commentStamp: 'CedricWalker 8/2/2016 10:38' prior: 36034548!Containter element for the data for running kMeans Runner    Instance Variables	klabel:		<label assigned by the k means runner>	representation:		<vector represetnation of statement>	statement:		<line of code in form of tokens>!!RepresentatorRunner commentStamp: 'CedricWalker 8/2/2016 10:38' prior: 0!Responisble for concatenating different types of representator.- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	distRep:		<Object>	typeRep:		<Object>	weightRep:		<Object>    Implementation Points!!RepresentatorRunner commentStamp: 'CedricWalker 8/2/2016 10:38' prior: 36035146!Responisble for concatenating different types of representator and initializing the centroids.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	distRep:		<Object>	typeRep:		<Object>	weightRep:		<Object>    Implementation Points!!RepresentatorRunner commentStamp: 'CedricWalker 8/2/2016 10:39' prior: 36035589!Responisble for concatenating different types of representator and initializing the centroids.     Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>    Implementation Points!!RepresentatorRunner commentStamp: 'CedricWalker 8/2/2016 10:39' prior: 36035981!Responisble for concatenating different types of representator and initializing the centroids.    Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>!!SqrSumAnalyzer commentStamp: 'CedricWalker 8/2/2016 10:40' prior: 0!Calcualtes he average of the distortion function.!!SqrSumAnalyzer commentStamp: 'CedricWalker 8/2/2016 10:40' prior: 36036685!Calcualtes the average of the distortion function.!----SNAPSHOT----2016-08-02T10:40:48.604538+02:00 Pharo4.0.image priorSource: 2474842!!FileHandler commentStamp: 'cedricwalker 8/2/2016 17:11' prior: 0!The Filehandler is responsible for dealing with the filesystem, this means loading files and stroring files.For the Responsibility part: Three sentences about my main responsibility, what I'm doing, what services do I offer.For the Collaborators Part: State my main collaborators and one line about how I interact with them. Public API and Key Messages- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	projectAsStream:		<Object>    Implementation Points!!FileHandler commentStamp: 'cedricwalker 8/2/2016 17:11' prior: 36037019!The Filehandler is responsible for dealing with the filesystem, this means loading files and stroring files.I contains methods that iteract directly with the filesystem.- message one   - message two - what is the way to create instances is a plus.   One simple example is simply gorgeous. Internal Representation and Key Implementation Points.    Instance Variables	projectAsStream:		<Object>    Implementation Points!!FileHandler commentStamp: 'cedricwalker 8/2/2016 17:11' prior: 36037715!The Filehandler is responsible for dealing with the filesystem, this means loading files and stroring files.I contains methods that iteract directly with the filesystem.!!Statement commentStamp: 'cedricwalker 8/2/2016 17:12' prior: 0!Container file for one line of code. It contains the line of code in a list of string tokens.!!Statement commentStamp: 'cedricwalker 8/2/2016 17:13' prior: 36038461!Container file for one line of code. It contains the line of code in a list of string tokens.It alows for setting and getting tokens.!!Statement commentStamp: 'cedricwalker 8/2/2016 17:13' prior: 36038628!Container file for one line of code. It contains the line of code in a list of string tokens.It alows for setting and getting tokens as a Collection or allows to add a single token at the time.!!AbstractStatementmaker commentStamp: 'cedricwalker 8/2/2016 17:14' prior: 0!Template for  adding different statement creation mechnistms.!!AbstractStatementmaker commentStamp: 'cedricwalker 8/2/2016 17:14' prior: 36039110!Template for  adding different statement creation mechnisms.!!NewLineStatementmaker commentStamp: 'cedricwalker 8/2/2016 17:14' prior: 0!NewLineStatementmaker is responsible for creating statements of a stream and return them tokanized.!!NewLineStatementmaker commentStamp: 'cedricwalker 8/2/2016 17:15' prior: 36039397!NewLineStatementmaker is responsible for creating statements of a stream and return them tokanized.createTokanizedStatment: is for online only. createTokanizedStatement:withLines: allows for multi-line creation.!!AbstractAnalyzingMethod commentStamp: 'cedricwalker 8/2/2016 17:16' prior: 34312423!Template for adding different Analyzing technics.!!StructureClassifier commentStamp: 'cedricwalker 8/2/2016 17:17' prior: 0!Structure Classifier is the Parent Class for the two different Mainfunctions of the k-means clustering algorithm for software code.!!StructureClassifier commentStamp: 'cedricwalker 8/2/2016 17:18' prior: 36040009!Structure Classifier is the Parent Class for the two different Mainfunctions of the k-means clustering algorithm for software code.It contains the methods for setting up the ressources for the StructureAnalyzer and the StructureFinder.!!StructureFinder commentStamp: 'cedricwalker 8/2/2016 17:19' prior: 0!Structure Finder is the bundler for the cluster technics-!!StructureFinder commentStamp: 'cedricwalker 8/2/2016 17:19' prior: 36040533!Structure Finder is the bundler for the cluster technics.!!StructureFinder commentStamp: 'cedricwalker 8/2/2016 17:20' prior: 36040670!Structure Finder is the bundler for the cluster technics.It allows for setting up ressources and parameters for the k means clustering and call KMeansrunner for clustering.!!Tokanizer commentStamp: 'cedricwalker 8/2/2016 17:20' prior: 0!The Tokanizer tokonaizes statements in the statement creation prozess.!!Tokanizer commentStamp: 'cedricwalker 8/2/2016 17:21' prior: 36041047!The Tokanizer tokonaizes statements in the statement creation prozess.tokanize:  splits a Stream into  tokens.!----STARTUP----2016-08-02T17:10:22.150421+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!Vector class removeSelector: #advancedFeatureDistanceFrom:to:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:22' prior: 35997203!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	loops ifNil: [ iterations := 50. ].	iterations := loops.	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !VectorTest removeSelector: #testadvancedFeatureDistance!Vector class removeSelector: #featureDistanceFrom:to:!VectorTest removeSelector: #testfeatureDistanceFromTo!!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:23' prior: 35792447!divide: sum through: count|list|list := OrderedCollection new."divide vector element wise"sum do:[:entry| list add: (entry / count)].^list.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:23' prior: 35413745!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list""make shure v1 is the biggest"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 			d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:24' prior: 36043068!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list""make shure v1 is the biggest"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 		"sum vector element wise"	d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:24' prior: 36043649!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list""make shure v1 is the biggest"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 		d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:24' prior: 36044255!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list""make shure v1 is the bigger"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 		d:=0.	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cedricwalker 8/2/2016 17:24' prior: 34558036!sumVec: vec1 plus: vec2"pad shorter vector with zeros, make shure v1 is the bigger"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	v1 := vec2.	v2 := vec1.	].		(1 to: v1 size )do: [ :count|			(count <= v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !!LanguageDifferentiator commentStamp: 'cedricwalker 8/2/2016 17:25' prior: 36029440!Allows for cross testing Languages!!LanguageDifferentiator commentStamp: 'cedricwalker 8/2/2016 17:25' prior: 36045900!Obejct responsible for calling the Languege Differentiation algorithm.The class is responsible  for setting up the k means runner and calculating the precisions values for the difference between two languages.!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:26' prior: 35994627!crossLanguageComparison: path types: types withk: k|kmeansList resultsPerType streams type1count|type1count :=0.streams := OrderedCollection new.resultsPerType := OrderedCollection new.kmeansList := OrderedCollection new."calculate k means for training examples and set up test example per type"types do: [ :type|	kmeansList add: (krunner bestKMean: path, '\compare\training' from: ((k/2) floor) to: k onType: type).	streams add: (FileHandler new projectAsStream: (path, '\compare\test') type: type).	 ].kmeansList do: [ :result|	|list type2count|	type1count := type1count +1.	type2count := 0.	list := OrderedCollection new.	streams do: [ :stream|		|radiusList featureList percentage |		percentage := 0.		type2count := type2count +1.		radiusList := self calcRadiusListfrom: result.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: stream).			featureList do: [ :feature |				(self is: feature to: (result at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].			].			list add:(1-(percentage / featureList size)) asString, (types at: type1count), (types at:type2count).		 ].	resultsPerType add: list.	 ].^resultsPerType.! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:27' prior: 35418336!calcRadiusListfrom: bestResult"calculates the distance from the centroids to the assigned feature with biggest distance"|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector euclideanDistanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:27' prior: 35417931!is: feature to: centroids in: radiusList"looks if feature is in raduis of the centroids"	|ciPosition |			ciPosition := 0.			centroids do: [ :ci|		|d | 					ciPosition := ciPosition +1.		d := Vector euclideanDistanceFrom: feature representation to: ci.					((radiusList at: ciPosition) >= d) ifTrue: [ ^true].			 		].^false.! !----SNAPSHOT----2016-08-02T17:27:38.699421+02:00 Pharo4.0.image priorSource: 2482432!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:28' prior: 35569763!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.		bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:28' prior: 36048833!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:28' prior: 36049840!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult.  	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:29' prior: 36050882!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult. 	"set up language two with representations" 	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |			(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:29' prior: 36051959!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult. 	"set up language two with representations" 	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		"calculate if representation is in a radius"		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:29' prior: 36053079!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (anotherPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult. 	"set up language two with representations" 	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		"calculate if representation is in a radius of a cluster."		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cedricwalker 8/2/2016 17:32' prior: 36046739!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: (k)to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveConfig: fHandler to: newpath.^results at: (self elbow)! !KMeansRunner removeSelector: #metric:!----QUIT----2016-08-02T17:33:03.982421+02:00 Pharo4.0.image priorSource: 2494201!----STARTUP----2016-08-02T18:11:05.282746+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:14' prior: 36032037!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:14' prior: 36056668!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !----QUIT/NOSAVE----2016-08-02T18:15:38.906746+02:00 Pharo4.0.image priorSource: 2501949!----STARTUP----2016-08-02T18:41:23.451115+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:43' prior: 36047682!calcRadiusListfrom: bestResult"calculates the distance from the centroids to the assigned features and saves the biggest per centroid in the radiusList"|radiusList count|radiusList := OrderedCollection new.count := 0.(bestResult at: 2) do: [ :ci|	|r maxR|	count := count + 1.		maxR := 0.	(bestResult at: 1) do: [  :y|		r:=0.		( y klabel = count) ifTrue: [ 			r := Vector euclideanDistanceFrom: ci to: y representation. 			].		(r > maxR ) ifTrue: [ maxR := r ].		].			radiusList add: maxR.			].^radiusList! !----STARTUP----2016-08-02T18:46:19.454026+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:49' prior: 36032037!run|krunner lDiff message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner metric: metric.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(mode = 3) ifTrue: [  	lDiff := LanguageDifferentiator new.	lDiff krunner:krunner.	result := lDiff is: path with: aType thesameLanguageAs: path with: anotherType and: k.	].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:50' prior: 36060927!run|krunner  message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:51' prior: 36113276!analyzeVMeasure	| t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 t11 t12 logMsg |	t9 := OrderedCollection new.	t12 := ''.	logMsg := ''.	t4 := OrderedCollection new.	t1 := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ t12 := t12 , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	t7 := self homogeneityof: t5 nd: t6.	t8 := self completenessof: t5 nd: t6.	t10 := 2 * (t7 * t8) / (t7 + t8).	logMsg := 'homogenity: ' , t7 asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , t8 asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	t11 := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	t11 do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	t1 addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:52' prior: 36064068!analyzeVMeasure	| t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 nearestStatements t12 logMsg |	t9 := OrderedCollection new.	t12 := ''.	logMsg := ''.	t4 := OrderedCollection new.	t1 := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ t12 := t12 , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	t7 := self homogeneityof: t5 nd: t6.	t8 := self completenessof: t5 nd: t6.	t10 := 2 * (t7 * t8) / (t7 + t8).	logMsg := 'homogenity: ' , t7 asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , t8 asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	t1 addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:52' prior: 36065935!analyzeVMeasure	| t1 t2 t3 t4 t5 t6 t7 t8 t9 t10 nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	t4 := OrderedCollection new.	t1 := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	t7 := self homogeneityof: t5 nd: t6.	t8 := self completenessof: t5 nd: t6.	t10 := 2 * (t7 * t8) / (t7 + t8).	logMsg := 'homogenity: ' , t7 asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , t8 asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	t1 addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:53' prior: 36067844!analyzeVMeasure	| fileHandler t2 t3 t4 t5 t6 t7 t8 t9 t10 nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	t4 := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	t7 := self homogeneityof: t5 nd: t6.	t8 := self completenessof: t5 nd: t6.	t10 := 2 * (t7 * t8) / (t7 + t8).	logMsg := 'homogenity: ' , t7 asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , t8 asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:53' prior: 36069773!analyzeVMeasure	| fileHandler t2 t3 t4 t5 t6 t7 c t9 t10 nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	t4 := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	t7 := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	t10 := 2 * (t7 * c) / (t7 + c).	logMsg := 'homogenity: ' , t7 asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:53' prior: 36071729!analyzeVMeasure	| fileHandler t2 t3 t4 t5 t6 h c t9 t10 nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	t4 := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	t10 := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , t10 asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:54' prior: 36073680!analyzeVMeasure	| fileHandler t2 t3 t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	t4 := OrderedCollection new.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:55' prior: 36075626!analyzeVMeasure	| fileHandler t2 t3 t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	t2 := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: t2.	t6 := self resultToBuckets: t3.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:55' prior: 36077566!analyzeVMeasure	| fileHandler perfectExample t3 t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ t3 := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			t3 := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: perfectExample.	t6 := self resultToBuckets: t3.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: t3.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:56' prior: 36079506!analyzeVMeasure	| fileHandler perfectExample kmeansResults t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: perfectExample.	t6 := self resultToBuckets: kmeansResults.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :t15 | logMsg := logMsg , t15 asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:56' prior: 36081482!analyzeVMeasure	| fileHandler perfectExample kmeansResults t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: perfectExample.	t6 := self resultToBuckets: kmeansResults.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:57' prior: 36083513!analyzeVMeasure	| fileHandler perfectExample kmeansResults t4 t5 t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	t5 := self resultToBuckets: perfectExample.	t6 := self resultToBuckets: kmeansResults.	h := self homogeneityof: t5 nd: t6.	c := self completenessof: t5 nd: t6.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:57' prior: 36085556!analyzeVMeasure	| fileHandler perfectExample kmeansResults t4 perfectForAnalyzing t6 h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	perfectForAnalyzing := self resultToBuckets: perfectExample.	t6 := self resultToBuckets: kmeansResults.	h := self homogeneityof: perfectForAnalyzing nd: t6.	c := self completenessof: perfectForAnalyzing nd: t6.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:58' prior: 36087617!analyzeVMeasure	| fileHandler perfectExample kmeansResults t4 perfectForAnalyzing kmeansForAnalyzing h c t9 v nearestStatements errorMsg logMsg |	t9 := OrderedCollection new.	t4 := OrderedCollection new.	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !----SNAPSHOT----2016-08-02T18:58:20.246026+02:00 Pharo4.0.image priorSource: 2501949!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:58' prior: 36089746!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	"t9 := OrderedCollection new.	t4 := OrderedCollection new."	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:58' prior: 36092026!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !----SNAPSHOT----2016-08-02T18:59:01.990026+02:00 Pharo4.0.image priorSource: 2537409!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:59' prior: 36094217!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 18:59' prior: 36096433!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.		h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 19:00' prior: 36098602!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/2/2016 19:00' prior: 36100806!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer commentStamp: 'cw 8/2/2016 19:00' prior: 35785523!homogenity and completness calculated from:  V-Measure: A conditional entropy-based external cluster evaluationmeasure!----SNAPSHOT----2016-08-02T19:00:29.406026+02:00 Pharo4.0.image priorSource: 2541816!----QUIT----2016-08-02T19:00:39.359026+02:00 Pharo4.0.image priorSource: 2550924!----STARTUP----2016-08-02T21:59:28.026539+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-08-02T22:35:16.244539+02:00 Pharo4.0.image priorSource: 2551011!----STARTUP----2016-08-03T09:17:38.51376+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureClassifier methodsFor: 'accessing' stamp: 'cw 8/3/2016 09:21'!iterations:aNumberloops := aNumber.! !StructureClassifier removeSelector: #loops:!----QUIT----2016-08-03T09:34:23.84976+02:00 Pharo4.0.image priorSource: 2551202!----STARTUP----2016-08-03T20:50:20.819217+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 20:52'!type: aStringaType := aString.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 20:53'!folder: aStringaType := aString.! !!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 20:53'!inputFolder: aStringaType := aString.! !!StructureClassifier methodsFor: 'accessing' stamp: 'cw 8/3/2016 20:54'!kmin: aKk2 := aK.	! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:03' prior: 36041580!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	loops ifNil: [ iterations := 25. ].	iterations := loops.	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !(Smalltalk globals at: #DistanceAllSmallRepresentor) rename: #DistanceAllRepresentor!Smalltalk globals removeClassNamed: #DistanceAllBigRepresentor!----SNAPSHOT----2016-08-03T21:06:25.741217+02:00 Pharo4.0.image priorSource: 2551551!!StructureClassifier methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:09'!weigthRep:aRepweigthRep := aRep.! !StructureClassifier removeSelector: #wheigthRep:!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:13' prior: 36106727!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:46' prior: 36047745!projectPath^projectPath! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:46' prior: 36055413!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList newpath fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	newpath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: (k)to: newpath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveLog: fHandler to: newpath.^results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:47' prior: 36075806!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.string := string , Character cr asString, (self elbow + k2-1) asString.fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:49' prior: 36107424!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	k1 := k.	type := aType.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:50' prior: 36109433!bestKMean: path from: kOne to: kTwo onType: aType|result aC bestC  statementList statementmaker aStream featureList  fHandler results|	k1 := kTwo.	k2 := kOne.	type := aType.	fHandler := FileHandler new.	projectPath := path, '\result\' , type ,'\' , timestamp.	aStream := fHandler projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.	statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"	featureList := representator makeFeaturesFrom: statementList.bestC := 99999999999.results := OrderedCollection new.(kOne to: kTwo) do: [:k|					result := self kMean: featureList with: k on: representator.		fHandler save: (result at: 1)on: (k)to: projectPath .		aC := (SqrSumAnalyzer new) analyze: result with: k.		c add: aC.		results add: result.	 ].self saveLog: fHandler to: projectPath.^results at: (self elbow)! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:50' prior: 36111222!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	k1 := k.	type := aType.	projectPath := path, '\result\' , type ,'\' , timestamp.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveConfig: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result! !----SNAPSHOT----2016-08-03T21:50:36.710217+02:00 Pharo4.0.image priorSource: 2553442!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:53' prior: 36113085!runOn: path with: k type: aType	|statementList aC statementmaker featureList result aStream  |	k1 := k.	type := aType.	projectPath := path, '\result\' , type ,'\' , timestamp.	aStream := (FileHandler new) projectAsStream: path type: type.		statementmaker := NewLineStatementmaker new.		statementList := statementmaker createTokanizedStatement: aStream withLines: multiline. "returnsList of Statement containers"		featureList := representator makeFeaturesFrom: statementList.		result := self kMean: featureList with: k on: representator.	aC := (SqrSumAnalyzer new) analyze: result with: k.	c add: aC.	(FileHandler new) save: (result at: 1)on: k to: (path, '\result\' , type ,'\' , timestamp).	self saveLog: (FileHandler new) to: (path, '\result\' , type ,'\' , timestamp).	 ^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/3/2016 21:55' prior: 36110451!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !StructureClassifier removeSelector: #k2:!UndefinedObject removeSelector: #DoIt!----SNAPSHOT----2016-08-03T22:00:05.464217+02:00 Pharo4.0.image priorSource: 2559458!!FileHandler methodsFor: 'loading' stamp: 'cw 8/3/2016 22:09' prior: 36049832!addAnalyzedInfo: info to: path	| reference result fileName|	reference := path asFileReference writeStream.	result := reference contents.	reference close.	result := result, info.	fileName := '\configuration_used.txt'.	self saveFile: result to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/3/2016 22:10' prior: 36115920!addAnalyzedInfo: info to: path	| reference result fileName|	fileName := '\configuration_used.txt'.	reference := path, fileName asFileReference writeStream.	result := reference contents.	reference close.	result := result, info.	self saveFile: result to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/3/2016 22:10' prior: 36116268!addAnalyzedInfo: info to: path	| reference result fileName|	fileName := '\configuration_used.txt'.	reference := (path, fileName) asFileReference writeStream.	result := reference contents.	reference close.	result := result, info.	self saveFile: result to: path, fileName.! !----SNAPSHOT----2016-08-03T23:36:26.056217+02:00 Pharo4.0.image priorSource: 2561321!----QUIT----2016-08-03T23:36:46.291217+02:00 Pharo4.0.image priorSource: 2562474!----STARTUP----2016-08-04T14:42:58.179277+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 15:30' prior: 36054244!is: aPath with: aType thesameLanguageAs: anotherPath with: anotherType and: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (aPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult. 	"set up language two with representations" 	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		"calculate if representation is in a radius of a cluster."		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !!LanguageDifferentiator methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 15:31'!is: aType thesameLanguageAs: anotherType in: aPath on: k"calculates precision value of relation between two languages" |bestResult radiusList threshold aStream  featureList   percentage  |	threshold := 0.9.	percentage := 0.	"set up clusters of first language"	bestResult := krunner bestKMean: (aPath, '\compare' )from:  (k/2) floor to: k onType: aType.	"calculate radius of the clusters"	radiusList := self calcRadiusListfrom: bestResult. 	"set up language two with representations" 	aStream := FileHandler new projectAsStream: (aPath, '\compare') type: anotherType.		featureList := krunner representator makeFeaturesFrom: (NewLineStatementmaker new createTokanizedStatement: aStream).		featureList do: [ :feature |		"calculate if representation is in a radius of a cluster."		(self is: feature to: (bestResult at:2) in: radiusList) ifTrue:  [  percentage := percentage + 1].	].					^1-(percentage / featureList size)" < threshold". "percentage should be high for same language and low for different langague " ! !LanguageDifferentiator removeSelector: #is:with:thesameLanguageAs:with:and:!----QUIT----2016-08-04T19:44:47.847277+02:00 Pharo4.0.image priorSource: 2562561!----STARTUP----2016-08-04T21:10:53.085774+02:00 as C:\Users\Cédric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----SNAPSHOT----2016-08-04T21:13:48.996774+02:00 Pharo4.0.image priorSource: 2565120!Object subclass: #KMeansRunner	instanceVariableNames: 'timestamp c type representator loops multiline k1 k2 projectPath alpha'	classVariableNames: ''	category: 'Structure-K-means'!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 21:23'!alpha: aalpha := a.! !Object subclass: #StructureClassifier	instanceVariableNames: 'k loops mode k2 path aType anotherType metric typeRep distRep weigthRep multiline alpha'	classVariableNames: ''	category: 'StructureFinder'!!StructureClassifier methodsFor: 'running' stamp: 'cw 8/4/2016 21:24'!alpha: aalpha :=a.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 21:25' prior: 36103028!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	logMsg := logMsg , Character cr asString , 'Number of Clusters: ' , (krunner elbow + k2 - 1) asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 21:25' prior: 36062600!run|krunner  message result|	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/4/2016 21:27' prior: 36025860!elbow|bestK count|alpha ifNil: [  alpha := -3.].bestK := 0. count := 0.c do: [ :aC|count := count +1.((count =1 )or: (count >= c size))ifFalse: [	|a b|	a := (c at: count -1 ) -(c at: count +1).	b := (count - 1) - (count +1).	(a/b > alpha ) ifTrue: [ 		^count].	 ].].^c size.! !----QUIT----2016-08-04T22:16:11.121774+02:00 Pharo4.0.image priorSource: 2565312!----STARTUP----2016-08-06T22:12:51.104735+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:22' prior: 36114965!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].string := string , Character cr asString,type.k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:22' prior: 36124833!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString .string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:22' prior: 36125659!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString.string := (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:23' prior: 36126462!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:24' prior: 36127264!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: '.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:24' prior: 36128116!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Best K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:27' prior: 36129024!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'.string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:27' prior: 36129955!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'."set up information for log file"string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K:' ,(self elbow + k2-1) asString.].fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:27' prior: 36130891!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'."set up information for log file"string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K:' ,(self elbow + k2-1) asString.]."save to file"fileHandler saveFile: string to: path, fileName.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:27' prior: 36131861!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'."set up information for log file"string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K:' ,(self elbow + k2-1) asString.]."save to file configartion_used.txt"fileHandler saveFile: string to: path, fileName.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:28' prior: 36120515!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:29' prior: 36122771!run|krunner  message result logMsg|	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:30' prior: 36135984!run|krunner  message result logMsg|	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:30' prior: 36137495!run|krunner  message result logMsg fileHandler |	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatements:result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:31' prior: 36139007!run|krunner  message result logMsg fileHandler |fileHandler := FileHandler new.	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:32' prior: 36140773!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new.	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:33' prior: 36142585!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:33' prior: 36144398!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:33' prior: 36146229!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:33' prior: 36133856!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:34' prior: 36149948!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:34' prior: 36152116!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completenes: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !StructureAnalyzer removeSelector: #homogeneityof:and:!StructureAnalyzer removeSelector: #completenessof:and:!StructureAnalyzer removeSelector: #featurize:!!StructureElements methodsFor: 'initialization' stamp: 'cw 8/6/2016 22:36' prior: 34814741!initialize"initalize stucture parts for TypeSpecific, so that parentheses can be dectet as the same token"	|pair1 pair2 pair3 pair4 pair5 strElement strElement2|	super initialize.	structureArray := OrderedCollection new.		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .! !!StructureElements methodsFor: 'initialization' stamp: 'cw 8/6/2016 22:37' prior: 36156648!initialize"initalize stucture parts for TypeSpecific, so that parentheses can be dectet as the same token"	|pair1 pair2 pair3 pair4 pair5 strElement strElement2 pair6|	super initialize.	structureArray := OrderedCollection new.		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	pair6 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .! !!StructureElements methodsFor: 'initialization' stamp: 'cw 8/6/2016 22:37' prior: 36157739!initialize"initalize stucture parts for TypeSpecific, so that parentheses can be dectet as the same token"	|pair1 pair2 pair3 pair4 pair5 strElement strElement2 pair6|	super initialize.	structureArray := OrderedCollection new.		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	pair6 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.	pair6 pair: $< and: $>.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: strElement .	structureArray add: strElement2 .! !!StructureElements methodsFor: 'initialization' stamp: 'cw 8/6/2016 22:37' prior: 36158865!initialize"initalize stucture parts for TypeSpecific, so that parentheses can be dectet as the same token"	|pair1 pair2 pair3 pair4 pair5 strElement strElement2 pair6|	super initialize.	structureArray := OrderedCollection new.		pair1 := StructureChar new.	pair2 := StructureChar new.	pair3 := StructureChar new.	pair4 := StructureChar new.	pair5 := StructureChar new.	pair6 := StructureChar new.	strElement := StructureChar new.	strElement2 := StructureChar new.	pair1 pair: ${ and: $}.	pair1 isClosing: true.	pair2 pair: $" and: $".	pair2 isClosing: false.	pair3 pair: $' and: $'.	pair3 isClosing: false.	pair4 pair: $[ and: $].	pair4 isClosing: true.	pair5 pair: $( and: $).	pair5 isClosing: true.	pair6 pair: $< and: $>.		strElement setSingleElement: $..	strElement2 setSingleElement: $;.	structureArray add: pair1.	structureArray add: pair2.	structureArray add: pair2.	structureArray add: pair3.	structureArray add: pair4.	structureArray add: pair5.	structureArray add: pair6.	structureArray add: strElement .	structureArray add: strElement2 .! !!StructureElements methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:39' prior: 34395672!returnIfContains: chr	"return the structure array form the structure array if a structure element exists"	|container|	structureArray do: [ :containerElement | (containerElement contains:chr) ifTrue: [container := 	containerElement ]].^container ! !!Tokanizer methodsFor: 'accessing' stamp: 'cw 8/6/2016 22:39' prior: 35095253!tokanize: aStream|tokenIdentifier|"set up deliminiters for creating tokens with petitparser"tokenIdentifier := (#word asParser plus/ #punctuation asParser)flatten trim.^tokenIdentifier matchesSkipIn: aStream.! !!StructureClassifier methodsFor: 'running' stamp: 'cw 8/6/2016 22:41' prior: 35933860!nearestStatementsFromCentroids: result|features centroids list nearest|"calculates and returns the nearest statement of each centroid"list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'cw 8/6/2016 22:41' prior: 36161835!nearestStatementsFromCentroids: result|features centroids list nearest|"calculates and returns the nearest statement of each centroid"list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	"initialize neares as infinity"	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'cw 8/6/2016 22:41' prior: 36162599!nearestStatementsFromCentroids: result|features centroids list nearest|"calculates and returns the nearest statement of each centroid"list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	"initialize neares as infinity"	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			"calc distance"			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'cw 8/6/2016 22:41' prior: 36163396!nearestStatementsFromCentroids: result|features centroids list nearest|"calculates and returns the nearest statement of each centroid"list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	"initialize neares as infinity"	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			"calc distance"			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	"look for emty centroids"	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!StructureClassifier methodsFor: 'running' stamp: 'cw 8/6/2016 22:42' prior: 36164212!nearestStatementsFromCentroids: result|features centroids list nearest|"calculates and returns the nearest statement of each centroid"list := OrderedCollection new.features := result at:1.centroids := result at:2.(1 to: (centroids size))do:[ :c|	|d nearestFeature|	nearestFeature := nil.	"initialize neares as infinity"	nearest := 999999999999999.	(features) do:[:feature|		(feature klabel = c) ifTrue:[			"calc distance"			d := Vector euclideanDistanceFrom: feature representation  to: (centroids at:c). 			(d < nearest) ifTrue: [				nearest := d.				nearestFeature := feature ].			].		].	"look for empty centroids"	(nearestFeature) ifNotNil: [list add: nearestFeature statement]; ifNil: [list add: 'centroid is empty'].	].^list.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:43' prior: 35191811!isOpeningElement: chr"legacy from structureTree for statemetizing, not used in thesis"	^(chr = element1) and: (self isClosing and: self isPaired).! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:44' prior: 34379659!isPaired"locks if StructureChar has a pair"|boolean|	boolean := false.	(element2 = nil) ifFalse: [ boolean := true].	^boolean! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:44' prior: 34339684!pair: aChar1 and: aChar2"set"	element1 := aChar1.	element2 := aChar2.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:44' prior: 35153829!isClosing: bolean "gets set in StructureElements means its not only paired, but praenthesis."isClosing := bolean.! !!StructureChar methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:44' prior: 36166547!isClosing: boolean "gets set in StructureElements means its not only paired, but praenthesis."isClosing := boolean.! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 22:44' prior: 36154304!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completeness: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	logMsg := logMsg , Character cr asString , 'Results Analyzer' , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer commentStamp: 'cw 8/6/2016 22:45' prior: 36105236!homogenity and completness calculated from:  V-Measure: A conditional entropy-based external cluster evaluationmeasure, interface for simple calculations.!!StructureAnalyzer commentStamp: 'cw 8/6/2016 22:46' prior: 36169141!homogenity and completness calculated from:  V-Measure: A conditional entropy-based external cluster evaluationmeasure.Responsible for creating interface for simpler tool analyzing.!!StructureChar commentStamp: 'cw 8/6/2016 22:46' prior: 34360266!Container Element for Structure Elements, Parenteses must be recocnisted as Opening and Closing, the first Element being the opening one.The isPaired Boolean alows further use of non Paired Characters such as $. and $,.!!Statement commentStamp: 'cw 8/6/2016 22:46' prior: 36038836!Container Object for one line of code. It contains the line of code in a list of string tokens.It alows for setting and getting tokens as a Collection or allows to add a single token at the time.!!LanguageDifferentiator commentStamp: 'cw 8/6/2016 23:15' prior: 36046021!Obejct responsible for calling the Languege Differentiation algorithm, wich calculates a precision value for how close two langauges are related.Two mode:   same Languageas; two langagues The class is responsible  for setting up the k means runner and calculating the precisions values for the difference between two languages.!!LanguageDifferentiator commentStamp: 'cw 8/6/2016 23:15' prior: 36170176!Obejct responsible for calling the Languege Differentiation algorithm, wich calculates a precision value for how close two langauges are related.Two mode:   same Languageas; two langagues , crossLanguage; multiple times with training and test set.The class is responsible  for setting up the k means runner and calculating the precisions values for the difference between two languages.!!LanguageDifferentiator commentStamp: 'cw 8/6/2016 23:15' prior: 36170585!Obejct responsible for calling the Languege Differentiation algorithm, wich calculates a precision value for how close two langauges are related.Two mode:   same Languageas; two langagues , crossLanguage; multiple times with training and test set.The class is responsible  for setting up the k means runner and calculating the precisions values for measuring the relation between two languages.!!FileHandler commentStamp: 'cw 8/6/2016 23:16' prior: 36038223!The Filehandler is responsible for dealing with the filesystem, meaning loading files and stroring files.I contains methods that iteract directly with the filesystem.!!FileHandler commentStamp: 'cw 8/6/2016 23:16' prior: 36171518!The Filehandler is responsible for dealing with the filesystem, meaning loading files and stroring files.It contains methods that interact directly with the filesystem.!!KMeansRunner commentStamp: 'cw 8/6/2016 23:17' prior: 36033339!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.    Instance Variables	c:		<cost of distortion function values>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	multiline:		<number of lines newline statementmaker should use>	projectPath:		<path of the projext>	representator:		<the represetor runner>	timestamp:		<timee the project started in string form>	type:		<folder of the actual code>!!KMeansRunner commentStamp: 'cw 8/6/2016 23:17' prior: 36171989!The KMeansRunner sets up all the necceary rescources for running the clustering algorithm on the input and has die method for running it.Parameter can be set through methods and the the cliustering algothim can be run.    Instance Variables	c:		<cost of distortion function values>	k1:		<max k>	k2:		<min k>	loops:		<number of iterations>	multiline:		<number of lines newline statementmaker should use>	projectPath:		<path of the project>	representator:		<the represetor runner>	timestamp:		<timee the project started in string form>	type:		<folder of the actual code>!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 0!Weight Representor, knows how to change representation of feature objects!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 36173292!.Weight Representor, knows how to change representation of feature objects!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 36173444!Weight Representor, knows how to change representation of feature objects.!!WeightSumFirstRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 0!Weight Representor, knows how to change representation of feature objects.!!WeightInverseRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 0!Weight Representor, knows how to change representation of feature objects.!!TypeStructureRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 0!Type Representor, knows how to change representation of feature objects.!!TypeSpecificRepresentor commentStamp: 'cw 8/6/2016 23:18' prior: 0!Type Representor, knows how to change representation of feature objects.!!TypeSpecificRepresentor commentStamp: 'cw 8/6/2016 23:19' prior: 36174179!Type Representor, knows how to change representation of feature objects.!!DistanceZeroRepresentor commentStamp: 'cw 8/6/2016 23:20' prior: 0!Type Representor, knows how to change representation of feature objects.!!TypeStructureRepresentor commentStamp: 'cw 8/6/2016 23:20' prior: 36174036!Type Representor, calculates a type repesentation to a statement and wraps it in feature elements.!!TypeSpecificRepresentor commentStamp: 'cw 8/6/2016 23:21' prior: 36174329!Type Representor, calculates a type repesentation to a statement and wraps it in feature elements.!!RepresentatorRunner commentStamp: 'cw 8/6/2016 23:21' prior: 36036354!Responisble for concatenating different types of representator and initializing the centroids.Runs all the different representatons on order; Type, Distance, Wight.    Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>!!RepresentatorRunner commentStamp: 'cw 8/6/2016 23:22' prior: 36174973!Responisble for concatenating different types of representator and initializing the centroids.Runs all the different representatons on order; Type, Distance, Weight Represetnator.    Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>!!RepresentatorRunner commentStamp: 'cw 8/6/2016 23:22' prior: 36175376!Responisble for concatenating different types of representator and initializing the centroids.Runs all the different representatons on order; Type, Distance, Weight Representator.    Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>!!RepresentatorRunner commentStamp: 'cw 8/6/2016 23:23' prior: 36175794!Responisble for concatenating different types of representator and initializing the centroids.Runs all the different representatons on order; Type, Distance, Weight Representator.    Instance Variables	distRep:		<Instance of a Distance Representor>	typeRep:		<Instance of a Type Representor>	weightRep:		<Instance of a Weight Representor>!!DistanceAllRepresentor commentStamp: 'cw 8/6/2016 23:23' prior: 0!Type Representor, knows how to change representation of feature objects.!!AbstractRepresentator commentStamp: 'cw 8/6/2016 23:24' prior: 34661247!RepresentatorsThere are three different Type of Representatiors and a Runner1. TypeRepresentator, sets up the inital Vector, is responsible for defining longesFeature!! Takes a StatementList2. DistRepresentator, calculates Distances between element. Takes a FeatureList.3. weightRepresentator: gives a defined Weight to the Vector. Needs to Tell Runner maxValue  Takes a FeatureList. The Runner consist of one instance of TypeRepresentatior and optionaly one of Dist and one of Weight.The Runner then concatenates these Runners.longestFeautrea and maxValue for scaling the instantiation of the centroids.!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:33' prior: 36173597!Weight Representor, knows how to change representation of a feature objects and its name.!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:33' prior: 36177473!Weight Representor, knows how to change representation of a feature objects and its name.Sets longestFeature and max Value!!WeightSummaryRepresentor commentStamp: 'cw 8/6/2016 23:33' prior: 36177641!Weight Representor, knows how to change representation of a feature objects and its name.Sets longestFeature and max Value.!!WeightSumFirstRepresentor commentStamp: 'cw 8/6/2016 23:33' prior: 36173744!Weight Representor, knows how to change representation of a feature objects and its name.Sets longestFeature and max Value.!!WeightInverseRepresentor commentStamp: 'cw 8/6/2016 23:33' prior: 36173890!Weight Representor, knows how to change representation of a feature objects and its name.Sets longestFeature and max Value.!!TypeStructureRepresentor commentStamp: 'cw 8/6/2016 23:34' prior: 36174625!Type Representor, calculates a type repesentation to a statement and wraps it in feature elements  and  knows its name.Sets longestFeature and max Value.!!TypeSpecificRepresentor commentStamp: 'cw 8/6/2016 23:34' prior: 36174801!Type Representor, calculates a type repesentation to a statement and wraps it in feature elements and knows its name.Sets longestFeature and maxValue from parent class.!!DistanceZeroRepresentor commentStamp: 'cw 8/6/2016 23:35' prior: 36174473!Type Representor, knows how to change representation of feature objects and its name.!DistanceAllRepresentor removeSelector: #initCentroids:with:!DistanceZeroRepresentor removeSelector: #initCentroids:with:!TypeSpecificRepresentor removeSelector: #initCentroids:with:!!TypeSpecificRepresentor commentStamp: 'cw 8/6/2016 23:36' prior: 36178685!Type Representor, calculates a type repesentation to a statement and wraps it in feature elements and knows its name.Sets longestFeature and maxValue from parent class.Reverse: reverses a centroid to a string statements based on the nearest dicitonary entry, wich is calulated in makeFeaturesFrom.!!DistanceZeroRepresentor commentStamp: 'cw 8/6/2016 23:37' prior: 36178932!Type Representor, knows how to change representation of feature objects and its name.Sets longestFeature and max Value for centroid initalization.!!DistanceAllRepresentor commentStamp: 'cw 8/6/2016 23:37' prior: 36176627!Type Representor, knows how to change representation of feature objects and its name.Sets longestFeature and max Value for centroid initalization.!!AbstractRepresentator commentStamp: 'cw 8/6/2016 23:38' prior: 36176776!RepresentatorsThere are three different Type of Representatiors and a Runner1. TypeRepresentator, sets up the inital Vector, is responsible for defining longesFeature!! Takes a StatementList2. DistRepresentator, calculates Distances between element. Takes a FeatureList.3. weightRepresentator: gives a defined Weight to the Vector. Needs to Tell Runner maxValue  Takes a FeatureList. The Runner consist of one instance of TypeRepresentatior and optionaly one of Dist and one of Weight.The Runner then concatenates these Runners.longestFeautrea and maxValue for scaling the instantiation of the centroids.makeFeaturesFrom:needs to be implemented for each subtype.!!SqrSumAnalyzer commentStamp: 'cw 8/6/2016 23:39' prior: 36036813!Calcualtes the average over k for the distortion function, the sum of the squared distances.!!SqrSumAnalyzer commentStamp: 'cw 8/6/2016 23:39' prior: 36180856!Calculates the average over k for the distortion function, the sum of the squared distances.!!AbstractAnalyzingMethod commentStamp: 'cw 8/6/2016 23:40' prior: 36039883!Template for adding different Analyzing technics, makes shure that analysing method does implement analyze method.!----SNAPSHOT----2016-08-06T23:41:05.896735+02:00 Pharo4.0.image priorSource: 2570117!!AbstractAnalyzingMethod methodsFor: 'analyzing' stamp: 'cw 8/6/2016 23:44' prior: 34311408!analyze	"makes shure that analysing method does implement analyze method." ^self subclassResponsibility ! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:45' prior: 35416981!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector euclideanDistanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	].(result at: 2) do: [ :vector| ((Vector euclideanDistanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]."calculate by average of clusters" ^sum/kc.! !!AbstractStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:48' prior: 34424818!createTokanizedStatement: aStream"creates interface for different statementizing methods."^self subclassResponsibility ! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:48' prior: 35790660!createTokanizedStatement: aStream	|statmentIdentifier  allbutnewline collection statementList|	"simple statement creator, making statement out of every newline"	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:49' prior: 36182484!createTokanizedStatement: aStream	|statmentIdentifier  allbutnewline collection statementList|	"simple statement creator, making statement out of every newline"	statementList := OrderedCollection new.	"sets up petitparser for separeting statemnts"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.		collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:49' prior: 36183140!createTokanizedStatement: aStream	|statmentIdentifier  allbutnewline collection statementList|	"simple statement creator, making statement out of every newline"	statementList := OrderedCollection new.	"sets up petitparser for separeting statemnts"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	collection := statmentIdentifier matchesSkipIn: aStream.	"Tokanizing statement and adding to statement list, containing all statements of file."	collection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:50' prior: 35995973!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:51' prior: 36184635!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:51' prior: 36185941!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !----SNAPSHOT----2016-08-06T23:52:32.655735+02:00 Pharo4.0.image priorSource: 2626870!!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:58' prior: 36187301!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:58' prior: 36188778!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:59' prior: 36190202!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/6/2016 23:59' prior: 36191646!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate current to -nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 00:01' prior: 36193152!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate current to -nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	"if number of statments in not divisable by nr, add the rest of the statements as one"	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 00:01' prior: 36194670!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate current to -nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	"if number of statments in not divisable by nr, add the rest of the lines as one statement"	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].		newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 00:01' prior: 36196276!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate current to -nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	"if number of statments in not divisable by nr, add the rest of the lines as one statement"	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].	"tokanize the list."	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!NewLineStatementmaker methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 00:01' prior: 36197887!createTokanizedStatement: aStream withLines: number	|statmentIdentifier  allbutnewline collection statementList newCollection stream lastUsedElement nr|		"simple statement creator, making statement our of the next nr of newlines"	statementList := OrderedCollection new.	"set up petitparser as delimiter for the statements"	allbutnewline := (#word asParser / #blank asParser/ #punctuation asParser)plus.	statmentIdentifier := (allbutnewline, #newline asParser star) trim flatten.	newCollection := OrderedCollection new.	nr := number.	"set default numbering as 1"	(number) ifNil:[ nr:= 1].	"petit parser get all new lines, save as collection"	collection := statmentIdentifier matchesSkipIn: aStream.	lastUsedElement :=0.	"go through all new lines and concatenate current to -nr of statements."	(1 to: collection size) do: [:k|		stream := String new writeStream.		(k % nr = 0) ifTrue:[			(0 to: nr-1)do:[:c|				|n|				n := nr -1-c.				stream nextPutAll: (collection at: (k-n)).				lastUsedElement :=k.				].			newCollection add: stream.			].		].	stream := String new writeStream.	"if number of statments in not divisable by nr, add the rest of the lines as one statement"	(collection size % nr = 0) ifFalse: [ 				(lastUsedElement+1 to: collection size)do:[:c|				stream nextPutAll: (collection at: (c)).			].		newCollection add: stream.		].	"tokanize the multiline statements"	newCollection do: [ :aStatement| statementList add: (Statement new list: (Tokanizer new tokanize: aStatement )) ].^statementList! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:02' prior: 36116626!addAnalyzedInfo: info to: path	| reference result fileName|	fileName := '\configuration_used.txt'.	"load current infor of log file"	reference := (path, fileName) asFileReference writeStream.	result := reference contents.	reference close.	"add anylzing info to current log file input"	result := result, info.	self saveFile: result to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:02' prior: 36201142!addAnalyzedInfo: info to: path	| reference result fileName|	fileName := '\configuration_used.txt'.	"load current infor of log file"	reference := (path, fileName) asFileReference writeStream.	result := reference contents.	reference close.	"add anylzing info to current log file input"	result := result, info.	"save everything back to file."	self saveFile: result to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:02' prior: 36201583!addAnalyzedInfo: info to: path	| reference result fileName|	fileName := '\configuration_used.txt'.	"load current infor of log file"	reference := (path, fileName) asFileReference writeStream.	result := reference contents.	reference close.	"add anylzing info to current log file input"	result := result, info.	"save everything back to file"	self saveFile: result to: path, fileName.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:05' prior: 35675834!clustersAsStreams: path type: type|projectPath streamList inputLoader|"loads centroid assignement in to type and saves them in individual streams"streamList := OrderedCollection new.projectPath := path , '\perfect\',type.inputLoader := FileHandler  new.		(projectPath  asFileReference allChildren)		do: [ :reference | 			|stream|			stream := String new writeStream.			(reference isFile)				ifTrue: [					stream nextPutAll: (inputLoader loadFromFile: reference).					streamList add: stream].					].	^streamList.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:05' prior: 34317667!loadFromFile: path	| reference result |	"loads input form a file to stream"	reference := path asFileReference writeStream.	result := reference contents.	reference close.	^ result! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:06' prior: 34622465!projectAsStream: projectPath	| stream inputLoader  |	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:06' prior: 36203407!projectAsStream: projectPath	| stream inputLoader |	"alows for muliple files to be put in folder and loaded as one stream for clusterin"	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:06' prior: 36203800!projectAsStream: projectPath	| stream inputLoader |	"alows for muliple files to be put in folder and loaded as one stream for clustering"	inputLoader := FileHandler  new.	stream := String new writeStream.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:06' prior: 34627996!projectAsStream: path type:type	| stream inputLoader   projectPath|	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:06' prior: 36204757!projectAsStream: path type:type	| stream inputLoader   projectPath|	"alows for muliple files to be put in folder and loaded as one stream for clustering"	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:07' prior: 36205205!projectAsStream: path type:type	| stream inputLoader   projectPath|	"alows for muliple files to be put in folder and loaded as one stream for clustering, gives specific subfolder for mutiple input folders in same root folder"	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:07' prior: 36205739!projectAsStream: path type:type	| stream inputLoader   projectPath|	"alows for muliple files to be put in folder and loaded as one stream for clustering,	 gives specific subfolder for mutiple input folders in same root folder"	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:07' prior: 36206345!projectAsStream: path type:type	| stream inputLoader   projectPath|	"alows for muliple files to be put in folder and loaded as one stream for clustering,	gives specific subfolder for mutiple input folders in same root folder"	inputLoader := FileHandler  new.	stream := String new writeStream.	projectPath := path , '\files\',type.	(projectPath  asFileReference allChildren)		do: [ :reference | 			(reference isFile)				ifTrue: [ stream nextPutAll: (inputLoader					loadFromFile: reference)] ].	^ stream contents.! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:08' prior: 35992479!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp""saves output, each statement to a file accoring to its centroid assignement."| aStream newpath |newpath := path, '\' , k asString.(1 to:k floor) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',(c floor) asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:08' prior: 36207560!save: result on: k to: path"result is a feature List, path is a String""path := path\result\type\timestamp""saves output, each statement to a file accoring to its centroid assignement, saves under timestamp and enumerates the files."| aStream newpath |newpath := path, '\' , k asString.(1 to:k floor) do: [:c|	 |count|	count := 0.	aStream := String new writeStream.	result do:[:feature|		(feature klabel = c)ifTrue:[			count := count +1.			feature statement list do: [ :token|				|string|				string := token, ' '.				aStream nextPutAll: string.				].						aStream nextPutAll: Character cr asString.						].		].		((path) asFileReference isDirectory) ifFalse:[			(path) asFileReference createDirectory.].		((newpath) asFileReference isDirectory) ifFalse:[			(newpath) asFileReference createDirectory.].		self saveFile: aStream to: newpath ,'\',(c floor) asString, '.txt'.	].! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:09' prior: 34589062!saveFile: aStream to: path	"saves stream to path"	|string|	string := aStream contents.	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: string ].! !!FileHandler methodsFor: 'loading' stamp: 'cw 8/7/2016 00:09' prior: 36209478!saveFile: aStream to: path	"saves stream to path, path must contain filename"	|string|	string := aStream contents.	path asFileReference writeStreamDo: [ :writeStream | writeStream nextPutAll: string ].! !----SNAPSHOT----2016-08-07T00:17:31.172735+02:00 Pharo4.0.image priorSource: 2634157!----QUIT----2016-08-07T00:17:35.081735+02:00 Pharo4.0.image priorSource: 2655514!----STARTUP----2016-08-07T10:51:55.582229+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 11:20' prior: 36166979!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completeness: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 11:21' prior: 36210322!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogenity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completeness: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString, Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 11:21' prior: 36212423!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentatorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogeneity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completeness: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString, Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 11:22' prior: 36132845!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'."set up information for log file"string := 'folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K: ' ,(self elbow + k2-1) asString.]."save to file configartion_used.txt"fileHandler saveFile: string to: path, fileName.! !----SNAPSHOT----2016-08-07T11:22:12.758229+02:00 Pharo4.0.image priorSource: 2655601!!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 12:44' prior: 36148081!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 12:45' prior: 36217764!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].logMsg := logMsg , Character cr asString ,'nearest Statements per centroid:' , Character cr asString.(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 12:45' prior: 36219708!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].logMsg := logMsg , Character cr asString, 'nearest Statements per centroid:' , Character cr asString.(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 12:45' prior: 36221675!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentatorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].logMsg := logMsg, Character cr asString, 'nearest Statements per centroid:' , Character cr asString.(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 12:50' prior: 36216667!saveLog: fileHandler to: path| string fileName|fileName := '\configuration_used.txt'."set up information for log file"string := 'Folder: ' , type, Character cr asString, Character cr asString.string := string, 'Representors: ' , Character cr asString, (representator typeRep asString).(representator distRep = nil) ifFalse: [  string :=  string, Character cr asString, (representator distRep asString)].(representator weightRep = nil) ifFalse: [ string := string, Character cr asString, (representator weightRep asString)].string  := string , Character cr asString, Character cr asString,  'Distortion Function values: ', Character cr asString.c do: [ :aC| string := string, aC asString, Character cr asString].k2 ifNotNil: [string := string , Character cr asString, 'Guess for K: ' ,(self elbow + k2-1) asString.]."save to file configartion_used.txt"fileHandler saveFile: string to: path, fileName.! !!WeightSummaryRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:18' prior: 35425869!asString	^'Weight Summary Representor'! !!WeightInverseRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 34697210!asString	^'Weight Inverse Representor'! !!TypeStructureRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 35998563!asString	^'Type Structure Representor'! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 34812101!asString	^'Specfic Type Representor'.! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 34700106!asString	^'Distance Zero Representor'.! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 35203578!asString^'Distance All Small Representor'! !(Smalltalk globals at: #RepresentatorRunner) rename: #RepresentorRunner!!StructureAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 36214547!analyzeVMeasure	| fileHandler perfectExample kmeansResults  perfectForAnalyzing kmeansForAnalyzing h c  v nearestStatements errorMsg logMsg |	errorMsg := ''.	logMsg := ''.	"set up parameters for kMeansRunner"	fileHandler := FileHandler new.	krunner := KMeansRunner new.	krunner loops: loops.	krunner alpha: alpha.	krunner multiline: 1.	"Interface checks"	((multiline = nil) not and: (multiline isMemberOf: SmallInteger))		ifTrue: [ krunner multiline: multiline ].	krunner representator: RepresentorRunner new.	typeRep = nil		ifTrue: [ errorMsg := errorMsg , 'TypeRep must be defined' , Character cr asString ];		ifFalse: [ krunner representator typeRep: typeRep ].	krunner representator distRep: distRep.	krunner representator weightRep: weigthRep.	perfectExample := self createResult.	(mode = nil or: mode = 1)		ifTrue: [ kmeansResults := krunner runOn: path with: k type: aType ].	mode = 2		ifTrue: [ 			kmeansResults := krunner				bestKMean: path				from: k2				to: k				onType: aType ].	"prepare results for analyzing"	perfectForAnalyzing := self resultToBuckets: perfectExample.	kmeansForAnalyzing := self resultToBuckets: kmeansResults.	"calculate scores of v measure"	h := self homogeneityof: perfectForAnalyzing nd: kmeansForAnalyzing.	c := self completenessof: perfectForAnalyzing nd: kmeansForAnalyzing.	v := 2 * (h * c) / (h + c).	"create Log Msg"	logMsg := 'homogeneity: ' , h asString , Character cr asString.	logMsg := logMsg , 'completeness: ' , c asString , Character cr asString.	logMsg := logMsg , 'v-measure: ' , v asString , Character cr asString, Character cr asString.	nearestStatements := self nearestStatementsFromCentroids: kmeansResults.	logMsg := logMsg , 'nearest Statements per centroid:' , Character cr asString.	nearestStatements do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.	^ logMsg! !!StructureFinder methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 14:19' prior: 36223642!run|krunner  message result logMsg fileHandler |	fileHandler := FileHandler new.	logMsg := ''.	"set up parameters for k-runner"	krunner := KMeansRunner new.	krunner loops:loops.	krunner alpha: alpha.	krunner multiline: 1.	(((multiline = nil )not)and:(multiline isMemberOf: SmallInteger)) ifTrue: [ krunner multiline: multiline. ].	krunner representator: RepresentorRunner new."interface checks"	(loops =nil) ifTrue: [ loops := 100].message := ''.(path = nil)ifTrue:[	message := message, 'Path is not Defined', Character cr asString.	].(k = nil)ifTrue:[	message := message,'Please define k', Character cr asString.	].((mode < 1 and: mode > 3) and: (mode isMemberOf: SmallInteger)) ifTrue: [	 message := message,'Please enter valid mode', Character cr asString.	 ].(typeRep = nil)ifTrue: [  message := message, 'TypeRep must be defined', Character cr asString];ifFalse:[	krunner representator typeRep: typeRep.	].krunner representator distRep: distRep.krunner representator weightRep: weigthRep.(mode = 1) ifTrue: [  	result := krunner runOn: path with: k type: aType. ].(mode = 2) ifTrue: [  	(k2 = nil) ifTrue: [  		message := message , 'Please define k2' , Character cr asString.				]; ifFalse:[	result := krunner bestKMean: path from: k2 to: k onType: aType.].].(message = '') ifFalse: [  ^message].((typeRep isMemberOf: TypeSpecificRepresentor) and: ((distRep = nil) and: weigthRep =nil ) )ifTrue: [ ^krunner representator typeRep reverse: (result at: 2) ].logMsg := logMsg, Character cr asString, 'nearest Statements per centroid:' , Character cr asString.(self nearestStatementsFromCentroids: result) do: [ :statement | logMsg := logMsg , statement asString , Character cr asString ].	"add analyzed information to log File"	fileHandler addAnalyzedInfo: Character cr asString , logMsg to: krunner projectPath.^result! !!AbstractRepresentator methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:15' prior: 36027055!initCentroids: k with: featureList maxedTo: aInteger|list|list := LinkedList new.(1 to: k) do: [:a| 	|feature rand|	feature := LinkedList new.	rand := Random new.		(1 to: longestFeature) do:[:b|			"scale centroids for decrease the risk of getting empty centroids"			feature add: (rand next * (maxValue/10)).		 ].	list add: feature.	  ].^list! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:15' prior: 35058445!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for short saving values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:34' prior: 36232124!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	""	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for short saving values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:34' prior: 36233359!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for short saving values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:34' prior: 36234598!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for short time saving values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:35' prior: 36235899!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:35' prior: 36237205!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| |elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:36' prior: 36238501!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:36' prior: 36239861!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.					(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:37' prior: 36241224!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict."			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:37' prior: 36242697!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].						(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:38' prior: 36244228!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:39' prior: 36245813!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				"if type already encountered, calc distane between the position of current token and last seen positon of type"				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:40' prior: 36247462!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				"if type already encountered, calc distane between the position of current token and last seen positon of type, if bigger than last distance, put new value in dict"				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:40' prior: 36249227!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				"if type already encountered, calc distane between the position of current token and last seen positon of type, if bigger than last distance, put new value in values dict"				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].		feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:40' prior: 36251045!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				"if type already encountered, calc distane between the position of current token and last seen positon of type, if bigger than last distance, put new value in values dict"				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].	"go through representation again and add new representation based on above calculations from type values"	feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceAllRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:41' prior: 36252870!makeFeaturesFrom: aFeatureList	|typePosition currentPos b typeValue|	"min object for finding larges vector element in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up dictionary for caching values"		typePosition := Dictionary new.		typeValue := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go thruogh all represetnation, come from a Type Representor"		feature representation do:[:element| 		|elemntAsInt|		"makes shure to adress all values as integers so that they are compared correctly for use of dicitionaries"		elemntAsInt :=	element asInteger.		currentPos := currentPos + 1.			"if not known add current position to typePosition dict, so to have reference when a type is first encountered"			(typePosition includesKey: elemntAsInt) ifFalse:[				typePosition at: elemntAsInt put: currentPos.			].			"set default value as 0, if type is encountered the first time"				(typeValue includesKey: elemntAsInt) ifFalse:[				typeValue at: elemntAsInt put: 0.				"if type already encountered, calc distane between the position of current token and last seen positon of type, if bigger than last distance, put new value in values dict"				]; ifTrue:[					((typeValue at: elemntAsInt) < (currentPos - typePosition at: elemntAsInt)) ifTrue: [ 						 typeValue at: elemntAsInt put: (currentPos - typePosition at: elemntAsInt) ].				].				typePosition at: elemntAsInt put: currentPos.		].	"go through representation again and add new representation based on above calculations from type values"	feature representation do:[:element| |n elemntAsInt|		elemntAsInt :=	element asInteger.		n:= typeValue at: elemntAsInt.		list add: (typeValue at: elemntAsInt).		"get biggest element for max value"		(n > b) ifTrue: [ b := n ].				].	feature representation: list.	].maxValue :=b.^aFeatureList! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:41' prior: 34760746!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |				typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:41' prior: 36256769!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:42' prior: 36257493!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:42' prior: 36258225!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		"keep track of position, for position distance calculation"		currentPos := currentPos + 1.		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:43' prior: 36259020!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		"keep track of position, for position distance calculation"		currentPos := currentPos + 1.				(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			"keep track of maxValue in represetnation"			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:45' prior: 36259877!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		"keep track of position, for position distance calculation"		currentPos := currentPos + 1.		"keep track of last found occurence of type"		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			"keep track of maxValue in represetnation"			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:45' prior: 36260783!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		"keep track of position, for position distance calculation"		currentPos := currentPos + 1.		"keep track of last found occurence of type and calc pisition distance to that."		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			list add: n.			"keep track of maxValue in represetnation"			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!DistanceZeroRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:45' prior: 36261733!makeFeaturesFrom: aFeatureList	|typePosition currentPos b|	"min for finding maxValue in representation"	b:=0.	aFeatureList do: [  :feature| 		|list |		"set up"		typePosition := Dictionary new.		currentPos := 0.		list:=OrderedCollection new.				"go through representation consigin of assigned type values"		feature representation do:[:element| |n|		"keep track of position, for position distance calculation"		currentPos := currentPos + 1.		"keep track of last found occurence of type and calc pisition distance to that."		(typePosition includesKey: (element asInteger )) ifFalse: [			typePosition at: element asInteger put: currentPos].			n := currentPos - (typePosition at: (element asInteger)).			"assignes calc pos distance to new representation"			list add: n.			"keep track of maxValue in represetnation"			(b < n) ifTrue: [ b := n ].			].	feature representation: list.	].maxValue :=b.^aFeatureList	! !!RepresentorRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:45' prior: 35562250!makeFeaturesFrom: aStatementList "Takes List containing Statement Elements, defined in StrucutureFinder"	|list|list := LinkedList new.	list := typeRep makeFeaturesFrom: aStatementList.	((distRep = nil)) ifFalse: [  list := distRep  makeFeaturesFrom: list ].	((weightRep = nil)) ifFalse: [  list := weightRep  makeFeaturesFrom: list ].	^list.! !!RepresentorRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:46' prior: 36263753!makeFeaturesFrom: aStatementList "Takes List containing Statement Elements, defined in StrucutureFinder"	|list|list := LinkedList new."concatenates and runs the usable representors"	list := typeRep makeFeaturesFrom: aStatementList.	((distRep = nil)) ifFalse: [  list := distRep  makeFeaturesFrom: list ].	((weightRep = nil)) ifFalse: [  list := weightRep  makeFeaturesFrom: list ].	^list.! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:46' prior: 35626127!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "sollte wieder ursprünglicher wert sein."		n := n rounded.		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:47' prior: 36264709!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded.		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:47' prior: 36265507!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded. "value cannot anly be integer"		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:47' prior: 36266316!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded. "value in dict cannot anly be integer"		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:47' prior: 36267156!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded. "value in dict can only be integer"		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:47' prior: 36268004!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded. "value in dict can only be integer, centroid can lie between"		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:48' prior: 36268849!reverse: cList|result|"goes thourg dictionary created in making the representation and takes the nearest available token in the dict for reversing a centroid bach to a statement"result := OrderedCollection new.cList do: [ :c|	|rep|	rep := OrderedCollection new.	c do:[ :element|		|n|		"reverse type normationion, reverse value to [0,1]"		(element <= 2 and: element > 1) ifTrue: [  n := element - 1].		(element <= 3 and: element > 2) ifTrue: [  n := element - 2].		(element <= 1 and: element > 0) ifTrue: [  n := element].		n := 1/n. "reverse norming calculation from makeFeaturesFrom:."		n := n rounded. "value in dict can only be integer, centroid can lie between"		(n > dict2 size) ifFalse: [ rep add: (dict2 at: n). ];ifTrue: [rep add: (dict2 at: dict2 size)].					].	result add: rep.	 ].^result! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:48' prior: 35464701!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |						(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:48' prior: 36270645!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].					(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:49' prior: 36273544!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:49' prior: 36276466!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:49' prior: 36279409!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature . "needs to be defined"maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:49' prior: 36282381!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3.^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:50' prior: 36285410!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1.dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:50' prior: 36288416!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new.dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:50' prior: 36291463!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new.typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:51' prior: 36294567!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall min value"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:51' prior: 36297726!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new.intId := #digit asParser plus, #any asParser not.				wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).				puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:51' prior: 36300912!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:51' prior: 36304100!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:52' prior: 36307328!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[				(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:52' prior: 36310582!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:52' prior: 36313840!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:53' prior: 36317093!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token"			(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:53' prior: 36320346!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:54' prior: 36323728!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:54' prior: 36327371!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureChars and StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:55' prior: 36331016!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:55' prior: 36334802!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:55' prior: 36338569!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:56' prior: 36342386!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found, because of legacy code, strucureChars most not only contain paired elements"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:58' prior: 36346230!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found, because of legacy code, strucureChars most not only contain paired elements"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								"include new value if "								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [							"reduces code dublication, uses code of no possible pairing found below."							strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:59' prior: 36350151!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found, because of legacy code, strucureChars most not only contain paired elements"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								"add value to "								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [							"reduces code dublication, uses code of no possible pairing found below."							strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found and type nt encountered yet"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 15:59' prior: 36354193!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found, because of legacy code, strucureChars most not only contain paired elements"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								"add value to represetnation if token already known"								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								"add value of token to representation, if pair was already encountered"								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [							"reduces code dublication, uses code of no possible pairing found below."							strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found and type nt encountered yet"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeSpecificRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:00' prior: 36358255!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"|dict typeInt typeWord typePunc featureList intId wordId puncId maxFeature runner |runner := 1."mirror of dict for possibility of reversing a centroid"dict2 := Dictionary new."stores all found tokens and the corresponding values"dict := Dictionary new."type intervall lower limit"typeInt  := 1.typeWord := 0.typePunc := 2.maxFeature := 0.featureList := LinkedList new."petitparser rules for recognising type of token"intId := #digit asParser plus, #any asParser not.wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).puncId := #punctuation asParser plus", intId not, wordId not".		aStatmentList do:[:statement|	|array feature|		feature := Feature new.		feature statement: statement.		array := Array new.		"go through all tokens"		(statement list) do: [ :aToken |			"rule if integer found, if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(intId matches: aToken) ifTrue:[(dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeInt.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeInt. 				].			].			"rule if word found  if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"			(wordId matches: aToken) ifTrue:[ (dict includesKey: aToken) ifFalse: [				dict at: aToken put: runner.				dict2 at: runner put: aToken.				feature addFeatureElement: (1/runner)+typeWord.				runner := runner +1.				]; ifTrue:[					feature addFeatureElement: (1/ (dict at: aToken)) + typeWord. 				].			].		"fule if punctation found, treat opening and closing parentheses as the same token, 		if value not already known give new value and add token with new value to dict and represetnation, normend to the type interval"					(puncId matches: aToken) ifTrue:[	" { and } should be equal!!"					|str strctChar|					"looks if token is already known or if a pair of the token is already known, paris are defined in StructureElements"					str := StructureElements getUniqueInstance.					strctChar := str returnIfContains: (aToken at:1).					"possible pair found, because of legacy code, strucureChars most not only contain paired elements"					(((strctChar = nil) not)  and: (aToken size = 1)) ifTrue: [ 						(strctChar isPaired) ifTrue: [  								"add value to represetnation if token already known"								(dict includesKey: ((aToken at: 1) asString)) ifTrue: [ feature addFeatureElement: 1/(dict at: aToken)+typePunc  ].								"add value of token to representation, if pair was already encountered"								(dict includesKey: (strctChar getPaired: ( aToken at: 1 ))asString) ifTrue: [ feature addFeatureElement: 1/(dict at: (strctChar getPaired: ( aToken at: 1 )) asString)+typePunc ].								"go to code for adding value in dict below if neither pair nor token is already encountered"								(((dict includesKey: (aToken at: 1) asString )  not ) and:( (dict includesKey: (strctChar getPaired: ( aToken at: 1 ) )asString) not )) ifTrue: [ strctChar := nil ].															]; ifFalse: [							"reduces code dublication, uses code of no possible pairing found below."							strctChar := nil].												 ]ifFalse: [strctChar := nil].					"normal adding procedure if know pair found and type nt encountered yet"					(strctChar = nil) ifTrue: [						(dict includesKey: aToken) ifTrue: [ feature addFeatureElement: (1/ (dict at: aToken)+ typePunc) ]; ifFalse:[							dict at: aToken put: runner.							dict2 at: runner put: aToken.							feature addFeatureElement: (1/runner) + typePunc.							runner := runner +1.							].						 ].					].		].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size].		].longestFeature := maxFeature.maxValue := 3. "can only be based on type values given"^featureList.  ! !!TypeStructureRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:01' prior: 34965025!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		"petitparser statements for recognizing type of token"		intId := #digit asParser plus, #any asParser not.		wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).		puncId := #punctuation asParser plus", intId not, wordId not".			aStatmentList do: [ :aStatement|  		| feature|		feature := Feature new.		feature statement: aStatement.		(aStatement list) do: [ :aToken | 			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !!TypeStructureRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:01' prior: 36366715!makeFeaturesFrom: aStatmentList "List containing Statement Elements, defined in StrucutureFinder"		|typeInt typeWord typePunc wordId puncId intId featureList maxFeature |		maxFeature := 0.		featureList := LinkedList new.		typeInt  := 1.		typeWord := 0.		typePunc := 2.		"petitparser statements for recognizing type of token"		intId := #digit asParser plus, #any asParser not.		wordId := #letter asParser plus / (#digit asParser plus, #letter asParser plus, #any asParser star).		puncId := #punctuation asParser plus", intId not, wordId not".			aStatmentList do: [ :aStatement|  		| feature|		feature := Feature new.		feature statement: aStatement.		(aStatement list) do: [ :aToken | 			"add type value for type found"			(intId matches: aToken) ifTrue:[ feature addFeatureElement: typeInt].			(wordId matches: aToken) ifTrue:[ feature addFeatureElement: typeWord].			(puncId matches: aToken) ifTrue:[ feature addFeatureElement: typePunc].			].		featureList add: feature.		(feature representation size > maxFeature) ifTrue: [  maxFeature := feature representation size]		].	longestFeature := maxFeature.	maxValue := 2.^featureList! !!WeightInverseRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:01' prior: 34786662!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	feature representation do:[ :element|		"inverse every element and add to new representation"	(element = 0) ifFalse: [ list add: (1/ (element))]; ifTrue: [list add: 0].		].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:02' prior: 36003103!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		"sum all values up from curren position to end"		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:02' prior: 36369732!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	"go throug representation and calc for each value the sum of all the next elements"	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		"sum all values up from curren position to end"		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSumFirstRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:02' prior: 36370326!makeFeaturesFrom: aFeatureList"Takes list containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list |	list := OrderedCollection new.	"go throug representation and calc for each value the sum of all the next elements"	(1 to: feature representation size) do: [ :i|		|sum| 		sum := 0.		"sum all values up from curren position to end"		(i to: feature representation size) do: [ :k|				sum := sum + (feature representation at: k).			].		list add: sum.		 ].	feature representation: list.	].maxValue :=1.^aFeatureList.! !!WeightSummaryRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:04' prior: 35443280!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			"last element cannot be summed up"			(lastElement = nil) ifTrue: [ lastElement := element ].			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			(count = feature representation size) ifTrue: [ list add: element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:04' prior: 36371689!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			"last element cannot be summed up, is itself"			(lastElement = nil) ifTrue: [ lastElement := element ].			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			(count = feature representation size) ifTrue: [ list add: element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:06' prior: 36372488!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			"last element cannot be summed up, is itself"			(lastElement = nil) ifTrue: [ lastElement := element ].			"if last element is = element do nothing, if last element := element, last element is added to representation, and new element is the last element"			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			(count = feature representation size) ifTrue: [ list add: element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!WeightSummaryRepresentor methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:06' prior: 36373298!makeFeaturesFrom: aFeatureList "List containing Features Elements, as passed throug by TypeRepresentator"aFeatureList do: [ :feature|	|list lastElement count|	lastElement := nil.	count := 0.	list := OrderedCollection new.			feature representation do:[ :element|			count := count +1.			"last element cannot be summed up, is itself"			(lastElement = nil) ifTrue: [ lastElement := element ].			"if last element is = element do nothing, if last element := element, last element is added to representation, and new element is the last element"			(((lastElement = element) not) and: ((lastElement = nil) not) )ifTrue: [  			list add: lastElement.			lastElement := element.			].			"add last element."			(count = feature representation size) ifTrue: [ list add: element ].	].feature representation: list.]."maxValue :=1.  doesnt change max Value"^aFeatureList.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:07' prior: 34695235!initialize|day hour minute second|c := OrderedCollection new.timestamp := DateAndTime current asString."set up timestamp format for folder naming"day := ''.hour:= ''.minute := ''.second := ''.(1 to: 10 )do:[ :a|	day:= day , (timestamp at: a) asString].(11 to: 13 )do:[ :a|	hour:= hour , (timestamp at: a) asString].(15 to: 16 )do:[ :a|	minute:= minute , (timestamp at: a) asString].(18 to: 19 )do:[ :a|	second:= second , (timestamp at: a) asString].timestamp :=  day, hour, minute, second.! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:07' prior: 36108225!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:08' prior: 36375833!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:08' prior: 36376963!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:08' prior: 36378156!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].						(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	"set up the result of the clustering in a collection"	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:09' prior: 36379386!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].			"for every centoird calculate the mean of the distances to the centroid and set as new centroid position"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|							(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	"set up the result of the clustering in a collection"	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:10' prior: 36380671!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].			"for every centoird calculate the mean of the distances to the centroid and set as new centroid position"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|						"if feature is assigned to current centroid sum up"						(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	"set up the result of the clustering in a collection"	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:10' prior: 36382061!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].			"for every centoird calculate the mean of the distances to the centroid and set as new centroid position"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|						"if feature is assigned to current centroid sum up"						(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				"if centroid not empty"				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	"set up the result of the clustering in a collection"	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!KMeansRunner methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:10' prior: 36383508!kMean: featureList with: k on:  aRepresentator	|centroids result iterations|	centroids := representator initCentroids: k with: featureList.	iterations := loops.	"set deafult iteration value if not set"	loops ifNil: [ iterations := 50. ].	(1 to:iterations) do:[:a|		featureList do: [ :feature|			|min|			min := 9999999999.			"assign every feature to centroid that is the nearest away"			(1 to: (centroids size)) do:[ : aC|				|d|				d :=  Vector euclideanDistanceFrom: (centroids at:aC) to: feature representation.				(d < min) ifTrue: [					min := d.					"label is the assigned cluster"					feature klabel: aC.						]. 					].				 ].			"for every centoird calculate the mean of the distances to the centroid and set as new centroid position"			(1 to: centroids size) do: [ :aC|					|tmp count|					count :=0.					tmp := LinkedList new.					featureList do: [ :feature|						"if feature is assigned to current centroid sum up"						(feature klabel = aC) ifTrue:[							count := count + 1.							tmp := Vector sumVec: tmp plus: feature representation. 							].					].				"if centroid not empty, divide trough number of assigned features"				(count > 0 ) ifTrue: [ 					centroids at: aC put: (Vector divide: tmp through: count). ].			].		].	"set up the result of the clustering in a collection"	result := OrderedCollection  new.	result add: featureList.	result add: centroids.^result! !!Vector class methodsFor: 'Math' stamp: 'cw 8/7/2016 16:11' prior: 36044834!euclideanDistanceFrom: vec1 to: vec2"C's lenght is longestFeature, feature does not have to meet this criteria, pad rest with zeros, c is a list, feature has a list""make shure v1 is the bigger"	|d v1 v2|	v1 := vec1.	v2 := vec2.	(vec1 size  - vec2 size < 0) ifTrue: [		v1 := vec2.		v2:= vec1.		]. 		d:=0.	"padd zeros while calculating, if vector lenght is not the same"	(1 to: v1 size) do: [ :cCount|		|a b|		a := v1 at:cCount.		(cCount>(v2 size)) ifFalse: [  b:= v2 at: cCount]; ifTrue: [  b:=0].		d:= d+((a-b) squared).	 ].	^d sqrt.! !!Vector class methodsFor: 'Math' stamp: 'cw 8/7/2016 16:11' prior: 36045412!sumVec: vec1 plus: vec2"pad shorter vector with zeros, make shure v1 is the bigger"| newVec v1 v2|v1:= vec1.v2:= vec2.newVec := LinkedList new.((v1 size - v2 size) < 0) ifTrue: [	v1 := vec2.	v2 := vec1.	].	"padd zeros while calculating, if vector lenght is not the same"	(1 to: v1 size )do: [ :count|			(count <= v2 size) ifTrue: [				newVec add:(( v1 at: count) + (v2 at: count)).			]; ifFalse: [				newVec add:( v1 at: count).			].		].^newVec.! !!StructureElements commentStamp: 'cw 8/7/2016 16:13' prior: 34343927!All the structure Elements that need to be stored.Could later be read out of a config file after a heuristic finds them.!!StructureElements commentStamp: 'cw 8/7/2016 16:14' prior: 36387657!Sets up Structure Array with StructreChars, legacy for use of statement tree, now used for Type Specific Representor, as to recognize pairs of parenthesis to treat as same token.Could later be read out of a config file after a heuristic finds them.!!StructureElements commentStamp: 'cw 8/7/2016 16:14' prior: 36387851!Sets up Structure Array with StructreChars, legacy for use of statement tree, now used for Type Specific Representor, as to recognize pairs of parenthesis to treat as same token.Could later be read out of a config file after a heuristic finds them.!!StructureElements commentStamp: 'cw 8/7/2016 16:14' prior: 36388173!Sets up Structure Array with StructreChars, legacy for use of statement tree, now used for Type Specific Representor, as to recognize pairs of parenthesis to treat as same token. Could later be read out of a config file after a heuristic finds them.!----SNAPSHOT----2016-08-07T16:29:45.087229+02:00 Pharo4.0.image priorSource: 2663149!!SqrSumAnalyzerTest methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:34'!setUp! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:35' prior: 36388917!setUp||! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:35' prior: 36389012!setUp|f1 f2 c1 c2|f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:36' prior: 36389110!setUp|f1 f2 c1 c2 res|res := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.! !----SNAPSHOT----2016-08-07T16:36:13.086229+02:00 Pharo4.0.image priorSource: 2834315!!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:36' prior: 36389315!setUp|f1 f2 c1 c2 res c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:36' prior: 36389641!setUp|f1 f2 c1 c2 res c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.res add:f.res add:c! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:36' prior: 36389940!setUp|f1 f2 c1 c2 res c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.res add:f.res add:c.! !TestCase subclass: #SqrSumAnalyzerTest	instanceVariableNames: 'res'	classVariableNames: ''	category: 'StructureTests'!!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:37' prior: 36390261!setUp|f1 f2 c1 c2 c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:37' prior: 36390706!setUp|f1 f2 c1 c2 c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:37' prior: 36391024!setUp|f1 f2 f3 c1 c2 c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:38' prior: 36391344!setUp|f1 f2 f3 c1 c2 c f|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:39' prior: 36391685!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:40' prior: 36392067!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:40' prior: 36392557!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:40' prior: 36393085!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.c1 add: 0.c1 add: 1.c1 add: 0.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:41' prior: 36393652!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.c1 add: 0.c1 add: 1.c1 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 2res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:41' prior: 36394252!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.c1 add: 0.c1 add: 1.c1 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 2c2 add: 0.c2 add: 0.c2 add: 2.res add:f.res add:c.! !!SqrSumAnalyzer methodsFor: 'as yet unclassified' stamp: 'cw 8/7/2016 16:47' prior: 36181687!analyze: result with: k| sum kc|kc:=k.sum := 0."Result has position one a featureList and on Pos 2 all Centroids in the exact order their label need to be."(result  at: 1)  do: [ :feature| 	sum := sum +(Vector euclideanDistanceFrom: feature representation  to: ((result at: 2) at: feature klabel))	]."remove emtpy centroids"(result at: 2) do: [ :vector| ((Vector euclideanDistanceFrom: LinkedList new to: vector)=0)ifTrue:[kc:= kc-1 ]]."calculate by average of clusters" ^sum/kc.! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:50' prior: 36394890!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.c1 add: 0.c1 add: 1.c1 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 2c2 add: 0.c2 add: 0.c2 add: 2.f add: f1.f add: f2.f add: f3.c add:c1.c add:c2.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:50'!testAnalyzeWith! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:51' prior: 36396875!testAnalyzeWithself assert: (SqrSumAnalyzer new analyze: res with: 2 = 4).! !!SqrSumAnalyzerTest methodsFor: 'running' stamp: 'cw 8/7/2016 16:51' prior: 36396149!setUp|f1 f2 f3 c1 c2 c f rep1 rep2 rep3|res := OrderedCollection new.c := OrderedCollection new.f := OrderedCollection new.f1 := Feature new.f2 := Feature new.f3 := Feature new.c1 := OrderedCollection new.c2 := OrderedCollection new.f1 klabel: 1.f2 klabel: 1.f3 klabel: 2.rep1 := OrderedCollection new.rep2 := OrderedCollection new.rep3 := OrderedCollection new.rep1 add: 1.rep1 add: 0.rep1 add: 0.rep2 add: 0.rep2 add: 0.rep2 add: 1.c1 add: 0.c1 add: 1.c1 add: 0.rep3 add: 0.rep3 add: 0.rep3 add: 2.c2 add: 0.c2 add: 0.c2 add: 2.f add: f1.f add: f2.f add: f3.c add:c1.c add:c2.res add:f.res add:c.! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:52' prior: 36396998!testAnalyzeWithself assert: (SqrSumAnalyzer new analyze: res with: 2 = 2).! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:53' prior: 36397906!testAnalyzeWithself assert: ((SqrSumAnalyzer new analyze: res with: 2) = 2).! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:53'!testAnalyze! !!SqrSumAnalyzerTest methodsFor: 'tests-as yet unclassified' stamp: 'cw 8/7/2016 16:53' prior: 36398258!testAnalyzeself assert: ((SqrSumAnalyzer new analyze: res) = 4).! !----SNAPSHOT----2016-08-07T16:58:51.572229+02:00 Pharo4.0.image priorSource: 2835035!----QUIT----2016-08-07T17:07:24.287229+02:00 Pharo4.0.image priorSource: 2844013!----STARTUP----2016-08-07T20:40:50.552808+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-08-07T20:42:52.107808+02:00 Pharo4.0.image priorSource: 2844100!----STARTUP----2016-08-20T20:10:46.502917+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT----2016-08-20T22:27:45.988917+02:00 Pharo4.0.image priorSource: 2844291!----STARTUP----2016-08-22T14:09:10.667274+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT/NOSAVE----2016-08-22T15:01:43.927274+02:00 Pharo4.0.image priorSource: 2844482!----STARTUP----2016-09-09T23:17:38.60118+02:00 as C:\Users\Cedric\Dropbox\pharo\Pharo4.0\Pharo4.0.image!----QUIT/NOSAVE----2016-09-09T23:17:46.13418+02:00 Pharo4.0.image priorSource: 2844482!