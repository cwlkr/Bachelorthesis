try : card = rfidiot . card except : print " Couldn ' t open reader ! " args = rfidiot . args card . settagtype ( args [ 0 ] ) else : card . settagtype ( card . ALL ) else : else : try : card = rfidiot . card except : card . select ( ) buffer = [ ] card . select ( ) sys . stdout . flush ( ) buffer . append ( card . data ) else : if x = = 0 : targettype = card . tagtype if not card . readblock ( 0 ) : else : sys . stdout . flush ( ) sys . stdout . flush ( ) else : try : card = rfidiot . card except : args = rfidiot . args try : card = rfidiot . card except : address = 0 address + = 1 try : card = rfidiot . card except : args = rfidiot . args help = rfidiot . help precoded = False card . FDXBIDPrint ( args [ 0 ] ) else : precoded = True else : else : id = args [ 0 ] else : out = card . FDXBID128Bit ( id ) card . settagtype ( card . Q5 ) card . select ( ) if not card . tagtype = = card . Q5 : card . settagtype ( card . ALL ) else : writetag = True else : writetag = False outbin = ' ' q5control = ' 6000F0E8 ' if writetag = = True : outhex [ 0 ] = q5control offset = 0 outhex [ 0 ] = h2control offset = 3 if x = = offset : card . settagtype ( card . EM4x05 ) card . select ( ) else : else : if x = = offset : card . reset ( ) card . settagtype ( card . EM4x05 ) card . select ( ) else : card . settagtype ( card . ALL ) print ' \ tIf a single 16 HEX digit ID is provided , it will be decoded according to the FDX - B standard . ' print ' \ tAlternatively , specifying a 4 HEX digit Application ID , 3 or 4 digit decimal country code ' print ' \ t ( normally based on ISO - 3166 country codes or ICAR . ORG manufacturer codes , range 0 - 4095 ) ' print ' \ tand a decimal National ID Number will generate a 16 HEX digit ID . ' print ' \ tMaximum value for country code is 999 according to the standard , but 4 digits will work . ' print ' \ tIf the WRITE option is specified , a Q5 or Hitag2 will be programmed to emulate FDX - B . ' 